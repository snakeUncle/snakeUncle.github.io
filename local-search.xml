<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>「云服务」通过秘钥文件SSH连接云ECS</title>
    <link href="/2020/04/17/%E9%80%9A%E8%BF%87%E7%A7%98%E9%92%A5%E6%96%87%E4%BB%B6SSH%E8%BF%9E%E6%8E%A5%E4%BA%91ECS%20-%20%E5%89%AF%E6%9C%AC/"/>
    <url>/2020/04/17/%E9%80%9A%E8%BF%87%E7%A7%98%E9%92%A5%E6%96%87%E4%BB%B6SSH%E8%BF%9E%E6%8E%A5%E4%BA%91ECS%20-%20%E5%89%AF%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h3 id="引用"><a href="#引用" class="headerlink" title="引用:"></a>引用:</h3><p><a href="https://yq.aliyun.com/articles/5184" target="_blank" rel="noopener">https://yq.aliyun.com/articles/5184</a></p><p><strong>注意事项</strong><br><strong>配置mysql:</strong></p>]]></content>
    
    
    <categories>
      
      <category>yun</category>
      
      <category>aliyun</category>
      
    </categories>
    
    
    <tags>
      
      <tag>yun</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Dream」好想快点删掉啊!!!</title>
    <link href="/2020/04/13/%E6%A2%A6%E6%83%B3/"/>
    <url>/2020/04/13/%E6%A2%A6%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="好想删掉你们"><a href="#好想删掉你们" class="headerlink" title="好想删掉你们"></a>好想删掉你们</h2><pre><code>蛋蛋疼,怀疑人生,生无可恋</code></pre><p><img src="https://github.com/snakeUncle/cloud/raw/master/2020/job.jpg" srcset="/img/loading.gif" alt="avatar"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「云服务」通过秘钥文件SSH连接云ECS</title>
    <link href="/2020/04/13/%E9%80%9A%E8%BF%87%E7%A7%98%E9%92%A5%E6%96%87%E4%BB%B6SSH%E8%BF%9E%E6%8E%A5%E4%BA%91ECS/"/>
    <url>/2020/04/13/%E9%80%9A%E8%BF%87%E7%A7%98%E9%92%A5%E6%96%87%E4%BB%B6SSH%E8%BF%9E%E6%8E%A5%E4%BA%91ECS/</url>
    
    <content type="html"><![CDATA[<h3 id="引用"><a href="#引用" class="headerlink" title="引用:"></a>引用:</h3><p><a href="https://yq.aliyun.com/articles/5184" target="_blank" rel="noopener">https://yq.aliyun.com/articles/5184</a></p><p><strong>注意事项</strong><br><strong>配置mysql:</strong></p>]]></content>
    
    
    <categories>
      
      <category>yun</category>
      
      <category>aliyun</category>
      
    </categories>
    
    
    <tags>
      
      <tag>yun</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「云服务」将hexo部署到阿里云</title>
    <link href="/2020/04/13/%E5%B0%86hexo%E9%83%A8%E7%BD%B2%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    <url>/2020/04/13/%E5%B0%86hexo%E9%83%A8%E7%BD%B2%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91/</url>
    
    <content type="html"><![CDATA[<h3 id="将Hexo部署到阿里云轻量服务器（保姆级教程）"><a href="#将Hexo部署到阿里云轻量服务器（保姆级教程）" class="headerlink" title="将Hexo部署到阿里云轻量服务器（保姆级教程）"></a>将Hexo部署到阿里云轻量服务器（保姆级教程）</h3><p>最后一步:先切换到git用户下,在修改权限<br>1 前言<br>作为有梦想的，有追求的程序员，有一个自己的个人博客简直就是必须品。你可以选择wordpress这种平台，直接使用，在任何地方只要有网络就能写博客。还可以选择hexo这种静态博客，但是发文章就没有那么随心所欲了，要在你部署的电脑上写才行。</p><p>本人之前使用的是hexo+github pages这种方式搭建博客，简单方便，感兴趣的同学可以看我之前写的这篇文章：Hexo+github pages搭建个人独立网站，绑定域名全教程</p><p>由于github是在国外的，访问速度确实慢了一些，体验有些不好。正巧上学的时候用学生优惠价格购买了几年阿里云轻量服务器，闲着也是闲着，就用来部署hexo好了，加快访问速度。</p><p>因为我是先部署了github pages，所以git安装、NodeJs安装等等都已经实现了，还没安装的有需要可以看我上面那个教程链接。</p><p>在部署的过程中，看了网上很多教程，大多是抄来抄去的，看了很多篇照着做也没有成功过，所以这篇博文是综合网上很多篇博文，加上自己的探索写出来的。网上普遍没有贴图片，看着头大，为了照顾纯小白，我这里贴上图片，一步一步来，保姆级教程。</p><p>2 环境介绍<br>我本地电脑安装的是win10(64)位。</p><p>服务器使用的是阿里云轻量服务器，配置是：</p><p>1核、2GB内存，系统盘 40GB SSD云盘<br>操作系统是CentOS 7.3。</p><p>3 本地环境部署<br>这部分在我之前写的Hexo+github pages搭建个人独立网站，绑定域名全教程这里也有，为了方便我直接拿过来这边了。</p><p>3.1 安装nodejs<br>因为Hexo需要nodejs环境，因此需要先下载安装Nodejs。点击NodeJs官网，下载最新版本。</p><p>2-2019-11-26-21-36-58.png</p><p>下载好一直next，选择一个文件夹位置在一直next即可完成，这个步骤很简单，就不放图了。</p><p>3.2 安装git<br>点击git官网，下载安装包。<br>3-2019-11-26-21-37-4.png</p><p>点击next，选择文件夹位置，然后一直next到底就行了，选择默认配置就好，默认配置会将环境变量配置好的，不需要搞得花里胡哨的。安装好后鼠标右击应该有下图这两个选项了，出现就代表安装成功了。<br>4-2019-11-26-21-37-10.png</p><p>4 使用Hexo<br>4.1 安装Hexo<br>上面环境搭建好之后，在桌面点击鼠标右键，点击 “Git Bash Here” ，输入以下两条命令。</p><p>$ npm install -g hexo-cli<br>提示：输入的时候不要输入 $ 了，因为命令行本来就已经有了。下载需要几分钟，请耐心等待一下。</p><p>可以在复制之后在git窗选择 Shift+Insert 粘贴。有一些警告WARN是不影响使用的，放心。</p><p>5-2019-11-26-21-37-18.png</p><p>4.2 初始化Hexo<br>安装好Hexo之后，新建一个文件夹，如 E:\HEXO ，然后在该文件夹内鼠标右击，选择 “Git Bash Here” ，输入以下命令。</p><p>$ hexo init<br>稍等片刻即可完成，如图：</p><p>6-2019-11-26-21-37-25.png</p><p>文件结构如图所示：</p><p>7-2019-11-26-21-37-35.png</p><p>scaffolds是模版文件夹，当你新建文章时，Hexo 会根据 scaffold 来建立文件。</p><p>source文件夹是存放用户资源的地方。</p><p>themes是主题文件夹，Hexo 会根据主题来生成静态页面，待会我们会更换成比较流行的nexT主题。</p><p>然后再输入命令行进行本地调试，即可看到初始效果啦~</p><p>$ hexo s –debug<br>访问<a href="http://localhost:4000/即可看到效果：" target="_blank" rel="noopener">http://localhost:4000/即可看到效果：</a></p><p>8-2019-11-26-21-37-43.png</p><p>4.3 更换主题为NexT<br>上面虽然本地可以调试成功了，但是默认的主题实在不是特别好看。你可以选择去官网选择自己喜欢的主题，官网主题链接<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></p><p>本篇教程选择的是当前流行的NexT主题，这个主题是我感觉用过的最好的一个了。</p><p>4.4 下载NexT主题<br>进入刚刚你创建的文件夹的themes里，比如我的 E:\HEXO\themes ，鼠标右击选择“Git Bash Here”输入以下两条命令中的一个：（这两个是一样的，只是有同学反应第一条命令不行，第二条就可以。）</p><p>$ git clone <a href="mailto:git@github.com">git@github.com</a>:iissnan/hexo-theme-next.git<br>$ git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a><br>9-2019-11-26-21-37-56.png</p><p>此时 themes 文件夹便多了一个next主题的文件夹。</p><p>10-2019-11-26-21-38-7.png</p><p>4.5 修改配置<br>打开 E:\HEXO （你的hexo根目录）下的 _config.yml 配置文件<br>11-2019-11-26-21-38-13.png</p><p>找到下面这段代码</p><h1 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h1><h2 id="Plugins-https-hexo-io-plugins"><a href="#Plugins-https-hexo-io-plugins" class="headerlink" title="Plugins: https://hexo.io/plugins/"></a>Plugins: <a href="https://hexo.io/plugins/" target="_blank" rel="noopener">https://hexo.io/plugins/</a></h2><h2 id="Themes-https-hexo-io-themes"><a href="#Themes-https-hexo-io-themes" class="headerlink" title="Themes: https://hexo.io/themes/"></a>Themes: <a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></h2><p>theme: landscape<br>将langscape替换成hexo-theme-next</p><p>theme: hexo-theme-next<br>重新在项目根目录下进行本地部署调试</p><p>$ hexo s –debug<br>即可看到效果<br>12-2019-11-26-21-38-23.png</p><p>5 配置SSH密钥<br>为了使本地可以跟远程的github建立联系，需要在本地配置SSH密钥，这样我们就可以在本地直接提交代码到GitHub上或者远端git仓库。<br>如果你是第一次配置SSH，则配置一下git的username 和 email</p><p>$ git config –global user.name “你要设置的名字”<br>$ git config –global user.email “你要设置的邮箱”<br>之后生成SSH密钥：</p><p>$ ssh-keygen -t rsa -C “你刚刚设置的邮箱”<br>如果不需要设置密码的话，连续三个回车就好了。在这之后会得到两个文件： id_rsa 和 id_rsa.pub</p><p>找到id_rsa.pub文件，用记事本打开，复制其内容。路径： C:\Users\J（你的用户名）.ssh</p><p>17-2019-11-26-21-39-3.png</p><p>6 服务器部署<br>注意：服务器是 centOS 7.3</p><p>阿里云截图如下：</p><p>1-2019-11-30-16-22-18.png</p><p>点击右上角的”远程连接”。</p><p>2-2019-11-30-16-26-8.png</p><p>输入以下命令，切换到root账号</p><p>sudo su root<br>3-2019-11-30-16-26-31.png</p><p>6.1 git配置<br>1、安装git</p><p>在刚刚的黑框里输入，然后回车：</p><p>yum install git<br>等待一下就安装好了。中途会出现</p><p>Is this ok [y/d/N]:</p><p>输入 ： y 回车即可<br>4-2019-11-30-16-27-42.png</p><p>此时git已经安装成功。</p><p>2、创建git账户</p><p>在命令框输入（下面不做重复提示了）</p><p>adduser git<br>3、添加git账户权限</p><p>chmod 740 /etc/sudoers<br>vim /etc/sudoers<br>5-2019-11-30-16-28-12.png</p><p>输入上面的命令，回车之后，进入编辑界面。</p><p>6-2019-11-30-16-28-30.png</p><p>这里要先点击 “i” 键，进入编辑模式，然后找到一下内容的地方：</p><h2 id="Allow-root-to-run-any-commands-anywhere"><a href="#Allow-root-to-run-any-commands-anywhere" class="headerlink" title="Allow root to run any commands anywhere"></a>Allow root to run any commands anywhere</h2><p>root    ALL=(ALL)     ALL<br>7-2019-11-30-16-28-45.png</p><p>添加以下内容：</p><p>git     ALL=(ALL)     ALL<br>然后按 “Esc” 键，此时最底下的—INSERT—消失，再输入 “:wq”，即保存退出。</p><p>4、改回权限</p><p>chmod 400 /etc/sudoers<br>5、设置git账户密码</p><p>sudo passwd git<br>输入两次密码就设置成功了。注意，linux下输入密码是不显示**的，你直接输入，输完回车就行了。</p><p>8-2019-11-30-16-29-3.png</p><p>6、切换至git用户，创建 ~/.ssh 文件夹和 ~/.ssh/authorized_keys 文件，并赋予相应的权限</p><p>su git<br>mkdir ~/.ssh<br>vim ~/.ssh/authorized_keys<br>按”i”进入编辑模式，将我们在win10中生成的id_rsa.pub文件中的公钥复制到authorized_keys中，按”esc”，然后按”:wq”，保存退出。</p><p>9-2019-11-30-16-29-28.png</p><p>接着，输入一下命令，赋予权限</p><p>chmod 600 /home/git/.ssh/authorized_keys<br>chmod 700 /home/git/.ssh<br>在本地Git终端中测试是否能免密登录git，其中SERVER为填写自己的云主机IP，执行输入yes后输入你之前配置的git密码，无报错就说明好了。</p><p>在电脑本地桌面，右键”Git Bash Here”，输入一下命令，其中SERVER填写自己的云主机ip，执行输入yes后不用密码说明配置成功了。</p><p>ssh -v git@SERVER<br>如果你之前配置过git，可能你会出现以下这种错误。</p><p>微信图片_20191203082833-2019-12-3-8-28-59.png</p><p>可以看到</p><p>Offending ECDSA key in /c/Users/jonty/.ssh/known_hosts:2<br>是.ssh/known_hosts 这个文件第二行出现冲突了。只要用笔记本打开，将这个文件的第二行删掉即可。</p><p>11-2019-11-30-16-29-57.png</p><p>重新执行刚刚的命令</p><p>ssh -v git@你的服务器ip<br>12-2019-11-30-16-30-12.png</p><p>这说明已经连接成功了。</p><p>6.2 创建仓库目录及相关配置<br>1、创建目录<br>在var目录下创建repo作为Git仓库目录，返回服务端命令行切换到root账户，然后输入：</p><p>mkdir /var/repo<br>13-2019-11-30-16-30-43.png</p><p>赋予权限：</p><p>chown -R git:git /var/repo<br>chmod -R 755 /var/repo<br>接下来创建hexo目录作为网站根目录，并赋予权限：</p><p>mkdir /var/hexo<br>chown -R git:git /var/hexo<br>chmod -R 755 /var/hexo<br>接下来创建一个空白的git仓库</p><p>cd /var/repo<br>git init –bare hexo.git<br>14-2019-11-30-16-31-7.png</p><p>创建一个新的 Git 钩子，用于自动部署.</p><p>在 /var/repo/hexo.git 下，有一个自动生成的 hooks 文件夹。我们需要在里边新建一个新的钩子文件 post-receive。</p><p>vim /var/repo/hexo.git/hooks/post-receive<br>进入编辑模式，然后将下面那两行代码粘贴进去，保存退出。</p><p>#!/bin/bash<br>git –work-tree=/var/hexo –git-dir=/var/repo/hexo.git checkout -f<br>修改权限：</p><p>chown -R git:git /var/repo/hexo.git/hooks/post-receive<br>chmod +x /var/repo/hexo.git/hooks/post-receive<br>到这里Git仓库已经搭建完毕了。</p><p>7 配置Nginx<br>为了部署和维护，我们使用宝塔面板来一键部署Nginx</p><p>yum install -y wget &amp;&amp; wget -O install.sh <a href="http://download.bt.cn/install/install_6.0.sh" target="_blank" rel="noopener">http://download.bt.cn/install/install_6.0.sh</a> &amp;&amp; bash install.sh<br>中途输入”y”回车等待一会就好了。在执行结果最后会出现地址，用户名，密码等。</p><p>15-2019-11-30-16-31-40.png</p><p>复制这个地址打开，输入账号密码即可进入宝塔面板。</p><p>16-2019-11-30-16-31-50.png</p><p>注意：这里也有可能你进不去面板页面，是因为你的服务器没有开8888这个端口（具体看你的宝塔面板连接的端口），去阿里云轻量服务器控制台中的“安全”-&gt;“防火墙”，右上角的”添加规则”，添加相应的端口即可。看下面的第二张图。</p><p>17-2019-11-30-16-32-0.png</p><p>18-2019-11-30-16-32-7.png</p><p>另外如果忘记了宝塔用户名密码，可以去你服务器终端输入：</p><p>cd /www/server/panel &amp;&amp; python tools.py panel testpasswd<br>下图为宝塔解决方案，链接忘记Linux 3.X/4.x/5.x/6.x 宝塔面板密码的解决方案</p><p>19-2019-11-30-16-32-26.png</p><p>进入面板之后，会提示叫你修改端口，点击”立即修改”,可以看到”面板端口”这时候是8888，自己选一个值，然后先去服务器防火墙上开放这个端口，跟刚刚的”添加规则”操作一样。</p><p>再回到宝塔面板页面将”面板端口”的值修改成你刚刚开放的端口值。</p><p>然后需要用新端口，重新进入宝塔面板，就是将原有的链接”:”后面的值改成你的端口即可。</p><p>20-2019-11-30-16-32-37.png</p><p>在宝塔面板，进入软件商店，输入”Nginx”，然后搜索，安装免费的那个。</p><p>21-2019-11-30-16-32-50.png</p><p>等待部署完成。</p><p>部署完成之后，点击网站，添加站点，填写你的域名，没有的话写你的服务器ip地址。其他的不要改。</p><p>22-2019-11-30-16-33-1.png</p><p>填写完之后提交，然后点击”设置”</p><p>23-2019-11-30-16-33-9.png</p><p>点击”配置文件”</p><p>server<br>{<br>    listen 80;<br>    # server_name填写你自己的域名，没有的话填ip<br>    server_name hjxlog.com;<br>    index index.php index.html index.htm default.php default.htm default.html;<br>    # 这里root填写自己的网站根目录，修改为/var/hexo<br>    root /var/hexo;<br>保存，然后选择“设置”-“网站目录”，将网站目录修改成以下，保存。</p><p>/var/hexo</p><p>24-2019-11-30-16-33-18.png<br>回到服务器终端，重启宝塔服务，使之生效。</p><p>service bt restart<br>8 修改hexo配置<br>进入本地电脑hexo博客的根目录，编辑站点配置文件 _config.yml，找到deploy，修改成以下</p><p>deploy:<br>  type: git<br>  #repo改为repo: git@你的域名:/var/repo/hexo.git<br>  repo: <a href="mailto:git@hjxlog.com">git@hjxlog.com</a>:/var/repo/hexo.git<br>  branch: master<br>最后在本地电脑hexo博客的根目录右击，Git Bash Here，输入以下命令部署</p><p>hexo clean<br>hexo d -g<br>这时候可能出现权限问题，导致部署到git失败。</p><p>25-2019-11-30-16-33-43.png</p><p>在服务器终端输入以下命令即可：</p><p>chown -R git:git /var/repo/<br>chown -R git:git /var/hexo/<br>最后再hexo d -g部署，应该就可以看到部署成功了。</p><p>26-2019-11-30-16-34-0.png</p><p>自此，已经将博客从GitHub pages搬到阿里云服务器了。</p><p>27-2019-11-30-16-34-7.png</p><p>9 将网站添加https访问<br>去阿里云申请一个免费的SSL证书，好像要备案，有点忘记了，很快就申请下来了。</p><p>进入宝塔面板，”网站”，”设置”，”SSL，”其他证书”</p><p>28-2019-11-30-16-34-22.png</p><p>将你申请的证书.key以及.pem内容，粘贴进去然后保存即可。</p><p>29-2019-11-30-16-34-28.png</p><p>10 持续更新<br>2020-03-15 根据评论和邮件反馈遇到的常见问题更新</p><p>12020-3-15-11-17-2</p><p>根据有同学遇到上图这种情况，如果提示</p><p>Could not resolve hostname ***.com: Name or service not known<br>Please make sure you have the correct access rights</p><p>那么看一下自己的域名是否实名验证成功了，如果已验证。可以ping一下域名看能不能ping得通，有可能是你没有把域名解析到服务器ip地址上了。</p><p>另外，Mac OS可能在配置方面和Windows不太一样。具体问题要具体分析，具体解决了。</p><p>11 总结<br>在部署网站的时候，由于之前对Linux没有经验，网络上看到几篇博客，还是没能部署成功，有些博客比如命令中的单词拼写错误，或者前后不衔接，导致部署一直有问题。</p><p>还好在部署的同时去网上学一些Linux基本命令，学到了进入编辑模式，编辑完怎么退出等等。之前看了一篇博客，可能作者默认大家都会了，结果我卡在这里了一下。</p><p>总的来说，部署还是比较简单的，第一次没成功的同学不要轻易放弃，多去网上找找答案，努力解决问题，加油！</p><p>如果因为看我的博客，在部署过程当中出现任何问题，请私信我或者邮箱联系我，帮助大家一起解决问题。</p><p>本文作者： Huang Jianxian<br>本文链接： <a href="https://hjxlog.com/posts/20191130a1.html" target="_blank" rel="noopener">https://hjxlog.com/posts/20191130a1.html</a><br>版权声明： 本文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！</p>]]></content>
    
    
    <categories>
      
      <category>yun</category>
      
      <category>aliyun</category>
      
    </categories>
    
    
    <tags>
      
      <tag>yun</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「云服务」手把手教你使用阿里云</title>
    <link href="/2020/04/09/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2020/04/09/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="引用"><a href="#引用" class="headerlink" title="引用:"></a>引用:</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247485868&amp;idx=1&amp;sn=8ce3d3fc332bab1b5c725b2a7ff323b2&amp;chksm=ebd748addca0c1bb784985997f91b9f6bdb8d1578985691ce0bb0acb271a0d2a62330bb1593b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247485868&amp;idx=1&amp;sn=8ce3d3fc332bab1b5c725b2a7ff323b2&amp;chksm=ebd748addca0c1bb784985997f91b9f6bdb8d1578985691ce0bb0acb271a0d2a62330bb1593b&amp;scene=21#wechat_redirect</a></p><p><strong>注意事项</strong><br><strong>配置mysql:</strong></p><p>检查系统是否已经有mysql用户，如果没有则创建<br>[root@localhost mysql-5.6.46]# cat /etc/passwd | grep mysql<br>[root@localhost mysql-5.6.46]# cat /etc/group | grep mysql<br>创建mysql用户（但是不能使用mysql账号登陆系统）</p><p>[root@localhost mysql-5.6.46]# groupadd mysql<br>[root@localhost mysql-5.6.46]# useradd -g mysql mysql<br>修改权限</p><p>[root@localhost mysql-5.6.46]# chown -R mysql:mysql /usr/local/mysql<br>切换到mysql目录</p><p>cd /usr/local/mysql<br>设置权限等东西</p><p> chown -R mysql:mysql .    (#这里最后是有个.的大家要注意 为了安全安装完成后请修改权限给root用户)</p><p> scripts/mysql_install_db –user=mysql    (先进行这一步再做如下权限的修改)</p><p> chown -R root:mysql .     (将权限设置给root用户，并设置给mysql组， 取消其他用户的读写执行权限，仅留给mysql “rx”读执行权限，其他用户无任何权限)</p><p> chown -R mysql:mysql ./data    (数据库存放目录设置成mysql用户mysql组)</p><p> chmod -R ug+rwx  .     (赋予读写执行权限，其他用户权限一律删除仅给mysql用户权限)</p><p>cp support-files/my-default.cnf  /etc/my.cnf<br>修改my.cnf</p><p>vi /etc/my.cnf  </p><p>在下面添加：<br>user=mysql<br>datadir=/usr/local/mysql/data<br>default-storage-engine=MyISAM<br>#skip-grant-tables 用来重置密码<br>启动mysql（还是在mysql的目录下进行的）</p><p>cp support-files/mysql.server  /etc/init.d/mysql</p><p>service mysql start<br>修改root的密码</p><p>chkconfig –add mysql<br>修改密码 cd 切换到mysql所在目录<br>cd /usr/local/mysql<br>./bin/mysqladmin -u root password   最后设置新的密码即可！<br>重启MySQL，启动客户端</p><p>service mysql restart</p><p>cd /usr/local/mysql/bin/<br>./mysql -u root -p<br>效果：成功进入到数据库</p><p>成功进入到数据库<br>参考资料：<br><a href="https://blog.csdn.net/wplblog/article/details/52179299" target="_blank" rel="noopener">https://blog.csdn.net/wplblog/article/details/52179299</a></p><h3 id="项目-https-github-com-ZhongFuCheng3y-3y"><a href="#项目-https-github-com-ZhongFuCheng3y-3y" class="headerlink" title="项目[https://github.com/ZhongFuCheng3y/3y]"></a>项目[<a href="https://github.com/ZhongFuCheng3y/3y]" target="_blank" rel="noopener">https://github.com/ZhongFuCheng3y/3y]</a></h3>]]></content>
    
    
    <categories>
      
      <category>yun</category>
      
      <category>aliyun</category>
      
    </categories>
    
    
    <tags>
      
      <tag>yun</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Java」复习重点</title>
    <link href="/2020/02/18/%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/"/>
    <url>/2020/02/18/%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="复习重点"><a href="#复习重点" class="headerlink" title="复习重点"></a>复习重点</h2><ol><li>反射</li><li>juntil</li><li>注解</li><li>springboot</li><li>spingcloud</li><li>redis</li><li>mysql</li><li>mvc</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Java」知乎大佬的学习复习路线图</title>
    <link href="/2020/02/05/%E7%9F%A5%E4%B9%8E%E5%A4%A7%E4%BD%AC%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%A4%8D%E4%B9%A0%E8%B7%AF%E7%BA%BF%E5%9B%BE/"/>
    <url>/2020/02/05/%E7%9F%A5%E4%B9%8E%E5%A4%A7%E4%BD%AC%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%A4%8D%E4%B9%A0%E8%B7%AF%E7%BA%BF%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="2018年如何快速学Java"><a href="#2018年如何快速学Java" class="headerlink" title="2018年如何快速学Java"></a>2018年如何快速学Java</h2><p><strong>原网址:</strong></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247484369&amp;idx=1&amp;sn=81beba398864b0b56cc1970e715e03b2&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247484369&amp;idx=1&amp;sn=81beba398864b0b56cc1970e715e03b2&amp;scene=21#wechat_redirect</a></p><h1 id="一、为什么我要写下这篇文章"><a href="#一、为什么我要写下这篇文章" class="headerlink" title="一、为什么我要写下这篇文章"></a>一、为什么我要写下这篇文章</h1><h2 id="1-1直接缘由："><a href="#1-1直接缘由：" class="headerlink" title="1.1直接缘由："></a>1.1直接缘由：</h2><ul><li><p>在今天(2018年11月4日)有个同学给我发微信找我</p></li><li><ul><li>同学：能不能给他一个网页他改一下，他想参考一下，然后用于做毕业设计。</li><li>3y：可以啊，你的题目是什么啊？想用Java来写吗？</li><li>同学：对啊，我现在在学Java呢(ps:之前跟该同学聊天的时候”我看着这些代码就头晕，我对电脑真不感兴趣”….真香！)</li><li>随后这个同学发了一个小视频过来，说自己在学Java。我看了一下：大概是在练习<code>&amp;^|</code>这些操作符。</li></ul></li></ul><p>最后，我告诉这同学：”你去找视频看吧，你现在学这些对你的毕业设计没有什么帮助的啊”。然后让他去B站找视频看了</p><blockquote><p>ps:我并不是说学&amp;^|这些运算符是没用的，但如果单纯是想自己用Java来写毕业设计的话，这些知识点应该是用不上的。</p></blockquote><h2 id="1-2间接缘由："><a href="#1-2间接缘由：" class="headerlink" title="1.2间接缘由："></a>1.2间接缘由：</h2><p><strong>自身经历：</strong></p><p>我学习Java也是自学的，在大学期间也是一直一个人在学(身边的同学可能家里有矿)。即便我在学习的时候也去<strong>搜了不少的意见</strong>，例如在知乎上找，，&lt;给刚开始学Java的年轻人一些建议&gt;等等类似的话题，<strong>但是</strong>现在回过头来看，我还是走了不少的”弯路”了。</p><p>比如说，当时我花了蛮多的精力去学JSP，最后整理成博客发到网上去。网友的评论：</p><ul><li><p>“不玩 JSP 十几年了“。</p></li><li><p>“jsp不是老掉牙的技术吗”。</p></li><li><p>“看这个有一种穿越的感觉……码了6w多字，看着就心疼……”。</p></li><li><p>“这十年前的技术都被挖出来了？”</p></li><li><p>“刚毕业时写过好几个自定义标签，那时候感觉好有成就感，但是现在，用于view的jsp，似乎有点过时了，view一般用【模板】或者【完全静态 + ajax + json】了”</p></li></ul><p>嗯…那篇文章我当时在2018.02.07发布。我学JSP的时候是在2017年初吧，其实在2017年JSP也已经是落后的技术了，但我还是花了不少的时间去学习JSP的各种用法(自定义标签，JSTL，EL表达式等等)。</p><p>网友们其实说得都没有毛病，对我来说：在2017年花了<strong>不少时间</strong>去学如何使用JSP(过期的技术)，这就是我认为的<strong>“弯路”</strong>。</p><ul><li>ps:在2018年花点时间了解JSP是没毛病的，但深入学习的话是没必要的。</li></ul><blockquote><p>“弯路”说明：如果你有<strong>充裕的时间，怎么学都不是事</strong>，毕竟你是真真正正地在学编程。只要在学编程，就不是弯路，最怕你不学。</p></blockquote><hr><p><strong>以这篇文章回复我部分的读者：</strong></p><p>写博客以来，还是有部分读者是零基础学Java的，有转行的、也有年轻的师弟师妹的。一般他们也问我应该怎么学Java比较好，学习Java的路线应该是怎么样的。</p><p>emmmm，我一般都是<strong>比较简单</strong>的回复一下：让他们多做笔记啊，接下来应该花时间学什么，不学什么…就完了..</p><p>所以，写完这篇文章，遇到再问我如何学习Java的时候，我直接发个链接就完事了(懒人必备)..</p><h2 id="1-3目的"><a href="#1-3目的" class="headerlink" title="1.3目的"></a>1.3目的</h2><p><strong>如果你：</strong></p><ul><li>想要用Java在短短的几个月时间内写出自己的毕业设计。</li><li>想要用Java体验一下如何从零搭建一个属于自己的网站。</li></ul><p>那么可以看一下我下面所写的<strong>不成熟的建议</strong>。</p><h1 id="二、如何快速学Java"><a href="#二、如何快速学Java" class="headerlink" title="二、如何快速学Java"></a>二、如何快速学Java</h1><blockquote><p>这里我以Java EE(Jakarta EE)/Java Web的经验来说哦。(都把你们看做是零基础入门的了)</p></blockquote><p>学习Java EE(Jakarta EE)总体来说会有以下三大模块：</p><ul><li>Java</li><li>数据库</li><li>Web前端</li></ul><p>数据库、Java、Web前端</p><p>在我看来，无论学习什么技术都好，在<strong>学习该项技术的细节之前</strong>都得知道：<strong>这项技术是什么，为什么我要学习这项技术，学习了这项技术有什么好处</strong>。</p><ul><li>看似好像我在说多余的话，但如果你在学习某项技术的时候无法回答上面的三个问题。再过几天，你很大程度上会<strong>忘记</strong>这项你所“学过”的技术。</li><li>比如说，如何你连“为什么要用多线程”你都无法用通俗的话来解释清楚。即便你<strong>当时</strong>学习的时候知道多线程可以用xxx方式来创建，多线程的xxx的api。那再过两个月，人家问你”Java多线程有什么用啊？”。你想想你还能答什么，我认为你是记不住“多线程可以用xxx方式来创建、多线程的xxx的api”这些知识点了。</li><li>再比如说，如果学习Spring时不知道IOC和new对象有什么区别，那我为啥不直接new对象而要那么麻烦去学Spring呢？</li></ul><p>简单来说：<strong>如果你不知道学习某项技术是干嘛用的，那先不要学</strong>。</p><hr><p>如果你是零基础学习Java并<strong>理解力不是爆棚</strong>的话，我建议以<strong>视频</strong>学习为主。</p><p><strong>可能</strong>你会看到这样类似的言论：</p><ul><li>“看视频学习太慢了”</li><li>“直接看源码啊，源码就是最好的解释”</li><li>“有问题直接Google啊，用什么百度”</li><li>“最好的资料是官网文档”</li><li>…..</li></ul><p>但是，那都是对有经验的人或者高智商的人群来讲的。</p><p>如果是<strong>零基础普通人</strong>，看视频学习/看不懂源码/用百度/看中文博客来学习<strong>不丢人</strong>。</p><blockquote><p>ps:如果看的视频讲师的语速不是特别快，建议以1.5或者1.75倍速观看。</p></blockquote><h2 id="2-1关于视频资源"><a href="#2-1关于视频资源" class="headerlink" title="2.1关于视频资源"></a>2.1关于视频资源</h2><p>我在学习Java的时候也收集了很多的视频资源，并不是每个都有看过。只是在混群的时候发现有人发了，就复制下来整理一下罢了。</p><ul><li><a href="https://github.com/ZhongFuCheng3y/3y/blob/master/src/resource.md" target="_blank" rel="noopener">https://github.com/ZhongFuCheng3y/3y/blob/master/src/resource.md</a></li></ul><p>其他的视频资源：</p><ul><li>B站：(bilibili.com)一个神奇的网站。如果你想看哪个视频，可以先搜一下B站有没有。</li><li>慕课网：(imooc.com)里头也有挺多的视频资源。</li><li>公众号/混qq群/微信群：不少人手里都有几t的资源，如果跟群友的关系不错，一般都会免费给你发的</li><li>……</li></ul><h2 id="2-1学习Java基础"><a href="#2-1学习Java基础" class="headerlink" title="2.1学习Java基础"></a>2.1学习Java基础</h2><p>零基础学习Java的路线我简单总结为以下：</p><ul><li><p>首先去官网下个JDK，按现在常用的版本<strong>JDK1.8</strong>就够学习了</p></li><li><ul><li>下载地址：JDK1.8下载：<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></li></ul></li><li><p>随后去下载现在Java常用的编辑器<strong>IDEA</strong>(也可以用eclipse，但现在IDEA的确是好用)..</p></li><li><ul><li>下载地址：IDEA下载：<a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">https://www.jetbrains.com/idea/</a></li></ul></li><li><p>以<strong>1.5/1.75倍速观看</strong>Java基础视频(以刘意为例)</p></li></ul><p>在学习Java基础时，我简单来说一下<strong>什么东西可以不碰</strong>：</p><ul><li><code>&amp;^|</code>位运算符，<code>++i</code>和<code>i++</code>类似这种绕死人的语法</li><li>内部类</li><li>AWT,SWING编程</li><li>注解</li></ul><p>需要<strong>深入理解</strong>的知识点：</p><ul><li><p>流程控制</p></li><li><p>面向对象的概念</p></li><li><p>Java语法</p></li><li><ul><li>this指针、重写和重载、final、static等等这些基础的东西</li></ul></li><li><p>集合(包括泛型)</p></li><li><ul><li>常用的集合类</li></ul></li><li><p>IO流</p></li><li><ul><li>IO流代码的编写  </li></ul></li><li><p>(理解这些知识点，能够在有提示的情况下码出代码，但<strong>不要为了一些细节钻牛角尖</strong>)</p></li></ul><p><strong>简单过一遍</strong>的知识：</p><ul><li>异常</li><li>多线程</li><li>网络编程</li><li>反射机制</li><li>(你<strong>得知道这个知识点是干嘛用的</strong>，为什么要学这个知识点，能看懂具体的代码！)</li></ul><p>对于上面所说<strong>深入理解</strong>的知识点，我个人是<strong>非常建议在学习期间写笔记(博客)的</strong>。如果你想写笔记的话，<strong>最好直接</strong>就用<code>markdown</code>语法来编写，而不是用word/简单的记事本。</p><p>markdown语法非常好学，几分钟跟着就可以学习了，几乎所有的it博客网站都支持<code>markdown</code>：</p><ul><li>markdown学习：<a href="https://www.jianshu.com/p/q81RER" target="_blank" rel="noopener">https://www.jianshu.com/p/q81RER</a></li></ul><p>如果喜欢<strong>画思维导图</strong>的，我这里推荐processOn就可以了。无需下载Xmind这么麻烦了：</p><ul><li>ProcessOn来画思维导图：<a href="https://www.processon.com/i/5815483ce4b0baccb2d1f8c6" target="_blank" rel="noopener">https://www.processon.com/i/5815483ce4b0baccb2d1f8c6</a></li></ul><p>有的时候并不需要使用IDEA打开一个<code>.java</code>或者<code>.xml</code>这样的文件，可以使用<code>notepad++</code>记事本：</p><ul><li>NotePad++记事本：<a href="https://notepad-plus-plus.org/" target="_blank" rel="noopener">https://notepad-plus-plus.org/</a></li></ul><p>学会科学上网和使用Chrome浏览器，比如说下载拦截广告插件，英语翻译插件</p><ul><li>Chrome浏览器：<a href="https://www.google.com/chrome/" target="_blank" rel="noopener">https://www.google.com/chrome/</a></li><li>拦截广告插件：<a href="https://chrome.google.com/webstore/search/uBlock%20Origin?hl=zh-CN&amp;_category=extensions" target="_blank" rel="noopener">https://chrome.google.com/webstore/search/uBlock%20Origin?hl=zh-CN&amp;_category=extensions</a></li><li>英语翻译插件：<a href="https://chrome.google.com/webstore/search/%E6%B2%99%E6%8B%89%20%E6%9F%A5%20%E8%AF%8D?hl=zh-CN" target="_blank" rel="noopener">https://chrome.google.com/webstore/search/%E6%B2%99%E6%8B%89%20%E6%9F%A5%20%E8%AF%8D?hl=zh-CN</a></li></ul><p>虽然是快速学习Java，但学完上面的<strong>估计得一个月了</strong>(:..</p><p>一个月发现都是面向控制台编程(console)，输入输出一些数据来玩。</p><p>控制台</p><p>期间可能就学习IO的时候可以复制文件，修改文件名有点意思。<strong>但好日子就要来临了</strong>！</p><h2 id="2-2学习Java-Web基础"><a href="#2-2学习Java-Web基础" class="headerlink" title="2.2学习Java Web基础"></a>2.2学习Java Web基础</h2><p>首先我们可以学习一下Web前端的知识(此部分都简单过一下就好了)</p><ul><li><p>HTML/CSS/JavaScript/jQuery</p></li><li><p>CSS框架(都有中文手册，很快就上手了，选一个自己喜欢的就好了)：</p></li><li><ul><li>BootStrap：<a href="http://www.bootcss.com/" target="_blank" rel="noopener">http://www.bootcss.com/</a></li><li>Materialize：<a href="http://www.materializecss.cn/" target="_blank" rel="noopener">http://www.materializecss.cn/</a></li></ul></li></ul><p>到目前为止，学完上面这些可以搭建“能看”的静态网页了。曾经看过一段话来总结上面的技术：</p><ul><li>“<strong>HTML是名词，CSS是形容词，JavaScript是动词</strong>”</li></ul><p>随后学习JavaWeb的路线如下：</p><ul><li>Tomcat(简单过一下)</li><li>XML/注解(简单过一下)</li><li>Servlet(<strong>重点理解</strong>)</li><li>HTTP协议(<strong>重点理解</strong>)</li><li>Filter过滤器(<strong>重点理解</strong>)</li><li>Listener监听器(简单过一下)</li><li>JSP(简单过一下)</li><li>AJAX、JSON(简单过一下)</li></ul><p>Servlet知识点</p><p>基于上面的学习，起码已经可以使用request对象来接收前端发送过来的数据，使用response对象将Java后端的数据返回给前端，使用Filter拦截器来处理中文乱码问题(Tomcat默认的编码是ISO-88591)。总的来说已经可以实现<strong>前后端交互了</strong>！</p><h2 id="2-3学习数据库"><a href="#2-3学习数据库" class="headerlink" title="2.3学习数据库"></a>2.3学习数据库</h2><p>数据库这里指的是关系型数据库，一般我们以<strong>MySQL</strong>来入门就足够了。</p><p>在学习期间，其实很多时间都耗费在<strong>配置环境</strong>上面，比如我之前安装JDK，安装MySQL，安装Oracle就耗费了不少时间。后来我也将其写成博客，需要重新安装的时候翻一下博客就好了。</p><ul><li>比如MySQL安装教程：<a href="https://segmentfault.com/a/1190000013530782" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013530782</a></li></ul><p>主要学习SQL的基本使用吧：</p><ul><li><strong>创建表(create table)</strong></li><li><strong>增删改查(insert,delete,update,select)</strong></li><li>对于存储过程、触发器这些了解一下即可</li><li>对于索引、锁后面再学(<strong>此部分很重要</strong>，但以快速入门来说，可以先不看)</li></ul><p>MySQL基本语法</p><h2 id="2-4学习Java连接数据库-JDBC"><a href="#2-4学习Java连接数据库-JDBC" class="headerlink" title="2.4学习Java连接数据库(JDBC)"></a>2.4学习Java连接数据库(JDBC)</h2><p>到这里，我们Java Web、数据库、Web前端的基础都已经基本学完了，但此时Java和数据库是相互独立的。我们想要以<strong>程序</strong>的方式来对数据库的数据进行操作，那就要学习一下Java连接数据库(JDBC)。</p><p>JDBC这项技术并不难呀，就是模板代码，来来去去就几个步骤：</p><ul><li>导入MySQL或者Oracle驱动包</li><li>装载数据库驱动程序</li><li>获取到与数据库连接</li><li>获取可以执行SQL语句的对象</li><li>执行SQL语句</li><li>关闭连接</li></ul><p>由于这些代码可能会重复出现，那我们可以学习一下<strong>DbUtils</strong>这个组件：可以帮我们减少编写JDBC的模板代码。</p><h2 id="2-6项目管理和框架的学习"><a href="#2-6项目管理和框架的学习" class="headerlink" title="2.6项目管理和框架的学习"></a>2.6项目管理和框架的学习</h2><p>经过上面的学习，已经是可以在本地写一个Web项目了。</p><ul><li>页面框架使用BootStrap/Materialize框架来搭好</li><li>请求处理交由Servlet，返回的数据可以通过AJAX或者使用JSP，DAO层可以使用DbUtils。</li><li>数据保存在MySQL中</li></ul><p>为了让写代码变得<strong>更爽</strong>，我建议用半天学一下<strong>Maven</strong>(项目管理工具)，用几天学一下<strong>SpringBoot</strong>。</p><ul><li>从Servlet直接跳到SpringBoot可能有点难理解，但多搞几天我相信还是可以的..</li></ul><h2 id="2-7Linux学习"><a href="#2-7Linux学习" class="headerlink" title="2.7Linux学习"></a>2.7Linux学习</h2><p>最后，我们在本地上写完的项目想要让其他人都看得见，一般都会部署在Linux环境下的。(此部分的学习可以等到将项目写完，想要部署项目才学习)</p><p>我是不推荐使用虚拟机再搞Linux的，<strong>直接买一台方便很多</strong></p><ul><li>如果是学生的话，一个月的学生版也就10块一个月。</li><li>如果是转行的大哥话，现在阿里云双十一有优惠，买起来就很便宜了。</li></ul><p><strong>优惠链接：</strong><a href="https://m.aliyun.com/act/team1111/#/share?params=N.FF7yxCciiM.pfn5xpli" target="_blank" rel="noopener">https://m.aliyun.com/act/team1111/#/share?params=N.FF7yxCciiM.pfn5xpli</a></p><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>总结一下我认为学习Java的路线：</p><ul><li>Java基础–&gt;流程控制–&gt;面向对象(包括Java语法)–&gt;Java集合–&gt;Java IO流–&gt;异常–&gt;多线程–&gt;网络编程–&gt;反射</li><li>JavaWeb基础–&gt;HTML/CSS/JavaScript/jQuery–&gt;Tomcat–&gt;XML/注解-&gt;Servlet–&gt;HTTP–&gt;Filter过滤器和监听器–&gt;JSP–&gt;AJAX/JSON–&gt;数据库(MySQL)–&gt;JDBC和DbUtils</li><li>项目管理和框架–&gt;Maven–&gt;SpringBoot</li><li>Linux基本命令</li></ul><p>最后我们的项目是这样的：</p><ul><li>以Maven来管理我们的项目</li><li>前端通过BootStrap来搭建页面框架</li><li>SpringBoot来搭建Java后端环境，SpringMVC处理前端请求(SpringBoot整合了)</li><li>DAO层使用DbUtils组件来完成，MySQL作为数据库</li></ul><p>当然了，我的Java路线不一定就是对的，我这里只是给出一种路线。</p><p>再次说明：这套路线是以“快速”学习Java的，<strong>如果你想要找到一份好工作，上面的知识点是不够的</strong>！</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「github」 做Markdown图床</title>
    <link href="/2019/02/26/github%E5%81%9AMarkdown%E5%9B%BE%E5%BA%8A/"/>
    <url>/2019/02/26/github%E5%81%9AMarkdown%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/example.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="「github」github做Markdown图床"><a href="#「github」github做Markdown图床" class="headerlink" title="「github」github做Markdown图床"></a>「github」github做Markdown图床</h2><p><strong>一:</strong><br>1，在github创建repository</p><p>2，利用github的windows客户端clone至本地</p><p>3，将需要上传的文件放入本地的文件夹</p><p>4，利用github的windows客户端commit</p><p>5，网页浏览复制图片URL，如<a href="https://github.com/zhanghlHUST/figureForMarkdown/blob/master/17_urllib_parse_urlparse.JPG，" target="_blank" rel="noopener">https://github.com/zhanghlHUST/figureForMarkdown/blob/master/17_urllib_parse_urlparse.JPG，</a><br>将URL中blob替换为raw,即<a href="https://github.com/zhanghlHUST/figureForMarkdown/raw/master/17_urllib_parse_urlparse.JPG" target="_blank" rel="noopener">https://github.com/zhanghlHUST/figureForMarkdown/raw/master/17_urllib_parse_urlparse.JPG</a></p><p><strong>二:</strong><br>利用picGo软件上传图片</p><p>作者：呆呆的张先生<br>链接：<a href="https://www.jianshu.com/p/33eeacac3344" target="_blank" rel="noopener">https://www.jianshu.com/p/33eeacac3344</a></p><hr>]]></content>
    
    
    <categories>
      
      <category>github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>day11【网络编程】</title>
    <link href="/2017/05/27/day11%E3%80%90%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%91/"/>
    <url>/2017/05/27/day11%E3%80%90%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="day11【网络编程】"><a href="#day11【网络编程】" class="headerlink" title="day11【网络编程】"></a>day11【网络编程】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul><li>软件架构CS／BS</li><li>网络通信三要素</li><li>TCP通信</li><li>Socket套接字</li><li>ServerSocket</li></ul><h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul><li><input disabled="" type="checkbox"> 能够辨别UDP和TCP协议特点</li><li><input disabled="" type="checkbox"> 能够说出TCP协议下两个常用类名称</li><li><input disabled="" type="checkbox"> 能够编写TCP协议下字符串数据传输程序</li><li><input disabled="" type="checkbox"> 能够理解TCP协议下文件上传案例</li><li><input disabled="" type="checkbox"> 能够理解TCP协议下案例2</li></ul><h1 id="第一章-网络编程入门"><a href="#第一章-网络编程入门" class="headerlink" title="第一章 网络编程入门"></a>第一章 网络编程入门</h1><h2 id="1-1软件结构"><a href="#1-1软件结构" class="headerlink" title="1.1软件结构"></a>1.1软件结构</h2><ul><li><strong>C/S结构</strong> ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。</li></ul><p><img src="img/1_cs.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>B/S结构</strong> ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。</p><p><img src="img/2_bs.jpg" srcset="/img/loading.gif" alt=""></p><p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。<strong>网络编程</strong>，就是在一定的协议下，实现两台计算机的通信的程序。</p><h2 id="1-2-网络通信协议"><a href="#1-2-网络通信协议" class="headerlink" title="1.2 网络通信协议"></a>1.2 网络通信协议</h2><ul><li><strong>网络通信协议：</strong>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</li></ul><ul><li><strong>TCP/IP协议：</strong> 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</li></ul><p><img src="img/3_tcp_ip.jpg" srcset="/img/loading.gif" alt=""></p><p>上图中，TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。<br>链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。<br>网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。<br>运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。<br>应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</p><h2 id="1-3-协议分类"><a href="#1-3-协议分类" class="headerlink" title="1.3 协议分类"></a>1.3 协议分类</h2><p>通信的协议还是比较复杂的，<code>java.net</code> 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。</p><p><code>java.net</code> 包中提供了两种常见的网络协议的支持：</p><ul><li><p><strong>UDP</strong>：用户数据报协议(User Datagram Protocol)。UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p><p>由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p><p>但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示。</p></li></ul><p><img src="img%5CUDP%E9%80%9A%E4%BF%A1%E5%9B%BE%E8%A7%A3.bmp" srcset="/img/loading.gif" alt="UDP通信图解"></p><p>特点:数据被限制在64kb以内，超出这个范围就不能发送了。</p><p>数据报(Datagram):网络传输的基本单位 </p><ul><li><p><strong>TCP</strong>：传输控制协议 (Transmission Control Protocol)。TCP协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。</p><p>在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。</p><ul><li>三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。<ul><li>第一次握手，客户端向服务器端发出连接请求，等待服务器确认。</li><li>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。</li><li>第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。</li></ul></li></ul></li></ul><p><img src="img/4_tcp.jpg" srcset="/img/loading.gif" alt=""></p><p>​    完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。</p><h2 id="1-4-网络编程三要素"><a href="#1-4-网络编程三要素" class="headerlink" title="1.4 网络编程三要素"></a>1.4 网络编程三要素</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul><li><strong>协议：</strong>计算机网络通信必须遵守的规则，已经介绍过了，不再赘述。</li></ul><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ul><li><strong>IP地址：指互联网协议地址（Internet Protocol Address）</strong>，俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。</li></ul><p><strong>IP地址分类</strong></p><ul><li><p>IPv4：是一个32位的二进制数，通常被分为4个字节，表示成<code>a.b.c.d</code> 的形式，例如<code>192.168.65.100</code> 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。</p></li><li><p>IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。</p><p>为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code>，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。</p></li></ul><p><strong>常用命令</strong></p><ul><li>查看本机IP地址，在控制台输入：</li></ul><pre><code class="java">ipconfig</code></pre><ul><li>检查网络是否连通，在控制台输入：</li></ul><pre><code class="java">ping 空格 IP地址ping 220.181.57.216</code></pre><p><strong>特殊的IP地址</strong></p><ul><li>本机IP地址：<code>127.0.0.1</code>、<code>localhost</code> 。</li></ul><h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？</p><p>如果说<strong>IP地址</strong>可以唯一标识网络中的设备，那么<strong>端口号</strong>就可以唯一标识设备中的进程（应用程序）了。</p><ul><li><strong>端口号：用两个字节表示的整数，它的取值范围是0~65535</strong>。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。</li></ul><p>利用<code>协议</code>+<code>IP地址</code>+<code>端口号</code> 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。</p><h1 id="第二章-TCP通信程序"><a href="#第二章-TCP通信程序" class="headerlink" title="第二章 TCP通信程序"></a>第二章 TCP通信程序</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。</p><p><strong>两端通信时步骤：</strong></p><ol><li>服务端程序，需要事先启动，等待客户端的连接。</li><li>客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。</li></ol><p><strong>在Java中，提供了两个类用于实现TCP通信程序：</strong></p><ol><li>客户端：<code>java.net.Socket</code> 类表示。创建<code>Socket</code>对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。</li><li>服务端：<code>java.net.ServerSocket</code> 类表示。创建<code>ServerSocket</code>对象，相当于开启一个服务，并等待客户端的连接。</li></ol><h2 id="2-2-Socket类"><a href="#2-2-Socket类" class="headerlink" title="2.2 Socket类"></a>2.2 Socket类</h2><p><code>Socket</code> 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><p><code>public Socket(String host, int port)</code> :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。  </p><blockquote><p>小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。</p></blockquote></li></ul><p>构造举例，代码如下：</p><pre><code class="java">Socket client = new Socket(&quot;127.0.0.1&quot;, 6666);</code></pre><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><ul><li><p><code>public InputStream getInputStream()</code> ： 返回此套接字的输入流。</p><ul><li>如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。</li><li>关闭生成的InputStream也将关闭相关的Socket。</li></ul></li><li><p><code>public OutputStream getOutputStream()</code> ： 返回此套接字的输出流。</p><ul><li>如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。</li><li>关闭生成的OutputStream也将关闭相关的Socket。</li></ul></li><li><p><code>public void close()</code> ：关闭此套接字。</p><ul><li>一旦一个socket被关闭，它不可再使用。</li><li>关闭此socket也将关闭相关的InputStream和OutputStream 。 </li></ul></li><li><p><code>public void shutdownOutput()</code> ： 禁用此套接字的输出流。   </p><ul><li>任何先前写出的数据将被发送，随后终止输出流。 </li></ul><h2 id="2-3-ServerSocket类"><a href="#2-3-ServerSocket类" class="headerlink" title="2.3 ServerSocket类"></a>2.3 ServerSocket类</h2></li></ul><p><code>ServerSocket</code>类：这个类实现了服务器套接字，该对象等待通过网络的请求。</p><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public ServerSocket(int port)</code> ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。</li></ul><p>构造举例，代码如下：</p><pre><code class="java">ServerSocket server = new ServerSocket(6666);</code></pre><h3 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h3><ul><li><code>public Socket accept()</code> ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 </li></ul><h2 id="2-4-简单的TCP网络程序"><a href="#2-4-简单的TCP网络程序" class="headerlink" title="2.4 简单的TCP网络程序"></a>2.4 简单的TCP网络程序</h2><h3 id="TCP通信分析图解"><a href="#TCP通信分析图解" class="headerlink" title="TCP通信分析图解"></a>TCP通信分析图解</h3><ol><li>【服务端】启动,创建ServerSocket对象，等待连接。</li><li>【客户端】启动,创建Socket对象，请求连接。</li><li>【服务端】接收连接,调用accept方法，并返回一个Socket对象。</li><li>【客户端】Socket对象，获取OutputStream，向服务端写出数据。</li><li>【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。</li></ol><blockquote><p>到此，客户端向服务端发送数据成功。</p></blockquote><p><img src="img/5_%E7%AE%80%E5%8D%95%E9%80%9A%E4%BF%A1.jpg" srcset="/img/loading.gif" alt=""></p><blockquote><p>自此，服务端向客户端回写数据。</p></blockquote><ol start="6"><li>【服务端】Socket对象，获取OutputStream，向客户端回写数据。</li><li>【客户端】Scoket对象，获取InputStream，解析回写数据。</li><li>【客户端】释放资源，断开连接。</li></ol><h3 id="客户端向服务器发送数据"><a href="#客户端向服务器发送数据" class="headerlink" title="客户端向服务器发送数据"></a>客户端向服务器发送数据</h3><p><strong>服务端实现：</strong></p><pre><code class="java">public class ServerTCP {    public static void main(String[] args) throws IOException {        System.out.println(&quot;服务端启动 , 等待连接 .... &quot;);        // 1.创建 ServerSocket对象，绑定端口，开始等待连接        ServerSocket ss = new ServerSocket(6666);        // 2.接收连接 accept 方法, 返回 socket 对象.        Socket server = ss.accept();        // 3.通过socket 获取输入流        InputStream is = server.getInputStream();        // 4.一次性读取数据          // 4.1 创建字节数组        byte[] b = new byte[1024];          // 4.2 据读取到字节数组中.        int len = is.read(b)；        // 4.3 解析数组,打印字符串信息        String msg = new String(b, 0, len);        System.out.println(msg);        //5.关闭资源.        is.close();        server.close();    }}</code></pre><p><strong>客户端实现：</strong></p><pre><code class="java">public class ClientTCP {    public static void main(String[] args) throws Exception {        System.out.println(&quot;客户端 发送数据&quot;);        // 1.创建 Socket ( ip , port ) , 确定连接到哪里.        Socket client = new Socket(&quot;localhost&quot;, 6666);        // 2.获取流对象 . 输出流        OutputStream os = client.getOutputStream();        // 3.写出数据.        os.write(&quot;你好么? tcp ,我来了&quot;.getBytes());        // 4. 关闭资源 .        os.close();        client.close();    }}</code></pre><h3 id="服务器向客户端回写数据"><a href="#服务器向客户端回写数据" class="headerlink" title="服务器向客户端回写数据"></a>服务器向客户端回写数据</h3><p><strong>服务端实现：</strong></p><pre><code class="java">public class ServerTCP {    public static void main(String[] args) throws IOException {        System.out.println(&quot;服务端启动 , 等待连接 .... &quot;);        // 1.创建 ServerSocket对象，绑定端口，开始等待连接        ServerSocket ss = new ServerSocket(6666);        // 2.接收连接 accept 方法, 返回 socket 对象.        Socket server = ss.accept();        // 3.通过socket 获取输入流        InputStream is = server.getInputStream();        // 4.一次性读取数据          // 4.1 创建字节数组        byte[] b = new byte[1024];          // 4.2 据读取到字节数组中.        int len = is.read(b)；        // 4.3 解析数组,打印字符串信息        String msg = new String(b, 0, len);        System.out.println(msg);          // =================回写数据=======================          // 5. 通过 socket 获取输出流           OutputStream out = server.getOutputStream();          // 6. 回写数据           out.write(&quot;我很好,谢谢你&quot;.getBytes());          // 7.关闭资源.          out.close();        is.close();        server.close();    }}</code></pre><p><strong>客户端实现：</strong></p><pre><code class="java">public class ClientTCP {    public static void main(String[] args) throws Exception {        System.out.println(&quot;客户端 发送数据&quot;);        // 1.创建 Socket ( ip , port ) , 确定连接到哪里.        Socket client = new Socket(&quot;localhost&quot;, 6666);        // 2.通过Scoket,获取输出流对象         OutputStream os = client.getOutputStream();        // 3.写出数据.        os.write(&quot;你好么? tcp ,我来了&quot;.getBytes());          // ==============解析回写=========================          // 4. 通过Scoket,获取 输入流对象          InputStream in = client.getInputStream();          // 5. 读取数据数据          byte[] b = new byte[100];          int len = in.read(b);          System.out.println(new String(b, 0, len));        // 6. 关闭资源 .          in.close();        os.close();        client.close();    }}</code></pre><h1 id="第三章-综合案例"><a href="#第三章-综合案例" class="headerlink" title="第三章 综合案例"></a>第三章 综合案例</h1><h2 id="3-1-文件上传案例"><a href="#3-1-文件上传案例" class="headerlink" title="3.1 文件上传案例"></a>3.1 文件上传案例</h2><h3 id="文件上传分析图解"><a href="#文件上传分析图解" class="headerlink" title="文件上传分析图解"></a>文件上传分析图解</h3><ol><li>【客户端】输入流，从硬盘读取文件数据到程序中。</li><li>【客户端】输出流，写出文件数据到服务端。</li><li>【服务端】输入流，读取文件数据到服务端程序。</li><li>【服务端】输出流，写出文件数据到服务器硬盘中。</li></ol><p><img src="img/6_upload.jpg" srcset="/img/loading.gif" alt="">    </p><h4 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h4><p><strong>服务端实现：</strong></p><pre><code class="java">public class FileUpload_Server {    public static void main(String[] args) throws IOException {        System.out.println(&quot;服务器 启动.....  &quot;);        // 1. 创建服务端ServerSocket          ServerSocket serverSocket = new ServerSocket(6666);          // 2. 建立连接         Socket accept = serverSocket.accept();          // 3. 创建流对象          // 3.1 获取输入流,读取文件数据        BufferedInputStream bis = new BufferedInputStream(accept.getInputStream());        // 3.2 创建输出流,保存到本地 .        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;copy.jpg&quot;));        // 4. 读写数据        byte[] b = new byte[1024 * 8];        int len;        while ((len = bis.read(b)) != -1) {            bos.write(b, 0, len);        }        //5. 关闭 资源        bos.close();        bis.close();        accept.close();        System.out.println(&quot;文件上传已保存&quot;);    }}</code></pre><p><strong>客户端实现：</strong></p><pre><code class="java">public class FileUPload_Client {    public static void main(String[] args) throws IOException {        // 1.创建流对象        // 1.1 创建输入流,读取本地文件          BufferedInputStream bis  = new BufferedInputStream(new FileInputStream(&quot;test.jpg&quot;));        // 1.2 创建输出流,写到服务端         Socket socket = new Socket(&quot;localhost&quot;, 6666);        BufferedOutputStream   bos   = new BufferedOutputStream(socket.getOutputStream());        //2.写出数据.         byte[] b  = new byte[1024 * 8 ];        int len ;         while (( len  = bis.read(b))!=-1) {            bos.write(b, 0, len);            bos.flush();        }        System.out.println(&quot;文件发送完毕&quot;);        // 3.释放资源        bos.close();         socket.close();        bis.close();         System.out.println(&quot;文件上传完毕 &quot;);    }}</code></pre><h3 id="文件上传优化分析"><a href="#文件上传优化分析" class="headerlink" title="文件上传优化分析"></a>文件上传优化分析</h3><ol><li><p><strong>文件名称写死的问题</strong></p><p>服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下：</p></li></ol><pre><code class="java">FileOutputStream fis = new FileOutputStream(System.currentTimeMillis()+&quot;.jpg&quot;) // 文件名称BufferedOutputStream bos = new BufferedOutputStream(fis);</code></pre><ol start="2"><li><p><strong>循环接收的问题</strong></p><p>服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下：</p></li></ol><pre><code class="java">// 每次接收新的连接,创建一个Socketwhile（true）{    Socket accept = serverSocket.accept();    ......}</code></pre><ol start="3"><li><p><strong>效率问题</strong></p><p>服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下：</p></li></ol><pre><code class="java">while（true）{    Socket accept = serverSocket.accept();    // accept 交给子线程处理.    new Thread(() -&gt; {          ......        InputStream bis = accept.getInputStream();          ......    }).start();}</code></pre><h4 id="优化实现"><a href="#优化实现" class="headerlink" title="优化实现"></a>优化实现</h4><pre><code class="java">public class FileUpload_Server {    public static void main(String[] args) throws IOException {        System.out.println(&quot;服务器 启动.....  &quot;);        // 1. 创建服务端ServerSocket        ServerSocket serverSocket = new ServerSocket(6666);          // 2. 循环接收,建立连接        while (true) {            Socket accept = serverSocket.accept();              /*               3. socket对象交给子线程处理,进行读写操作               Runnable接口中,只有一个run方法,使用lambda表达式简化格式            */            new Thread(() -&gt; {                try (                    //3.1 获取输入流对象                    BufferedInputStream bis = new BufferedInputStream(accept.getInputStream());                    //3.2 创建输出流对象, 保存到本地 .                    FileOutputStream fis = new FileOutputStream(System.currentTimeMillis() + &quot;.jpg&quot;);                    BufferedOutputStream bos = new BufferedOutputStream(fis);) {                    // 3.3 读写数据                    byte[] b = new byte[1024 * 8];                    int len;                    while ((len = bis.read(b)) != -1) {                      bos.write(b, 0, len);                    }                    //4. 关闭 资源                    bos.close();                    bis.close();                    accept.close();                    System.out.println(&quot;文件上传已保存&quot;);                } catch (IOException e) {                      e.printStackTrace();                }            }).start();        }    }}</code></pre><h3 id="信息回写分析图解"><a href="#信息回写分析图解" class="headerlink" title="信息回写分析图解"></a>信息回写分析图解</h3><p>前四步与基本文件上传一致.</p><ol start="5"><li>【服务端】获取输出流，回写数据。</li><li>【客户端】获取输入流，解析回写数据。</li></ol><p><img src="img/6_upload2.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="回写实现"><a href="#回写实现" class="headerlink" title="回写实现"></a>回写实现</h4><pre><code class="java">public class FileUpload_Server {    public static void main(String[] args) throws IOException {        System.out.println(&quot;服务器 启动.....  &quot;);        // 1. 创建服务端ServerSocket        ServerSocket serverSocket = new ServerSocket(6666);        // 2. 循环接收,建立连接        while (true) {            Socket accept = serverSocket.accept();              /*              3. socket对象交给子线程处理,进行读写操作               Runnable接口中,只有一个run方法,使用lambda表达式简化格式            */            new Thread(() -&gt; {                try (                    //3.1 获取输入流对象                    BufferedInputStream bis = new BufferedInputStream(accept.getInputStream());                    //3.2 创建输出流对象, 保存到本地 .                    FileOutputStream fis = new FileOutputStream(System.currentTimeMillis() + &quot;.jpg&quot;);                    BufferedOutputStream bos = new BufferedOutputStream(fis);                ) {                    // 3.3 读写数据                    byte[] b = new byte[1024 * 8];                    int len;                    while ((len = bis.read(b)) != -1) {                        bos.write(b, 0, len);                    }                    // 4.=======信息回写===========================                    System.out.println(&quot;back ........&quot;);                    OutputStream out = accept.getOutputStream();                    out.write(&quot;上传成功&quot;.getBytes());                    out.close();                    //================================                    //5. 关闭 资源                    bos.close();                    bis.close();                    accept.close();                    System.out.println(&quot;文件上传已保存&quot;);                } catch (IOException e) {                    e.printStackTrace();                }            }).start();        }    }}</code></pre><p><strong>客户端实现：</strong></p><pre><code class="java">public class FileUpload_Client {    public static void main(String[] args) throws IOException {        // 1.创建流对象        // 1.1 创建输入流,读取本地文件        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;test.jpg&quot;));        // 1.2 创建输出流,写到服务端        Socket socket = new Socket(&quot;localhost&quot;, 6666);        BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream());        //2.写出数据.        byte[] b  = new byte[1024 * 8 ];        int len ;        while (( len  = bis.read(b))!=-1) {            bos.write(b, 0, len);        }          // 关闭输出流,通知服务端,写出数据完毕        socket.shutdownOutput();        System.out.println(&quot;文件发送完毕&quot;);        // 3. =====解析回写============        InputStream in = socket.getInputStream();        byte[] back = new byte[20];        in.read(back);        System.out.println(new String(back));        in.close();        // ============================        // 4.释放资源        socket.close();        bis.close();    }}</code></pre><h2 id="3-2-模拟B-S服务器-扩展知识点"><a href="#3-2-模拟B-S服务器-扩展知识点" class="headerlink" title="3.2 模拟B\S服务器(扩展知识点)"></a>3.2 模拟B\S服务器(扩展知识点)</h2><p>模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。</p><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol><li><p>准备页面数据，web文件夹。</p><p>复制到我们Module中，比如复制到day08中</p><p><img src="img%5C%E5%A4%8D%E5%88%B6.png" srcset="/img/loading.gif" alt=""></p></li><li><p>我们模拟服务器端，ServerSocket类监听端口，使用浏览器访问</p><pre><code class="java">public static void main(String[] args) throws IOException {        ServerSocket server = new ServerSocket(8000);        Socket socket = server.accept();        InputStream in = socket.getInputStream();           byte[] bytes = new byte[1024];        int len = in.read(bytes);        System.out.println(new String(bytes,0,len));        socket.close();        server.close();}</code></pre><p><img src="img%5C%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>服务器程序中字节输入流可以读取到浏览器发来的请求信息</p><p><img src="img%5C%E8%AF%BB%E5%8F%96%E8%AE%BF%E9%97%AE%E4%BF%A1%E6%81%AF.jpg" srcset="/img/loading.gif" alt=""></p></li></ol><p>GET/web/index.html HTTP/1.1是浏览器的请求消息。/web/index.html为浏览器想要请求的服务器端的资源,使用字符串切割方式获取到请求的资源。</p><pre><code class="java">//转换流,读取浏览器请求第一行BufferedReader readWb = new BufferedReader(new InputStreamReader(socket.getInputStream()));String requst = readWb.readLine();//取出请求资源的路径String[] strArr = requst.split(&quot; &quot;);//去掉web前面的/String path = strArr[1].substring(1);System.out.println(path);</code></pre><h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><p>服务端实现：</p><pre><code class="java">public class SerDemo {    public static void main(String[] args) throws IOException {        System.out.println(&quot;服务端  启动 , 等待连接 .... &quot;);        // 创建ServerSocket 对象        ServerSocket server = new ServerSocket(8888);        Socket socket = server.accept();        // 转换流读取浏览器的请求消息        BufferedReader readWb = new        BufferedReader(new InputStreamReader(socket.getInputStream()));        String requst = readWb.readLine();        // 取出请求资源的路径        String[] strArr = requst.split(&quot; &quot;);        // 去掉web前面的/        String path = strArr[1].substring(1);        // 读取客户端请求的资源文件        FileInputStream fis = new FileInputStream(path);        byte[] bytes= new byte[1024];        int len = 0 ;        // 字节输出流,将文件写会客户端        OutputStream out = socket.getOutputStream();        // 写入HTTP协议响应头,固定写法        out.write(&quot;HTTP/1.1 200 OK\r\n&quot;.getBytes());        out.write(&quot;Content-Type:text/html\r\n&quot;.getBytes());        // 必须要写入空行,否则浏览器不解析        out.write(&quot;\r\n&quot;.getBytes());        while((len = fis.read(bytes))!=-1){            out.write(bytes,0,len);        }        fis.close();        out.close();        readWb.close();            socket.close();        server.close();    }}</code></pre><h3 id="访问效果"><a href="#访问效果" class="headerlink" title="访问效果"></a>访问效果</h3><ul><li><strong>火狐</strong></li></ul><p><img src="img/%E6%95%88%E6%9E%9C%E5%9B%BE1.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>小贴士：不同的浏览器，内核不一样，解析效果有可能不一样。</p></blockquote><p>发现浏览器中出现很多的叉子,说明浏览器没有读取到图片信息导致。</p><p>浏览器工作原理是遇到图片会开启一个线程进行单独的访问,因此在服务器端加入线程技术。</p><pre><code class="java">public class ServerDemo {    public static void main(String[] args) throws IOException {        ServerSocket server = new ServerSocket(8888);        while(true){            Socket socket = server.accept();            new Thread(new Web(socket)).start();        }    }    static class Web implements Runnable{        private Socket socket;        public Web(Socket socket){            this.socket=socket;        }        public void run() {            try{                //转换流,读取浏览器请求第一行                BufferedReader readWb = new                        BufferedReader(new InputStreamReader(socket.getInputStream()));                String requst = readWb.readLine();                //取出请求资源的路径                String[] strArr = requst.split(&quot; &quot;);                System.out.println(Arrays.toString(strArr));                String path = strArr[1].substring(1);                System.out.println(path);                FileInputStream fis = new FileInputStream(path);                System.out.println(fis);                byte[] bytes= new byte[1024];                int len = 0 ;                //向浏览器 回写数据                OutputStream out = socket.getOutputStream();                out.write(&quot;HTTP/1.1 200 OK\r\n&quot;.getBytes());                out.write(&quot;Content-Type:text/html\r\n&quot;.getBytes());                out.write(&quot;\r\n&quot;.getBytes());                while((len = fis.read(bytes))!=-1){                    out.write(bytes,0,len);                }                fis.close();                out.close();                readWb.close();                socket.close();            }catch(Exception ex){            }        }    }}</code></pre><p><strong>访问效果：</strong></p><p><img src="img/%E6%95%88%E6%9E%9C%E5%9B%BE2.png" srcset="/img/loading.gif" alt="">图解：</p><p><img src="img%5CBS%E9%80%9A%E4%BF%A1.bmp" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>lamda</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>day10【缓冲流、转换流、序列化流、打印流】</title>
    <link href="/2017/05/19/day10%E3%80%90%E7%BC%93%E5%86%B2%E6%B5%81%E3%80%81%E8%BD%AC%E6%8D%A2%E6%B5%81%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E3%80%81%E6%89%93%E5%8D%B0%E6%B5%81%E3%80%91/"/>
    <url>/2017/05/19/day10%E3%80%90%E7%BC%93%E5%86%B2%E6%B5%81%E3%80%81%E8%BD%AC%E6%8D%A2%E6%B5%81%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E3%80%81%E6%89%93%E5%8D%B0%E6%B5%81%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="day10【缓冲流、转换流、序列化流】"><a href="#day10【缓冲流、转换流、序列化流】" class="headerlink" title="day10【缓冲流、转换流、序列化流】"></a>day10【缓冲流、转换流、序列化流】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul><li>缓冲流</li><li>转换流</li><li>序列化流</li><li>打印流</li></ul><h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul><li><input disabled="" type="checkbox"> 能够使用字节缓冲流读取数据到程序</li><li><input disabled="" type="checkbox"> 能够使用字节缓冲流写出数据到文件</li><li><input disabled="" type="checkbox"> 能够明确字符缓冲流的作用和基本用法</li><li><input disabled="" type="checkbox"> 能够使用缓冲流的特殊功能</li><li><input disabled="" type="checkbox"> 能够阐述编码表的意义</li><li><input disabled="" type="checkbox"> 能够使用转换流读取指定编码的文本文件</li><li><input disabled="" type="checkbox"> 能够使用转换流写入指定编码的文本文件</li><li><input disabled="" type="checkbox"> 能够说出打印流的特点</li><li><input disabled="" type="checkbox"> 能够使用序列化流写出对象到文件</li><li><input disabled="" type="checkbox"> 能够使用反序列化流读取文件到程序中</li></ul><h1 id="第一章-缓冲流"><a href="#第一章-缓冲流" class="headerlink" title="第一章 缓冲流"></a>第一章 缓冲流</h1><p>昨天学习了基本的一些流，作为IO流的入门，今天我们要见识一些更强大的流。比如能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流等等。这些功能更为强大的流，都是在基本的流对象基础之上创建而来的，就像穿上铠甲的武士一样，相当于是对基本流对象的一种增强。</p><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>缓冲流,也叫高效流，是对4个基本的<code>FileXxx</code> 流的增强，所以也是4个流，按照数据类型分类：</p><ul><li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code> </li><li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li></ul><p>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</p><h2 id="1-2-字节缓冲流"><a href="#1-2-字节缓冲流" class="headerlink" title="1.2 字节缓冲流"></a>1.2 字节缓冲流</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public BufferedInputStream(InputStream in)</code> ：创建一个 新的缓冲输入流。 </li><li><code>public BufferedOutputStream(OutputStream out)</code>： 创建一个新的缓冲输出流。</li></ul><p>构造举例，代码如下：</p><pre><code class="java">// 创建字节缓冲输入流BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;bis.txt&quot;));// 创建字节缓冲输出流BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;bos.txt&quot;));</code></pre><h3 id="效率测试"><a href="#效率测试" class="headerlink" title="效率测试"></a>效率测试</h3><p>查询API，缓冲流读写方法与基本的流是一致的，我们通过复制大文件（375MB），测试它的效率。</p><ol><li>基本流，代码如下：</li></ol><pre><code class="java">public class BufferedDemo {    public static void main(String[] args) throws FileNotFoundException {        // 记录开始时间          long start = System.currentTimeMillis();        // 创建流对象        try (            FileInputStream fis = new FileInputStream(&quot;jdk9.exe&quot;);            FileOutputStream fos = new FileOutputStream(&quot;copy.exe&quot;)        ){            // 读写数据            int b;            while ((b = fis.read()) != -1) {                fos.write(b);            }        } catch (IOException e) {            e.printStackTrace();        }        // 记录结束时间        long end = System.currentTimeMillis();        System.out.println(&quot;普通流复制时间:&quot;+(end - start)+&quot; 毫秒&quot;);    }}十几分钟过去了...</code></pre><ol start="2"><li>缓冲流，代码如下：</li></ol><pre><code class="java">public class BufferedDemo {    public static void main(String[] args) throws FileNotFoundException {        // 记录开始时间          long start = System.currentTimeMillis();        // 创建流对象        try (            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;jdk9.exe&quot;));         BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;copy.exe&quot;));        ){        // 读写数据            int b;            while ((b = bis.read()) != -1) {                bos.write(b);            }        } catch (IOException e) {            e.printStackTrace();        }        // 记录结束时间        long end = System.currentTimeMillis();        System.out.println(&quot;缓冲流复制时间:&quot;+(end - start)+&quot; 毫秒&quot;);    }}缓冲流复制时间:8016 毫秒</code></pre><p>如何更快呢？</p><p>使用数组的方式，代码如下：</p><pre><code class="java">public class BufferedDemo {    public static void main(String[] args) throws FileNotFoundException {          // 记录开始时间        long start = System.currentTimeMillis();        // 创建流对象        try (            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;jdk9.exe&quot;));         BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;copy.exe&quot;));        ){              // 读写数据            int len;            byte[] bytes = new byte[8*1024];            while ((len = bis.read(bytes)) != -1) {                bos.write(bytes, 0 , len);            }        } catch (IOException e) {            e.printStackTrace();        }        // 记录结束时间        long end = System.currentTimeMillis();        System.out.println(&quot;缓冲流使用数组复制时间:&quot;+(end - start)+&quot; 毫秒&quot;);    }}缓冲流使用数组复制时间:666 毫秒</code></pre><h2 id="1-3-字符缓冲流"><a href="#1-3-字符缓冲流" class="headerlink" title="1.3 字符缓冲流"></a>1.3 字符缓冲流</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public BufferedReader(Reader in)</code> ：创建一个 新的缓冲输入流。 </li><li><code>public BufferedWriter(Writer out)</code>： 创建一个新的缓冲输出流。</li></ul><p>构造举例，代码如下：</p><pre><code class="java">// 创建字符缓冲输入流BufferedReader br = new BufferedReader(new FileReader(&quot;br.txt&quot;));// 创建字符缓冲输出流BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;bw.txt&quot;));</code></pre><h3 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h3><p>字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。</p><ul><li>BufferedReader：<code>public String readLine()</code>: 读一行文字。 </li><li>BufferedWriter：<code>public void newLine()</code>: 写一行行分隔符,由系统属性定义符号。 </li></ul><p><code>readLine</code>方法演示，代码如下：</p><pre><code class="java">public class BufferedReaderDemo {    public static void main(String[] args) throws IOException {           // 创建流对象        BufferedReader br = new BufferedReader(new FileReader(&quot;in.txt&quot;));        // 定义字符串,保存读取的一行文字        String line  = null;          // 循环读取,读取到最后返回null        while ((line = br.readLine())!=null) {            System.out.print(line);            System.out.println(&quot;------&quot;);        }        // 释放资源        br.close();    }}</code></pre><p><code>newLine</code>方法演示，代码如下：</p><pre><code class="java">public class BufferedWriterDemo throws IOException {    public static void main(String[] args) throws IOException  {          // 创建流对象        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;out.txt&quot;));          // 写出数据        bw.write(&quot;黑马&quot;);          // 写出换行        bw.newLine();        bw.write(&quot;程序&quot;);        bw.newLine();        bw.write(&quot;员&quot;);        bw.newLine();        // 释放资源        bw.close();    }}输出效果:黑马程序员</code></pre><h2 id="1-4-练习-文本排序"><a href="#1-4-练习-文本排序" class="headerlink" title="1.4 练习:文本排序"></a>1.4 练习:文本排序</h2><p>请将文本信息恢复顺序。</p><pre><code>3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。9.今当远离，临表涕零，不知所言。6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。</code></pre><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol><li>逐行读取文本信息。</li><li>解析文本信息到集合中。</li><li>遍历集合，按顺序，写出文本信息。</li></ol><h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><pre><code class="java">public class BufferedTest {    public static void main(String[] args) throws IOException {        // 创建map集合,保存文本数据,键为序号,值为文字        HashMap&lt;String, String&gt; lineMap = new HashMap&lt;&gt;();        // 创建流对象        BufferedReader br = new BufferedReader(new FileReader(&quot;in.txt&quot;));        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;out.txt&quot;));        // 读取数据        String line  = null;        while ((line = br.readLine())!=null) {            // 解析文本            String[] split = line.split(&quot;\\.&quot;);            // 保存到集合            lineMap.put(split[0],split[1]);        }        // 释放资源        br.close();        // 遍历map集合        for (int i = 1; i &lt;= lineMap.size(); i++) {            String key = String.valueOf(i);            // 获取map中文本            String value = lineMap.get(key);              // 写出拼接文本            bw.write(key+&quot;.&quot;+value);              // 写出换行            bw.newLine();        }        // 释放资源        bw.close();    }}</code></pre><h1 id="第二章-转换流"><a href="#第二章-转换流" class="headerlink" title="第二章 转换流"></a>第二章 转换流</h1><h2 id="2-1-字符编码和字符集"><a href="#2-1-字符编码和字符集" class="headerlink" title="2.1 字符编码和字符集"></a>2.1 字符编码和字符集</h2><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为<strong>编码</strong> 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为<strong>解码</strong> 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。</p><p>编码:字符(能看懂的)–字节(看不懂的)</p><p>解码:字节(看不懂的)–&gt;字符(能看懂的)</p><ul><li><p><strong>字符编码<code>Character Encoding</code></strong> : 就是一套自然语言的字符与二进制数之间的对应规则。</p><p>编码表:生活中文字和计算机中二进制的对应规则</p></li></ul><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><ul><li><strong>字符集 <code>Charset</code></strong>：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li></ul><p>计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。<img src="img/1_charset.jpg" srcset="/img/loading.gif" alt=""></p><p>可见，当指定了<strong>编码</strong>，它所对应的<strong>字符集</strong>自然就指定了，所以<strong>编码</strong>才是我们最终要关心的。</p><ul><li><strong>ASCII字符集</strong> ：<ul><li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</li><li>基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。</li></ul></li><li><strong>ISO-8859-1字符集</strong>：<ul><li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。</li><li>ISO-8859-1使用单字节编码，兼容ASCII编码。</li></ul></li><li><strong>GBxxx字符集</strong>：<ul><li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li><li><strong>GB2312</strong>：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</li><li><strong>GBK</strong>：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。</li><li><strong>GB18030</strong>：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li></ul></li><li><strong>Unicode字符集</strong> ：<ul><li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li><li>它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。</li><li>UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：<ol><li>128个US-ASCII字符，只需一个字节编码。</li><li>拉丁文等字符，需要二个字节编码。 </li><li>大部分常用字（含中文），使用三个字节编码。</li><li>其他极少使用的Unicode辅助字符，使用四字节编码。</li></ol></li></ul></li></ul><h2 id="2-2-编码引出的问题"><a href="#2-2-编码引出的问题" class="headerlink" title="2.2 编码引出的问题"></a>2.2 编码引出的问题</h2><p>在IDEA中，使用<code>FileReader</code> 读取项目中的文本文件。由于IDEA的设置，都是默认的<code>UTF-8</code>编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。</p><pre><code class="java">public class ReaderDemo {    public static void main(String[] args) throws IOException {        FileReader fileReader = new FileReader(&quot;E:\\File_GBK.txt&quot;);        int read;        while ((read = fileReader.read()) != -1) {            System.out.print((char)read);        }        fileReader.close();    }}输出结果：���</code></pre><p>那么如何读取GBK编码的文件呢？ </p><h2 id="2-3-InputStreamReader类"><a href="#2-3-InputStreamReader类" class="headerlink" title="2.3 InputStreamReader类"></a>2.3 InputStreamReader类</h2><p>转换流<code>java.io.InputStreamReader</code>，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p><h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。 </li><li><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li></ul><p>构造举例，代码如下： </p><pre><code class="java">InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;in.txt&quot;));InputStreamReader isr2 = new InputStreamReader(new FileInputStream(&quot;in.txt&quot;) , &quot;GBK&quot;);</code></pre><h3 id="指定编码读取"><a href="#指定编码读取" class="headerlink" title="指定编码读取"></a>指定编码读取</h3><pre><code class="java">public class ReaderDemo2 {    public static void main(String[] args) throws IOException {          // 定义文件路径,文件为gbk编码        String FileName = &quot;E:\\file_gbk.txt&quot;;          // 创建流对象,默认UTF8编码        InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName));          // 创建流对象,指定GBK编码        InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , &quot;GBK&quot;);        // 定义变量,保存字符        int read;          // 使用默认编码字符流读取,乱码        while ((read = isr.read()) != -1) {            System.out.print((char)read); // ��Һ�        }        isr.close();          // 使用指定编码字符流读取,正常解析        while ((read = isr2.read()) != -1) {            System.out.print((char)read);// 大家好        }        isr2.close();    }}</code></pre><h2 id="2-4-OutputStreamWriter类"><a href="#2-4-OutputStreamWriter类" class="headerlink" title="2.4 OutputStreamWriter类"></a>2.4 OutputStreamWriter类</h2><p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p><h3 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。 </li><li><code>OutputStreamWriter(OutputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li></ul><p>构造举例，代码如下： </p><pre><code class="java">OutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream(&quot;out.txt&quot;));OutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream(&quot;out.txt&quot;) , &quot;GBK&quot;);</code></pre><h3 id="指定编码写出"><a href="#指定编码写出" class="headerlink" title="指定编码写出"></a>指定编码写出</h3><pre><code class="java">public class OutputDemo {    public static void main(String[] args) throws IOException {          // 定义文件路径        String FileName = &quot;E:\\out.txt&quot;;          // 创建流对象,默认UTF8编码        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName));        // 写出数据          osw.write(&quot;你好&quot;); // 保存为6个字节        osw.close();        // 定义文件路径        String FileName2 = &quot;E:\\out2.txt&quot;;         // 创建流对象,指定GBK编码        OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),&quot;GBK&quot;);        // 写出数据          osw2.write(&quot;你好&quot;);// 保存为4个字节        osw2.close();    }}</code></pre><h3 id="转换流理解图解"><a href="#转换流理解图解" class="headerlink" title="转换流理解图解"></a>转换流理解图解</h3><p><strong>转换流是字节与字符间的桥梁！</strong><img src="img/2_zhuanhuan.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="2-5-练习：转换文件编码"><a href="#2-5-练习：转换文件编码" class="headerlink" title="2.5 练习：转换文件编码"></a>2.5 练习：转换文件编码</h2><p>将GBK编码的文本文件，转换为UTF-8编码的文本文件。</p><h3 id="案例分析-1"><a href="#案例分析-1" class="headerlink" title="案例分析"></a>案例分析</h3><ol><li>指定GBK编码的转换流，读取文本文件。</li><li>使用UTF-8编码的转换流，写出文本文件。</li></ol><h3 id="案例实现-1"><a href="#案例实现-1" class="headerlink" title="案例实现"></a>案例实现</h3><pre><code class="java">public class TransDemo {   public static void main(String[] args) {              // 1.定义文件路径         String srcFile = &quot;file_gbk.txt&quot;;        String destFile = &quot;file_utf8.txt&quot;;        // 2.创建流对象        // 2.1 转换输入流,指定GBK编码        InputStreamReader isr = new InputStreamReader(new FileInputStream(srcFile) , &quot;GBK&quot;);        // 2.2 转换输出流,默认utf8编码        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(destFile));        // 3.读写数据        // 3.1 定义数组        char[] cbuf = new char[1024];        // 3.2 定义长度        int len;        // 3.3 循环读取        while ((len = isr.read(cbuf))!=-1) {            // 循环写出              osw.write(cbuf,0,len);        }        // 4.释放资源        osw.close();        isr.close();      }}</code></pre><h1 id="第三章-序列化"><a href="#第三章-序列化" class="headerlink" title="第三章 序列化"></a>第三章 序列化</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。 </p><p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。看图理解序列化： <img src="img/3_xuliehua.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="3-2-ObjectOutputStream类"><a href="#3-2-ObjectOutputStream类" class="headerlink" title="3.2 ObjectOutputStream类"></a>3.2 ObjectOutputStream类</h2><p><code>java.io.ObjectOutputStream</code> 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</p><h3 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public ObjectOutputStream(OutputStream out)</code>： 创建一个指定OutputStream的ObjectOutputStream。</li></ul><p>构造举例，代码如下：  </p><pre><code class="java">FileOutputStream fileOut = new FileOutputStream(&quot;employee.txt&quot;);ObjectOutputStream out = new ObjectOutputStream(fileOut);</code></pre><h3 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h3><ol><li>一个对象要想序列化，必须满足两个条件:</li></ol><ul><li>该类必须实现<code>java.io.Serializable</code> 接口，<code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code>NotSerializableException</code> 。</li><li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰。</li></ul><pre><code class="java">public class Employee implements java.io.Serializable {    public String name;    public String address;    public transient int age; // transient瞬态修饰成员,不会被序列化    public void addressCheck() {          System.out.println(&quot;Address  check : &quot; + name + &quot; -- &quot; + address);    }}</code></pre><p>2.写出对象方法</p><ul><li><code>public final void writeObject (Object obj)</code> : 将指定的对象写出。</li></ul><pre><code class="java">public class SerializeDemo{       public static void main(String [] args)   {        Employee e = new Employee();        e.name = &quot;zhangsan&quot;;        e.address = &quot;beiqinglu&quot;;        e.age = 20;         try {              // 创建序列化流对象          ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;employee.txt&quot;));            // 写出对象            out.writeObject(e);            // 释放资源            out.close();            fileOut.close();            System.out.println(&quot;Serialized data is saved&quot;); // 姓名，地址被序列化，年龄没有被序列化。        } catch(IOException i)   {            i.printStackTrace();        }       }}输出结果：Serialized data is saved</code></pre><h2 id="3-3-ObjectInputStream类"><a href="#3-3-ObjectInputStream类" class="headerlink" title="3.3 ObjectInputStream类"></a>3.3 ObjectInputStream类</h2><p>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 </p><h3 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public ObjectInputStream(InputStream in)</code>： 创建一个指定InputStream的ObjectInputStream。</li></ul><h3 id="反序列化操作1"><a href="#反序列化操作1" class="headerlink" title="反序列化操作1"></a>反序列化操作1</h3><p>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用<code>ObjectInputStream</code>读取对象的方法：</p><ul><li><code>public final Object readObject ()</code> : 读取一个对象。</li></ul><pre><code class="java">public class DeserializeDemo {   public static void main(String [] args)   {        Employee e = null;        try {                     // 创建反序列化流             FileInputStream fileIn = new FileInputStream(&quot;employee.txt&quot;);             ObjectInputStream in = new ObjectInputStream(fileIn);             // 读取一个对象             e = (Employee) in.readObject();             // 释放资源             in.close();             fileIn.close();        }catch(IOException i) {             // 捕获其他异常             i.printStackTrace();             return;        }catch(ClassNotFoundException c)  {            // 捕获类找不到异常             System.out.println(&quot;Employee class not found&quot;);             c.printStackTrace();             return;        }        // 无异常,直接打印输出        System.out.println(&quot;Name: &quot; + e.name);    // zhangsan        System.out.println(&quot;Address: &quot; + e.address); // beiqinglu        System.out.println(&quot;age: &quot; + e.age); // 0    }}</code></pre><p><strong>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</strong>  </p><h3 id="反序列化操作2"><a href="#反序列化操作2" class="headerlink" title="反序列化操作2"></a><strong>反序列化操作2</strong></h3><p><strong>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个<code>InvalidClassException</code>异常。</strong>发生这个异常的原因如下：</p><ul><li>该类的序列版本号与从流中读取的类描述符的版本号不匹配 </li><li>该类包含未知数据类型 </li><li>该类没有可访问的无参数构造方法 </li></ul><p><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号。<code>serialVersionUID</code> 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p><pre><code class="java">public class Employee implements java.io.Serializable {     // 加入序列版本号     private static final long serialVersionUID = 1L;     public String name;     public String address;     // 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.     public int eid;      public void addressCheck() {         System.out.println(&quot;Address  check : &quot; + name + &quot; -- &quot; + address);     }}</code></pre><h2 id="3-4-练习：序列化集合"><a href="#3-4-练习：序列化集合" class="headerlink" title="3.4 练习：序列化集合"></a>3.4 练习：序列化集合</h2><ol><li>将存有多个自定义对象的集合序列化操作，保存到<code>list.txt</code>文件中。</li><li>反序列化<code>list.txt</code> ，并遍历集合，打印对象信息。</li></ol><h3 id="案例分析-2"><a href="#案例分析-2" class="headerlink" title="案例分析"></a>案例分析</h3><ol><li>把若干学生对象 ，保存到集合中。</li><li>把集合序列化。</li><li>反序列化读取时，只需要读取一次，转换为集合类型。</li><li>遍历集合，可以打印所有的学生信息</li></ol><h3 id="案例实现-2"><a href="#案例实现-2" class="headerlink" title="案例实现"></a>案例实现</h3><pre><code class="java">public class SerTest {    public static void main(String[] args) throws Exception {        // 创建 学生对象        Student student = new Student(&quot;老王&quot;, &quot;laow&quot;);        Student student2 = new Student(&quot;老张&quot;, &quot;laoz&quot;);        Student student3 = new Student(&quot;老李&quot;, &quot;laol&quot;);        ArrayList&lt;Student&gt; arrayList = new ArrayList&lt;&gt;();        arrayList.add(student);        arrayList.add(student2);        arrayList.add(student3);        // 序列化操作        // serializ(arrayList);        // 反序列化          ObjectInputStream ois  = new ObjectInputStream(new FileInputStream(&quot;list.txt&quot;));        // 读取对象,强转为ArrayList类型        ArrayList&lt;Student&gt; list  = (ArrayList&lt;Student&gt;)ois.readObject();          for (int i = 0; i &lt; list.size(); i++ ){              Student s = list.get(i);            System.out.println(s.getName()+&quot;--&quot;+ s.getPwd());          }    }    private static void serializ(ArrayList&lt;Student&gt; arrayList) throws Exception {        // 创建 序列化流         ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;list.txt&quot;));        // 写出对象        oos.writeObject(arrayList);        // 释放资源        oos.close();    }}</code></pre><h1 id="第四章-打印流"><a href="#第四章-打印流" class="headerlink" title="第四章 打印流"></a>第四章 打印流</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>平时我们在控制台打印输出，是调用<code>print</code>方法和<code>println</code>方法完成的，这两个方法都来自于<code>java.io.PrintStream</code>类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</p><h2 id="4-2-PrintStream类"><a href="#4-2-PrintStream类" class="headerlink" title="4.2 PrintStream类"></a>4.2 PrintStream类</h2><h3 id="构造方法-6"><a href="#构造方法-6" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public PrintStream(String fileName)</code>： 使用指定的文件名创建一个新的打印流。</li></ul><p>构造举例，代码如下：  </p><pre><code class="java">PrintStream ps = new PrintStream(&quot;ps.txt&quot;)；</code></pre><h3 id="改变打印流向"><a href="#改变打印流向" class="headerlink" title="改变打印流向"></a>改变打印流向</h3><p><code>System.out</code>就是<code>PrintStream</code>类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个”小把戏”，改变它的流向。</p><pre><code class="java">public class PrintDemo {    public static void main(String[] args) throws IOException {        // 调用系统的打印流,控制台直接输出97        System.out.println(97);        // 创建打印流,指定文件的名称        PrintStream ps = new PrintStream(&quot;ps.txt&quot;);          // 设置系统的打印流流向,输出到ps.txt        System.setOut(ps);          // 调用系统的打印流,ps.txt中输出97        System.out.println(97);    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>lamda</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>day09【字节流、字符流】</title>
    <link href="/2017/05/11/day09%E3%80%90%E5%AD%97%E8%8A%82%E6%B5%81%E3%80%81%E5%AD%97%E7%AC%A6%E6%B5%81%E3%80%91/"/>
    <url>/2017/05/11/day09%E3%80%90%E5%AD%97%E8%8A%82%E6%B5%81%E3%80%81%E5%AD%97%E7%AC%A6%E6%B5%81%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="day09【字节流、字符流】"><a href="#day09【字节流、字符流】" class="headerlink" title="day09【字节流、字符流】"></a>day09【字节流、字符流】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul><li>IO流</li><li>字节流</li><li>字符流</li><li>异常处理</li><li>Properties</li></ul><h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul><li><input disabled="" type="checkbox"> 能够说出IO流的分类和功能</li><li><input disabled="" type="checkbox"> 能够使用字节输出流写出数据到文件</li><li><input disabled="" type="checkbox"> 能够使用字节输入流读取数据到程序</li><li><input disabled="" type="checkbox"> 能够理解读取数据read(byte[])方法的原理</li><li><input disabled="" type="checkbox"> 能够使用字节流完成文件的复制</li><li><input disabled="" type="checkbox"> 能够使用FileWirter写数据到文件</li><li><input disabled="" type="checkbox"> 能够说出FileWriter中关闭和刷新方法的区别</li><li><input disabled="" type="checkbox"> 能够使用FileWriter写数据的5个方法</li><li><input disabled="" type="checkbox"> 能够使用FileWriter写数据实现换行和追加写</li><li><input disabled="" type="checkbox"> 能够使用FileReader读数据</li><li><input disabled="" type="checkbox"> 能够使用FileReader读数据一次一个字符数组</li><li><input disabled="" type="checkbox"> 能够使用Properties的load方法加载文件中配置信息</li></ul><h1 id="第一章-IO概述"><a href="#第一章-IO概述" class="headerlink" title="第一章 IO概述"></a>第一章 IO概述</h1><h2 id="1-1-什么是IO"><a href="#1-1-什么是IO" class="headerlink" title="1.1 什么是IO"></a>1.1 什么是IO</h2><p>生活中，你肯定经历过这样的场景。当你编辑一个文本文件，忘记了<code>ctrl+s</code> ，可能文件就白白编辑了。当你电脑上插入一个U盘，可以把一个视频，拷贝到你的电脑硬盘里。那么数据都是在哪些设备上的呢？键盘、内存、硬盘、外接设备等等。</p><p>我们把这种数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为<code>输入input</code> 和<code>输出output</code> ，即流向内存是输入流，流出内存的输出流。</p><p>Java中I/O操作主要是指使用<code>java.io</code>包下的内容，进行输入、输出操作。<strong>输入</strong>也叫做<strong>读取</strong>数据，<strong>输出</strong>也叫做作<strong>写出</strong>数据。</p><h2 id="1-2-IO的分类"><a href="#1-2-IO的分类" class="headerlink" title="1.2 IO的分类"></a>1.2 IO的分类</h2><p>根据数据的流向分为：<strong>输入流</strong>和<strong>输出流</strong>。</p><ul><li><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。 </li><li><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。</li></ul><p>格局数据的类型分为：<strong>字节流</strong>和<strong>字符流</strong>。</p><ul><li><strong>字节流</strong> ：以字节为单位，读写数据的流。</li><li><strong>字符流</strong> ：以字符为单位，读写数据的流。</li></ul><h2 id="1-3-IO的流向说明图解"><a href="#1-3-IO的流向说明图解" class="headerlink" title="1.3 IO的流向说明图解"></a>1.3 IO的流向说明图解</h2><p><img src="img/1_io.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="1-4-顶级父类们"><a href="#1-4-顶级父类们" class="headerlink" title="1.4 顶级父类们"></a>1.4 顶级父类们</h2><table><thead><tr><th align="center"></th><th align="center"><strong>输入流</strong></th><th align="center">输出流</th></tr></thead><tbody><tr><td align="center"><strong>字节流</strong></td><td align="center">字节输入流<br /><strong>InputStream</strong></td><td align="center">字节输出流<br /><strong>OutputStream</strong></td></tr><tr><td align="center"><strong>字符流</strong></td><td align="center">字符输入流<br /><strong>Reader</strong></td><td align="center">字符输出流<br /><strong>Writer</strong></td></tr></tbody></table><h1 id="第二章-字节流"><a href="#第二章-字节流" class="headerlink" title="第二章 字节流"></a>第二章 字节流</h1><h2 id="2-1-一切皆为字节"><a href="#2-1-一切皆为字节" class="headerlink" title="2.1 一切皆为字节"></a>2.1 一切皆为字节</h2><p>一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。</p><h2 id="2-2-字节输出流【OutputStream】"><a href="#2-2-字节输出流【OutputStream】" class="headerlink" title="2.2 字节输出流【OutputStream】"></a>2.2 字节输出流【OutputStream】</h2><p><code>java.io.OutputStream</code>抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。  </li><li><code>public void flush()</code> ：刷新此输出流并强制任何缓冲的输出字节被写出。  </li><li><code>public void write(byte[] b)</code>：将 b.length字节从指定的字节数组写入此输出流。  </li><li><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  </li><li><code>public abstract void write(int b)</code> ：将指定的字节输出流。</li></ul><blockquote><p>小贴士：</p><p>close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p></blockquote><h2 id="2-3-FileOutputStream类"><a href="#2-3-FileOutputStream类" class="headerlink" title="2.3 FileOutputStream类"></a>2.3 FileOutputStream类</h2><p><code>OutputStream</code>有很多子类，我们从最简单的一个子类开始。</p><p><code>java.io.FileOutputStream</code>类是文件输出流，用于将数据写出到文件。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public FileOutputStream(File file)</code>：创建文件输出流以写入由指定的 File对象表示的文件。 </li><li><code>public FileOutputStream(String name)</code>： 创建文件输出流以指定的名称写入文件。  </li></ul><p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。</p><ul><li>构造举例，代码如下：</li></ul><pre><code class="java">public class FileOutputStreamConstructor throws IOException {    public static void main(String[] args) {            // 使用File对象创建流对象        File file = new File(&quot;a.txt&quot;);        FileOutputStream fos = new FileOutputStream(file);        // 使用文件名称创建流对象        FileOutputStream fos = new FileOutputStream(&quot;b.txt&quot;);    }}</code></pre><h3 id="写出字节数据"><a href="#写出字节数据" class="headerlink" title="写出字节数据"></a>写出字节数据</h3><ol><li><strong>写出字节</strong>：<code>write(int b)</code> 方法，每次可以写出一个字节数据，代码使用演示：</li></ol><pre><code class="java">public class FOSWrite {    public static void main(String[] args) throws IOException {        // 使用文件名称创建流对象        FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);               // 写出数据          fos.write(97); // 写出第1个字节          fos.write(98); // 写出第2个字节          fos.write(99); // 写出第3个字节          // 关闭资源        fos.close();    }}输出结果：abc</code></pre><blockquote><p>小贴士：</p><ol><li>虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。</li><li>流操作完毕后，必须释放系统资源，调用close方法，千万记得。</li></ol></blockquote><ol start="2"><li><strong>写出字节数组</strong>：<code>write(byte[] b)</code>，每次可以写出数组中的数据，代码使用演示：</li></ol><pre><code class="java">public class FOSWrite {    public static void main(String[] args) throws IOException {        // 使用文件名称创建流对象        FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);               // 字符串转换为字节数组          byte[] b = &quot;黑马程序员&quot;.getBytes();          // 写出字节数组数据          fos.write(b);          // 关闭资源        fos.close();    }}输出结果：黑马程序员</code></pre><ol start="3"><li><strong>写出指定长度字节数组</strong>：<code>write(byte[] b, int off, int len)</code> ,每次写出从off索引开始，len个字节，代码使用演示：</li></ol><pre><code class="java">public class FOSWrite {    public static void main(String[] args) throws IOException {        // 使用文件名称创建流对象        FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);               // 字符串转换为字节数组          byte[] b = &quot;abcde&quot;.getBytes();        // 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。        fos.write(b,2,2);          // 关闭资源        fos.close();    }}输出结果：cd</code></pre><h3 id="数据追加续写"><a href="#数据追加续写" class="headerlink" title="数据追加续写"></a>数据追加续写</h3><p>经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？</p><ul><li><code>public FileOutputStream(File file, boolean append)</code>： 创建文件输出流以写入由指定的 File对象表示的文件。  </li><li><code>public FileOutputStream(String name, boolean append)</code>： 创建文件输出流以指定的名称写入文件。  </li></ul><p>这两个构造方法，参数中都需要传入一个boolean类型的值，<code>true</code> 表示追加数据，<code>false</code> 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示：</p><pre><code class="java">public class FOSWrite {    public static void main(String[] args) throws IOException {        // 使用文件名称创建流对象        FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;，true);               // 字符串转换为字节数组          byte[] b = &quot;abcde&quot;.getBytes();        // 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。        fos.write(b);          // 关闭资源        fos.close();    }}文件操作前：cd文件操作后：cdabcde</code></pre><h3 id="写出换行"><a href="#写出换行" class="headerlink" title="写出换行"></a>写出换行</h3><p>Windows系统里，换行符号是<code>\r\n</code> 。把</p><p>以指定是否追加续写了，代码使用演示：</p><pre><code class="java">public class FOSWrite {    public static void main(String[] args) throws IOException {        // 使用文件名称创建流对象        FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);            // 定义字节数组          byte[] words = {97,98,99,100,101};          // 遍历数组        for (int i = 0; i &lt; words.length; i++) {              // 写出一个字节            fos.write(words[i]);              // 写出一个换行, 换行符号转成数组写出            fos.write(&quot;\r\n&quot;.getBytes());        }          // 关闭资源        fos.close();    }}输出结果：abcde</code></pre><blockquote><ul><li>回车符<code>\r</code>和换行符<code>\n</code> ：<ul><li>回车符：回到一行的开头（return）。</li><li>换行符：下一行（newline）。</li></ul></li><li>系统中的换行：<ul><li>Windows系统里，每行结尾是 <code>回车+换行</code> ，即<code>\r\n</code>；</li><li>Unix系统里，每行结尾只有 <code>换行</code> ，即<code>\n</code>；</li><li>Mac系统里，每行结尾是 <code>回车</code> ，即<code>\r</code>。从 Mac OS X开始与Linux统一。</li></ul></li></ul></blockquote><h2 id="2-4-字节输入流【InputStream】"><a href="#2-4-字节输入流【InputStream】" class="headerlink" title="2.4 字节输入流【InputStream】"></a>2.4 字节输入流【InputStream】</h2><p><code>java.io.InputStream</code>抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。    </li><li><code>public abstract int read()</code>： 从输入流读取数据的下一个字节。 </li><li><code>public int read(byte[] b)</code>： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。</li></ul><blockquote><p>小贴士：</p><p>close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p></blockquote><h2 id="2-5-FileInputStream类"><a href="#2-5-FileInputStream类" class="headerlink" title="2.5 FileInputStream类"></a>2.5 FileInputStream类</h2><p><code>java.io.FileInputStream</code>类是文件输入流，从文件中读取字节。</p><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>FileInputStream(File file)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 </li><li><code>FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。  </li></ul><p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出<code>FileNotFoundException</code> 。</p><ul><li>构造举例，代码如下：</li></ul><pre><code class="java">public class FileInputStreamConstructor throws IOException{    public static void main(String[] args) {            // 使用File对象创建流对象        File file = new File(&quot;a.txt&quot;);        FileInputStream fos = new FileInputStream(file);        // 使用文件名称创建流对象        FileInputStream fos = new FileInputStream(&quot;b.txt&quot;);    }}</code></pre><h3 id="读取字节数据"><a href="#读取字节数据" class="headerlink" title="读取字节数据"></a>读取字节数据</h3><ol><li><strong>读取字节</strong>：<code>read</code>方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，代码使用演示：</li></ol><pre><code class="java">public class FISRead {    public static void main(String[] args) throws IOException{          // 使用文件名称创建流对象           FileInputStream fis = new FileInputStream(&quot;read.txt&quot;);          // 读取数据，返回一个字节        int read = fis.read();        System.out.println((char) read);        read = fis.read();        System.out.println((char) read);        read = fis.read();        System.out.println((char) read);        read = fis.read();        System.out.println((char) read);        read = fis.read();        System.out.println((char) read);          // 读取到末尾,返回-1           read = fis.read();        System.out.println( read);        // 关闭资源        fis.close();    }}输出结果：abcde-1</code></pre><p>循环改进读取方式，代码使用演示：</p><pre><code class="java">public class FISRead {    public static void main(String[] args) throws IOException{          // 使用文件名称创建流对象           FileInputStream fis = new FileInputStream(&quot;read.txt&quot;);          // 定义变量，保存数据        int b ；        // 循环读取        while ((b = fis.read())!=-1) {            System.out.println((char)b);        }        // 关闭资源        fis.close();    }}输出结果：abcde</code></pre><blockquote><p>小贴士：</p><ol><li>虽然读取了一个字节，但是会自动提升为int类型。</li><li>流操作完毕后，必须释放系统资源，调用close方法，千万记得。</li></ol></blockquote><ol start="2"><li><strong>使用字节数组读取</strong>：<code>read(byte[] b)</code>，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回<code>-1</code> ，代码使用演示：</li></ol><pre><code class="java">public class FISRead {    public static void main(String[] args) throws IOException{          // 使用文件名称创建流对象.           FileInputStream fis = new FileInputStream(&quot;read.txt&quot;); // 文件中为abcde          // 定义变量，作为有效个数        int len ；        // 定义字节数组，作为装字节数据的容器           byte[] b = new byte[2];        // 循环读取        while (( len= fis.read(b))!=-1) {               // 每次读取后,把数组变成字符串打印            System.out.println(new String(b));        }        // 关闭资源        fis.close();    }}输出结果：abcded</code></pre><p>错误数据<code>d</code>，是由于最后一次读取时，只读取一个字节<code>e</code>，数组中，上次读取的数据没有被完全替换，所以要通过<code>len</code> ，获取有效的字节，代码使用演示：</p><pre><code class="java">public class FISRead {    public static void main(String[] args) throws IOException{          // 使用文件名称创建流对象.           FileInputStream fis = new FileInputStream(&quot;read.txt&quot;); // 文件中为abcde          // 定义变量，作为有效个数        int len ；        // 定义字节数组，作为装字节数据的容器           byte[] b = new byte[2];        // 循环读取        while (( len= fis.read(b))!=-1) {               // 每次读取后,把数组的有效字节部分，变成字符串打印            System.out.println(new String(b，0，len));//  len 每次读取的有效字节个数        }        // 关闭资源        fis.close();    }}输出结果：abcde</code></pre><blockquote><p>小贴士：</p><p>使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。</p></blockquote><h2 id="2-6-字节流练习：图片复制"><a href="#2-6-字节流练习：图片复制" class="headerlink" title="2.6 字节流练习：图片复制"></a>2.6 字节流练习：图片复制</h2><h3 id="复制原理图解"><a href="#复制原理图解" class="headerlink" title="复制原理图解"></a>复制原理图解</h3><p><img src="img/2_copy.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><p>复制图片文件，代码使用演示：</p><pre><code class="java">public class Copy {    public static void main(String[] args) throws IOException {        // 1.创建流对象        // 1.1 指定数据源        FileInputStream fis = new FileInputStream(&quot;D:\\test.jpg&quot;);        // 1.2 指定目的地        FileOutputStream fos = new FileOutputStream(&quot;test_copy.jpg&quot;);        // 2.读写数据        // 2.1 定义数组        byte[] b = new byte[1024];        // 2.2 定义长度        int len;        // 2.3 循环读取        while ((len = fis.read(b))!=-1) {            // 2.4 写出数据            fos.write(b, 0 , len);        }        // 3.关闭资源        fos.close();        fis.close();    }}</code></pre><blockquote><p>小贴士：</p><p>流的关闭原则：先开后关，后开先关。</p></blockquote><h1 id="第三章-字符流"><a href="#第三章-字符流" class="headerlink" title="第三章 字符流"></a>第三章 字符流</h1><p>当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。</p><h2 id="3-1-字符输入流【Reader】"><a href="#3-1-字符输入流【Reader】" class="headerlink" title="3.1 字符输入流【Reader】"></a>3.1 字符输入流【Reader】</h2><p><code>java.io.Reader</code>抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。    </li><li><code>public int read()</code>： 从输入流读取一个字符。 </li><li><code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。</li></ul><h2 id="3-2-FileReader类"><a href="#3-2-FileReader类" class="headerlink" title="3.2 FileReader类"></a>3.2 FileReader类</h2><p><code>java.io.FileReader</code>类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p><blockquote><p>小贴士：</p><ol><li><p>字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。</p><p>idea中UTF-8</p></li><li><p>字节缓冲区：一个字节数组，用来临时存储字节数据。</p></li></ol></blockquote><h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>FileReader(File file)</code>： 创建一个新的 FileReader ，给定要读取的File对象。   </li><li><code>FileReader(String fileName)</code>： 创建一个新的 FileReader ，给定要读取的文件的名称。  </li></ul><p>当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。</p><ul><li>构造举例，代码如下：</li></ul><pre><code class="java">public class FileReaderConstructor throws IOException{    public static void main(String[] args) {            // 使用File对象创建流对象        File file = new File(&quot;a.txt&quot;);        FileReader fr = new FileReader(file);        // 使用文件名称创建流对象        FileReader fr = new FileReader(&quot;b.txt&quot;);    }}</code></pre><h3 id="读取字符数据"><a href="#读取字符数据" class="headerlink" title="读取字符数据"></a>读取字符数据</h3><ol><li><strong>读取字符</strong>：<code>read</code>方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，循环读取，代码使用演示：</li></ol><pre><code class="java">public class FRRead {    public static void main(String[] args) throws IOException {          // 使用文件名称创建流对象           FileReader fr = new FileReader(&quot;read.txt&quot;);          // 定义变量，保存数据        int b ；        // 循环读取        while ((b = fr.read())!=-1) {            System.out.println((char)b);        }        // 关闭资源        fr.close();    }}输出结果：黑马程序员</code></pre><blockquote><p>小贴士：虽然读取了一个字符，但是会自动提升为int类型。</p></blockquote><ol start="2"><li><strong>使用字符数组读取</strong>：<code>read(char[] cbuf)</code>，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回<code>-1</code> ，代码使用演示：</li></ol><pre><code class="java">public class FRRead {    public static void main(String[] args) throws IOException {          // 使用文件名称创建流对象           FileReader fr = new FileReader(&quot;read.txt&quot;);          // 定义变量，保存有效字符个数        int len ；        // 定义字符数组，作为装字符数据的容器         char[] cbuf = new char[2];        // 循环读取        while ((len = fr.read(cbuf))!=-1) {            System.out.println(new String(cbuf));        }        // 关闭资源        fr.close();    }}输出结果：黑马程序员序</code></pre><p>获取有效的字符改进，代码使用演示：</p><pre><code class="java">public class FISRead {    public static void main(String[] args) throws IOException {          // 使用文件名称创建流对象           FileReader fr = new FileReader(&quot;read.txt&quot;);          // 定义变量，保存有效字符个数        int len ；        // 定义字符数组，作为装字符数据的容器        char[] cbuf = new char[2];        // 循环读取        while ((len = fr.read(cbuf))!=-1) {            System.out.println(new String(cbuf,0,len));        }        // 关闭资源        fr.close();    }}输出结果：黑马程序员</code></pre><h2 id="3-3-字符输出流【Writer】"><a href="#3-3-字符输出流【Writer】" class="headerlink" title="3.3 字符输出流【Writer】"></a>3.3 字符输出流【Writer】</h2><p><code>java.io.Writer</code>抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p><ul><li><code>void write(int c)</code> 写入单个字符。</li><li><code>void write(char[] cbuf)</code>写入字符数组。 </li><li><code>abstract  void write(char[] cbuf, int off, int len)</code>写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 </li><li><code>void write(String str)</code>写入字符串。 </li><li><code>void write(String str, int off, int len)</code> 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。</li><li><code>void flush()</code>刷新该流的缓冲。  </li><li><code>void close()</code> 关闭此流，但要先刷新它。 </li></ul><h2 id="3-4-FileWriter类"><a href="#3-4-FileWriter类" class="headerlink" title="3.4 FileWriter类"></a>3.4 FileWriter类</h2><p><code>java.io.FileWriter</code>类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p><h3 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的File对象。   </li><li><code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。  </li></ul><p>当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。</p><ul><li>构造举例，代码如下：</li></ul><pre><code class="java">public class FileWriterConstructor {    public static void main(String[] args) throws IOException {            // 使用File对象创建流对象        File file = new File(&quot;a.txt&quot;);        FileWriter fw = new FileWriter(file);        // 使用文件名称创建流对象        FileWriter fw = new FileWriter(&quot;b.txt&quot;);    }}</code></pre><h3 id="基本写出数据"><a href="#基本写出数据" class="headerlink" title="基本写出数据"></a>基本写出数据</h3><p><strong>写出字符</strong>：<code>write(int b)</code> 方法，每次可以写出一个字符数据，代码使用演示：</p><pre><code class="java">public class FWWrite {    public static void main(String[] args) throws IOException {        // 使用文件名称创建流对象        FileWriter fw = new FileWriter(&quot;fw.txt&quot;);               // 写出数据          fw.write(97); // 写出第1个字符          fw.write(&#39;b&#39;); // 写出第2个字符          fw.write(&#39;C&#39;); // 写出第3个字符          fw.write(30000); // 写出第4个字符，中文编码表中30000对应一个汉字。          /*        【注意】关闭资源时,与FileOutputStream不同。           如果不关闭,数据只是保存到缓冲区，并未保存到文件。        */        // fw.close();    }}输出结果：abC田</code></pre><blockquote><p>小贴士：</p><ol><li>虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。</li><li>未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。</li></ol></blockquote><h3 id="关闭和刷新"><a href="#关闭和刷新" class="headerlink" title="关闭和刷新"></a>关闭和刷新</h3><p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要<code>flush</code> 方法了。</p><ul><li><code>flush</code> ：刷新缓冲区，流对象可以继续使用。</li><li><code>close</code>:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li></ul><p>代码使用演示：</p><pre><code class="java">public class FWWrite {    public static void main(String[] args) throws IOException {        // 使用文件名称创建流对象        FileWriter fw = new FileWriter(&quot;fw.txt&quot;);        // 写出数据，通过flush        fw.write(&#39;刷&#39;); // 写出第1个字符        fw.flush();        fw.write(&#39;新&#39;); // 继续写出第2个字符，写出成功        fw.flush();          // 写出数据，通过close        fw.write(&#39;关&#39;); // 写出第1个字符        fw.close();        fw.write(&#39;闭&#39;); // 继续写出第2个字符,【报错】java.io.IOException: Stream closed        fw.close();    }}</code></pre><blockquote><p>小贴士：即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。</p></blockquote><h3 id="写出其他数据"><a href="#写出其他数据" class="headerlink" title="写出其他数据"></a>写出其他数据</h3><ol><li><strong>写出字符数组</strong> ：<code>write(char[] cbuf)</code> 和 <code>write(char[] cbuf, int off, int len)</code> ，每次可以写出字符数组中的数据，用法类似FileOutputStream，代码使用演示：</li></ol><pre><code class="java">public class FWWrite {    public static void main(String[] args) throws IOException {        // 使用文件名称创建流对象        FileWriter fw = new FileWriter(&quot;fw.txt&quot;);               // 字符串转换为字节数组          char[] chars = &quot;黑马程序员&quot;.toCharArray();          // 写出字符数组          fw.write(chars); // 黑马程序员        // 写出从索引2开始，2个字节。索引2是&#39;程&#39;，两个字节，也就是&#39;程序&#39;。        fw.write(b,2,2); // 程序          // 关闭资源        fos.close();    }}</code></pre><ol start="2"><li><strong>写出字符串</strong>：<code>write(String str)</code> 和 <code>write(String str, int off, int len)</code> ，每次可以写出字符串中的数据，更为方便，代码使用演示：</li></ol><pre><code class="java">public class FWWrite {    public static void main(String[] args) throws IOException {        // 使用文件名称创建流对象        FileWriter fw = new FileWriter(&quot;fw.txt&quot;);               // 字符串          String msg = &quot;黑马程序员&quot;;          // 写出字符数组          fw.write(msg); //黑马程序员        // 写出从索引2开始，2个字节。索引2是&#39;程&#39;，两个字节，也就是&#39;程序&#39;。        fw.write(msg,2,2);    // 程序        // 关闭资源        fos.close();    }}</code></pre><ol start="3"><li><strong>续写和换行</strong>：操作类似于FileOutputStream。</li></ol><pre><code class="java">public class FWWrite {    public static void main(String[] args) throws IOException {        // 使用文件名称创建流对象，可以续写数据        FileWriter fw = new FileWriter(&quot;fw.txt&quot;，true);               // 写出字符串        fw.write(&quot;黑马&quot;);          // 写出换行          fw.write(&quot;\r\n&quot;);          // 写出字符串          fw.write(&quot;程序员&quot;);          // 关闭资源        fw.close();    }}输出结果:黑马程序员</code></pre><blockquote><p>小贴士：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。</p><p>当我们单纯读或者写文本文件时  使用字符流 其他情况使用字节流</p></blockquote><h1 id="第四章-IO异常的处理"><a href="#第四章-IO异常的处理" class="headerlink" title="第四章 IO异常的处理"></a>第四章 IO异常的处理</h1><h3 id="JDK7前处理"><a href="#JDK7前处理" class="headerlink" title="JDK7前处理"></a>JDK7前处理</h3><p>之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用<code>try...catch...finally</code> 代码块，处理异常部分，代码使用演示：</p><pre><code class="java">public class HandleException1 {    public static void main(String[] args) {          // 声明变量        FileWriter fw = null;        try {            //创建流对象            fw = new FileWriter(&quot;fw.txt&quot;);            // 写出数据            fw.write(&quot;黑马程序员&quot;); //黑马程序员        } catch (IOException e) {            e.printStackTrace();        } finally {            try {                if (fw != null) {                    fw.close();                }            } catch (IOException e) {                e.printStackTrace();            }        }    }}</code></pre><h3 id="JDK7的处理-扩展知识点了解内容"><a href="#JDK7的处理-扩展知识点了解内容" class="headerlink" title="JDK7的处理(扩展知识点了解内容)"></a>JDK7的处理(扩展知识点了解内容)</h3><p>还可以使用JDK7优化后的<code>try-with-resource</code> 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。</p><p>格式：</p><pre><code class="java">try (创建流对象语句，如果多个,使用&#39;;&#39;隔开) {    // 读写数据} catch (IOException e) {    e.printStackTrace();}</code></pre><p>代码使用演示：</p><pre><code class="java">public class HandleException2 {    public static void main(String[] args) {          // 创建流对象        try ( FileWriter fw = new FileWriter(&quot;fw.txt&quot;); ) {            // 写出数据            fw.write(&quot;黑马程序员&quot;); //黑马程序员        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><h3 id="JDK9的改进-扩展知识点了解内容"><a href="#JDK9的改进-扩展知识点了解内容" class="headerlink" title="JDK9的改进(扩展知识点了解内容)"></a>JDK9的改进(扩展知识点了解内容)</h3><p>JDK9中<code>try-with-resource</code> 的改进，对于<strong>引入对象</strong>的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close，我们来了解一下格式。</p><p>改进前格式：</p><pre><code class="java">// 被final修饰的对象final Resource resource1 = new Resource(&quot;resource1&quot;);// 普通对象Resource resource2 = new Resource(&quot;resource2&quot;);// 引入方式：创建新的变量保存try (Resource r1 = resource1;     Resource r2 = resource2) {     // 使用对象}</code></pre><p>改进后格式：</p><pre><code class="java">// 被final修饰的对象final Resource resource1 = new Resource(&quot;resource1&quot;);// 普通对象Resource resource2 = new Resource(&quot;resource2&quot;);// 引入方式：直接引入try (resource1; resource2) {     // 使用对象}</code></pre><p>改进后，代码使用演示：</p><pre><code class="java">public class TryDemo {    public static void main(String[] args) throws IOException {           // 创建流对象        final  FileReader fr  = new FileReader(&quot;in.txt&quot;);        FileWriter fw = new FileWriter(&quot;out.txt&quot;);           // 引入到try中        try (fr; fw) {              // 定义变量            int b;              // 读取数据              while ((b = fr.read())!=-1) {                // 写出数据                fw.write(b);              }        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><h1 id="第五章-属性集"><a href="#第五章-属性集" class="headerlink" title="第五章 属性集"></a>第五章 属性集</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p><code>java.util.Properties</code> 继承于<code>Hashtable</code> ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，<code>System.getProperties</code> 方法就是返回一个<code>Properties</code>对象。</p><h2 id="5-2-Properties类"><a href="#5-2-Properties类" class="headerlink" title="5.2 Properties类"></a>5.2 Properties类</h2><h3 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public Properties()</code> :创建一个空的属性列表。</li></ul><h3 id="基本的存储方法"><a href="#基本的存储方法" class="headerlink" title="基本的存储方法"></a>基本的存储方法</h3><ul><li><code>public Object setProperty(String key, String value)</code> ： 保存一对属性。  </li><li><code>public String getProperty(String key)</code> ：使用此属性列表中指定的键搜索属性值。</li><li><code>public Set&lt;String&gt; stringPropertyNames()</code> ：所有键的名称的集合。</li></ul><pre><code class="java">public class ProDemo {    public static void main(String[] args) throws FileNotFoundException {        // 创建属性集对象        Properties properties = new Properties();        // 添加键值对元素        properties.setProperty(&quot;filename&quot;, &quot;a.txt&quot;);        properties.setProperty(&quot;length&quot;, &quot;209385038&quot;);        properties.setProperty(&quot;location&quot;, &quot;D:\\a.txt&quot;);        // 打印属性集对象        System.out.println(properties);        // 通过键,获取属性值        System.out.println(properties.getProperty(&quot;filename&quot;));        System.out.println(properties.getProperty(&quot;length&quot;));        System.out.println(properties.getProperty(&quot;location&quot;));        // 遍历属性集,获取所有键的集合        Set&lt;String&gt; strings = properties.stringPropertyNames();        // 打印键值对        for (String key : strings ) {              System.out.println(key+&quot; -- &quot;+properties.getProperty(key));        }    }}输出结果：{filename=a.txt, length=209385038, location=D:\a.txt}a.txt209385038D:\a.txtfilename -- a.txtlength -- 209385038location -- D:\a.txt</code></pre><h3 id="与流相关的方法"><a href="#与流相关的方法" class="headerlink" title="与流相关的方法"></a>与流相关的方法</h3><ul><li><code>public void load(InputStream inStream)</code>： 从字节输入流中读取键值对。 </li></ul><p>参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。文本数据格式:</p><pre><code>filename=a.txtlength=209385038location=D:\a.txt</code></pre><p>加载代码演示：</p><pre><code class="java">public class ProDemo2 {    public static void main(String[] args) throws FileNotFoundException {        // 创建属性集对象        Properties pro = new Properties();        // 加载文本中信息到属性集        pro.load(new FileInputStream(&quot;read.txt&quot;));        // 遍历集合并打印        Set&lt;String&gt; strings = pro.stringPropertyNames();        for (String key : strings ) {              System.out.println(key+&quot; -- &quot;+pro.getProperty(key));        }     }}输出结果：filename -- a.txtlength -- 209385038location -- D:\a.txt</code></pre><blockquote><p>小贴士：文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>lamda</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>day08【File类、递归】</title>
    <link href="/2017/04/29/day08%E3%80%90File%E7%B1%BB%E3%80%81%E9%80%92%E5%BD%92%E3%80%91/"/>
    <url>/2017/04/29/day08%E3%80%90File%E7%B1%BB%E3%80%81%E9%80%92%E5%BD%92%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="day08【File类、递归】"><a href="#day08【File类、递归】" class="headerlink" title="day08【File类、递归】"></a>day08【File类、递归】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul><li>File类</li><li>递归</li></ul><h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul><li><input disabled="" type="checkbox"> 能够说出File对象的创建方式</li><li><input disabled="" type="checkbox"> 能够说出File类获取名称的方法名称</li><li><input disabled="" type="checkbox"> 能够说出File类获取绝对路径的方法名称</li><li><input disabled="" type="checkbox"> 能够说出File类获取文件大小的方法名称</li><li><input disabled="" type="checkbox"> 能够说出File类判断是否是文件的方法名称</li><li><input disabled="" type="checkbox"> 能够说出File类判断是否是文件夹的方法名称</li><li><input disabled="" type="checkbox"> 能够辨别相对路径和绝对路径</li><li><input disabled="" type="checkbox"> 能够遍历文件夹</li><li><input disabled="" type="checkbox"> 能够解释递归的含义</li><li><input disabled="" type="checkbox"> 能够使用递归的方式计算5的阶乘</li><li><input disabled="" type="checkbox"> 能够说出使用递归会内存溢出隐患的原因</li></ul><h1 id="第一章-File类"><a href="#第一章-File类" class="headerlink" title="第一章 File类"></a>第一章 File类</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><code>java.io.File</code> 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p><h2 id="1-2-构造方法"><a href="#1-2-构造方法" class="headerlink" title="1.2 构造方法"></a>1.2 构造方法</h2><ul><li><code>public File(String pathname)</code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File实例。  </li><li><code>public File(String parent, String child)</code> ：从<strong>父路径名字符串和子路径名字符串</strong>创建新的 File实例。</li><li><code>public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File实例。  </li></ul><ul><li>构造举例，代码如下：</li></ul><pre><code class="java">// 文件路径名String pathname = &quot;D:\\aaa.txt&quot;;File file1 = new File(pathname); // 文件路径名String pathname2 = &quot;D:\\aaa\\bbb.txt&quot;;File file2 = new File(pathname2); // 通过父路径和子路径字符串 String parent = &quot;d:\\aaa&quot;; String child = &quot;bbb.txt&quot;; File file3 = new File(parent, child);// 通过父级File对象和子路径字符串File parentDir = new File(&quot;d:\\aaa&quot;);String child = &quot;bbb.txt&quot;;File file4 = new File(parentDir, child);</code></pre><blockquote><p>小贴士：</p><ol><li>一个File对象代表硬盘中实际存在的一个文件或者目录。</li><li>无论该路径下是否存在文件或者目录，都不影响File对象的创建。</li></ol></blockquote><h2 id="1-3-常用方法"><a href="#1-3-常用方法" class="headerlink" title="1.3 常用方法"></a>1.3 常用方法</h2><h3 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h3><ul><li><p><code>public String getAbsolutePath()</code> ：返回此File的绝对路径名字符串。</p></li><li><p><code>public String getPath()</code> ：将此File转换为路径名字符串。 </p></li><li><p><code>public String getName()</code>  ：返回由此File表示的文件或目录的名称。  </p></li><li><p><code>public long length()</code>  ：返回由此File表示的文件的长度。 </p><p>方法演示，代码如下：</p><pre><code class="java">public class FileGet {    public static void main(String[] args) {        File f = new File(&quot;d:/aaa/bbb.java&quot;);             System.out.println(&quot;文件绝对路径:&quot;+f.getAbsolutePath());        System.out.println(&quot;文件构造路径:&quot;+f.getPath());        System.out.println(&quot;文件名称:&quot;+f.getName());        System.out.println(&quot;文件长度:&quot;+f.length()+&quot;字节&quot;);        File f2 = new File(&quot;d:/aaa&quot;);             System.out.println(&quot;目录绝对路径:&quot;+f2.getAbsolutePath());        System.out.println(&quot;目录构造路径:&quot;+f2.getPath());        System.out.println(&quot;目录名称:&quot;+f2.getName());        System.out.println(&quot;目录长度:&quot;+f2.length());    }}输出结果：文件绝对路径:d:\aaa\bbb.java文件构造路径:d:\aaa\bbb.java文件名称:bbb.java文件长度:636字节目录绝对路径:d:\aaa目录构造路径:d:\aaa目录名称:aaa目录长度:4096</code></pre></li></ul><blockquote><p>API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。</p></blockquote><h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><ul><li><strong>绝对路径</strong>：从盘符开始的路径，这是一个完整的路径。</li><li><strong>相对路径</strong>：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。</li></ul><pre><code class="java">public class FilePath {    public static void main(String[] args) {          // D盘下的bbb.java文件        File f = new File(&quot;D:\\bbb.java&quot;);        System.out.println(f.getAbsolutePath());        // 项目下的bbb.java文件        File f2 = new File(&quot;bbb.java&quot;);        System.out.println(f2.getAbsolutePath());    }}输出结果：D:\bbb.javaD:\idea_project_test4\bbb.java</code></pre><h3 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h3><ul><li><code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在。</li><li><code>public boolean isDirectory()</code> ：此File表示的是否为目录。</li><li><code>public boolean isFile()</code> ：此File表示的是否为文件。</li></ul><p>方法演示，代码如下：</p><pre><code class="java">public class FileIs {    public static void main(String[] args) {        File f = new File(&quot;d:\\aaa\\bbb.java&quot;);        File f2 = new File(&quot;d:\\aaa&quot;);          // 判断是否存在        System.out.println(&quot;d:\\aaa\\bbb.java 是否存在:&quot;+f.exists());        System.out.println(&quot;d:\\aaa 是否存在:&quot;+f2.exists());          // 判断是文件还是目录        System.out.println(&quot;d:\\aaa 文件?:&quot;+f2.isFile());        System.out.println(&quot;d:\\aaa 目录?:&quot;+f2.isDirectory());    }}输出结果：d:\aaa\bbb.java 是否存在:trued:\aaa 是否存在:trued:\aaa 文件?:falsed:\aaa 目录?:true</code></pre><h3 id="创建删除功能的方法"><a href="#创建删除功能的方法" class="headerlink" title="创建删除功能的方法"></a>创建删除功能的方法</h3><ul><li><code>public boolean createNewFile()</code> ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 </li><li><code>public boolean delete()</code> ：删除由此File表示的文件或目录。  </li><li><code>public boolean mkdir()</code> ：创建由此File表示的目录。</li><li><code>public boolean mkdirs()</code> ：创建由此File表示的目录，包括任何必需但不存在的父目录。</li></ul><p>方法演示，代码如下：</p><pre><code class="java">public class FileCreateDelete {    public static void main(String[] args) throws IOException {        // 文件的创建        File f = new File(&quot;aaa.txt&quot;);        System.out.println(&quot;是否存在:&quot;+f.exists()); // false        System.out.println(&quot;是否创建:&quot;+f.createNewFile()); // true        System.out.println(&quot;是否存在:&quot;+f.exists()); // true         // 目录的创建          File f2= new File(&quot;newDir&quot;);            System.out.println(&quot;是否存在:&quot;+f2.exists());// false        System.out.println(&quot;是否创建:&quot;+f2.mkdir());    // true        System.out.println(&quot;是否存在:&quot;+f2.exists());// true        // 创建多级目录          File f3= new File(&quot;newDira\\newDirb&quot;);        System.out.println(f3.mkdir());// false        File f4= new File(&quot;newDira\\newDirb&quot;);        System.out.println(f4.mkdirs());// true          // 文件的删除           System.out.println(f.delete());// true          // 目录的删除        System.out.println(f2.delete());// true        System.out.println(f4.delete());// false    }}</code></pre><blockquote><p>API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。</p></blockquote><h2 id="1-4-目录的遍历"><a href="#1-4-目录的遍历" class="headerlink" title="1.4 目录的遍历"></a>1.4 目录的遍历</h2><ul><li><code>public String[] list()</code> ：返回一个String数组，表示该File目录中的所有子文件或目录。</li></ul><ul><li><code>public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的子文件或目录。  </li></ul><pre><code class="java">public class FileFor {    public static void main(String[] args) {        File dir = new File(&quot;d:\\java_code&quot;);          //获取当前目录下的文件以及文件夹的名称。        String[] names = dir.list();        for(String name : names){            System.out.println(name);        }        //获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息        File[] files = dir.listFiles();        for (File file : files) {            System.out.println(file);        }    }}</code></pre><blockquote><p>小贴士：</p><p>调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。</p></blockquote><h1 id="第二章-递归"><a href="#第二章-递归" class="headerlink" title="第二章 递归"></a>第二章 递归</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ul><li><p><strong>递归</strong>：指在当前方法内调用自己的这种现象。</p></li><li><p><strong>递归的分类:</strong></p><ul><li>递归分为两种，直接递归和间接递归。</li><li>直接递归称为方法自身调用自己。</li><li>间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法。</li></ul></li><li><p><strong>注意事项</strong>：</p><ul><li>递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。</li><li>在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。</li><li>构造方法,禁止递归</li></ul></li></ul><pre><code class="java">public class Demo01DiGui {    public static void main(String[] args) {        // a();        b(1);    }    /*     * 3.构造方法,禁止递归     * 编译报错:构造方法是创建对象使用的,不能让对象一直创建下去     */    public Demo01DiGui() {        //Demo01DiGui();    }    /*     * 2.在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。     * 4993     *     Exception in thread &quot;main&quot; java.lang.StackOverflowError     */    private static void b(int i) {        System.out.println(i);        //添加一个递归结束的条件,i==5000的时候结束        if(i==5000){            return;//结束方法        }        b(++i);    }    /*     * 1.递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。 Exception in thread &quot;main&quot;     * java.lang.StackOverflowError     */    private static void a() {        System.out.println(&quot;a方法&quot;);        a();    }}</code></pre><h2 id="2-2-递归累加求和"><a href="#2-2-递归累加求和" class="headerlink" title="2.2 递归累加求和"></a>2.2 递归累加求和</h2><h3 id="计算1-n的和"><a href="#计算1-n的和" class="headerlink" title="计算1 ~ n的和"></a>计算1 ~ n的和</h3><p><strong>分析</strong>：num的累和 = num + (num-1)的累和，所以可以把累和的操作定义成一个方法，递归调用。</p><p><strong>实现代码</strong>：</p><pre><code class="java">public class DiGuiDemo {    public static void main(String[] args) {        //计算1~num的和，使用递归完成        int num = 5;          // 调用求和的方法        int sum = getSum(num);          // 输出结果        System.out.println(sum);    }      /*        通过递归算法实现.        参数列表:int         返回值类型: int       */    public static int getSum(int num) {          /*              num为1时,方法返回1,             相当于是方法的出口,num总有是1的情况          */        if(num == 1){            return 1;        }          /*          num不为1时,方法返回 num +(num-1)的累和          递归调用getSum方法        */        return num + getSum(num-1);    }}</code></pre><h3 id="代码执行图解"><a href="#代码执行图解" class="headerlink" title="代码执行图解"></a>代码执行图解</h3><p><img src="img/day08_01_%E9%80%92%E5%BD%92%E7%B4%AF%E5%92%8C.jpg" srcset="/img/loading.gif" alt=""></p><blockquote><p>小贴士：递归一定要有条件限定，保证递归能够停止下来，次数不要太多，否则会发生栈内存溢出。</p></blockquote><h2 id="2-3-递归求阶乘"><a href="#2-3-递归求阶乘" class="headerlink" title="2.3 递归求阶乘"></a>2.3 递归求阶乘</h2><ul><li><strong>阶乘</strong>：所有小于及等于该数的正整数的积。</li></ul><pre><code class="java">n的阶乘：n! = n * (n-1) *...* 3 * 2 * 1 </code></pre><p><strong>分析</strong>：这与累和类似,只不过换成了乘法运算，学员可以自己练习，需要注意阶乘值符合int类型的范围。</p><pre><code>推理得出：n! = n * (n-1)!</code></pre><p><strong>代码实现</strong>：</p><pre><code class="java">public class DiGuiDemo {      //计算n的阶乘，使用递归完成    public static void main(String[] args) {        int n = 3;          // 调用求阶乘的方法        int value = getValue(n);          // 输出结果        System.out.println(&quot;阶乘为:&quot;+ value);    }    /*        通过递归算法实现.        参数列表:int         返回值类型: int       */    public static int getValue(int n) {          // 1的阶乘为1        if (n == 1) {            return 1;        }          /*            n不为1时,方法返回 n! = n*(n-1)!          递归调用getValue方法          */        return n * getValue(n - 1);    }}</code></pre><h2 id="2-4-递归打印多级目录"><a href="#2-4-递归打印多级目录" class="headerlink" title="2.4 递归打印多级目录"></a>2.4 递归打印多级目录</h2><p><strong>分析</strong>：多级目录的打印，就是当目录的嵌套。遍历之前，无从知道到底有多少级目录，所以我们还是要使用递归实现。</p><p><strong>代码实现</strong>：</p><pre><code class="java">public class DiGuiDemo2 {    public static void main(String[] args) {          // 创建File对象        File dir  = new File(&quot;D:\\aaa&quot;);          // 调用打印目录方法        printDir(dir);    }    public static void  printDir(File dir) {          // 获取子文件和目录        File[] files = dir.listFiles();          // 循环打印          /*            判断:            当是文件时,打印绝对路径.            当是目录时,继续调用打印目录的方法,形成递归调用.          */        for (File file : files) {            // 判断            if (file.isFile()) {                  // 是文件,输出文件绝对路径                System.out.println(&quot;文件名:&quot;+ file.getAbsolutePath());            } else {                  // 是目录,输出目录绝对路径                System.out.println(&quot;目录:&quot;+file.getAbsolutePath());                  // 继续遍历,调用printDir,形成递归                printDir(file);            }        }    }}</code></pre><h1 id="第三章-综合案例"><a href="#第三章-综合案例" class="headerlink" title="第三章 综合案例"></a>第三章 综合案例</h1><h2 id="3-1-文件搜索"><a href="#3-1-文件搜索" class="headerlink" title="3.1 文件搜索"></a>3.1 文件搜索</h2><p>搜索<code>D:\aaa</code> 目录中的<code>.java</code> 文件。</p><p><strong>分析</strong>：</p><ol><li>目录搜索，无法判断多少级目录，所以使用递归，遍历所有目录。</li><li>遍历目录时，获取的子文件，通过文件名称，判断是否符合条件。</li></ol><p><strong>代码实现</strong>：</p><pre><code class="java">public class DiGuiDemo3 {    public static void main(String[] args) {        // 创建File对象        File dir  = new File(&quot;D:\\aaa&quot;);          // 调用打印目录方法        printDir(dir);    }    public static void printDir(File dir) {          // 获取子文件和目录        File[] files = dir.listFiles();          // 循环打印        for (File file : files) {            if (file.isFile()) {                  // 是文件，判断文件名并输出文件绝对路径                if (file.getName().endsWith(&quot;.java&quot;)) {                    System.out.println(&quot;文件名:&quot; + file.getAbsolutePath());                }            } else {                // 是目录，继续遍历,形成递归                printDir(file);            }        }    }}</code></pre><h2 id="3-2-文件过滤器优化"><a href="#3-2-文件过滤器优化" class="headerlink" title="3.2 文件过滤器优化"></a>3.2 文件过滤器优化</h2><p><code>java.io.FileFilter</code>是一个接口，是File的过滤器。 该接口的对象可以传递给File类的<code>listFiles(FileFilter)</code> 作为参数， 接口中只有一个方法。</p><p><code>boolean accept(File pathname)</code> ：测试pathname是否应该包含在当前File目录中，符合则返回true。</p><p><strong>分析</strong>：</p><ol><li>接口作为参数，需要传递子类对象，重写其中方法。我们选择匿名内部类方式，比较简单。</li><li><code>accept</code>方法，参数为File，表示当前File下所有的子文件和子目录。保留住则返回true，过滤掉则返回false。保留规则：<ol><li>要么是.java文件。</li><li>要么是目录，用于继续遍历。</li></ol></li><li>通过过滤器的作用，<code>listFiles(FileFilter)</code>返回的数组元素中，子文件对象都是符合条件的，可以直接打印。</li></ol><p><strong>代码实现：</strong></p><pre><code class="java">public class DiGuiDemo4 {    public static void main(String[] args) {        File dir = new File(&quot;D:\\aaa&quot;);        printDir2(dir);    }    public static void printDir2(File dir) {          // 匿名内部类方式,创建过滤器子类对象        File[] files = dir.listFiles(new FileFilter() {            @Override            public boolean accept(File pathname) {                return pathname.getName().endsWith(&quot;.java&quot;)||pathname.isDirectory();            }        });          // 循环打印        for (File file : files) {            if (file.isFile()) {                System.out.println(&quot;文件名:&quot; + file.getAbsolutePath());            } else {                printDir2(file);            }        }    }}      </code></pre><h2 id="3-3-Lambda优化"><a href="#3-3-Lambda优化" class="headerlink" title="3.3 Lambda优化"></a>3.3 Lambda优化</h2><p><strong>分析：</strong><code>FileFilter</code>是只有一个方法的接口，因此可以用lambda表达式简写。</p><p>lambda格式：</p><pre><code class="java">()-&gt;{ }</code></pre><p><strong>代码实现：</strong></p><pre><code class="java">public static void printDir3(File dir) {      // lambda的改写    File[] files = dir.listFiles(f -&gt;{           return f.getName().endsWith(&quot;.java&quot;) || f.isDirectory();     });    // 循环打印    for (File file : files) {        if (file.isFile()) {            System.out.println(&quot;文件名:&quot; + file.getAbsolutePath());          } else {            printDir3(file);          }    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>lamda</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>day07【线程池、Lambda表达式】(1)</title>
    <link href="/2017/04/21/day07%E3%80%90%E7%BA%BF%E7%A8%8B%E6%B1%A0%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%91(1)/"/>
    <url>/2017/04/21/day07%E3%80%90%E7%BA%BF%E7%A8%8B%E6%B1%A0%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%91(1)/</url>
    
    <content type="html"><![CDATA[<h1 id="day07【线程池、Lambda表达式】"><a href="#day07【线程池、Lambda表达式】" class="headerlink" title="day07【线程池、Lambda表达式】"></a>day07【线程池、Lambda表达式】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul><li>等待与唤醒案例</li><li>线程池</li><li>Lambda表达式</li></ul><h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><p>-[ ] 能够理解线程通信概念<br>-[ ] 能够理解等待唤醒机制<br>-[ ] 能够描述Java中线程池运行原理<br>-[ ] 能够理解函数式编程相对于面向对象的优点<br>-[ ] 能够掌握Lambda表达式的标准格式<br>-[ ] 能够使用Lambda标准格式使用Runnable与Comparator接口<br>-[ ] 能够掌握Lambda表达式的省略格式与规则<br>-[ ] 能够使用Lambda省略格式使用Runnable与Comparator接口<br>-[ ] 能够通过Lambda的标准格式使用自定义的接口（有且仅有一个抽象方法）<br>-[ ] 能够通过Lambda的省略格式使用自定义的接口（有且仅有一个抽象方法）<br>-[ ] 能够明确Lambda的两项使用前提</p><h1 id="第一章-等待唤醒机制"><a href="#第一章-等待唤醒机制" class="headerlink" title="第一章 等待唤醒机制"></a>第一章 等待唤醒机制</h1><h2 id="1-1-线程间通信"><a href="#1-1-线程间通信" class="headerlink" title="1.1 线程间通信"></a>1.1 线程间通信</h2><p><strong>概念：</strong>多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。</p><p>比如：线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。</p><p><img src="img%5C%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.bmp" srcset="/img/loading.gif" alt=""></p><p><strong>为什么要处理线程间通信：</strong></p><p>多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。</p><p><strong>如何保证线程间通信有效利用资源：</strong></p><p>多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— <strong>等待唤醒机制。</strong></p><h2 id="1-2-等待唤醒机制"><a href="#1-2-等待唤醒机制" class="headerlink" title="1.2 等待唤醒机制"></a>1.2 等待唤醒机制</h2><p><strong>什么是等待唤醒机制</strong></p><p>这是多个线程间的一种<strong>协作</strong>机制。谈到线程我们经常想到的是线程间的<strong>竞争（race）</strong>，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。</p><p>就是在一个线程进行了规定操作后，就进入等待状态（<strong>wait()</strong>）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（<strong>notify()</strong>）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。</p><p>wait/notify 就是线程间的一种协作机制。</p><p><strong>等待唤醒中的方法</strong></p><p>等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：</p><ol><li>wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个<strong>特别的动作</strong>，也即是“<strong>通知（notify）</strong>”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中</li><li>notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。</li><li>notifyAll：则释放所通知对象的 wait set 上的全部线程。</li></ol><blockquote><p>注意：</p><p>哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。</p><p>总结如下：</p><ul><li>如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态；</li><li>否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态</li></ul></blockquote><p><strong>调用wait和notify方法需要注意的细节</strong></p><ol><li>wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。</li><li>wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li><li>wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。</li></ol><h2 id="1-3-生产者与消费者问题"><a href="#1-3-生产者与消费者问题" class="headerlink" title="1.3 生产者与消费者问题"></a>1.3 生产者与消费者问题</h2><p>等待唤醒机制其实就是经典的“生产者与消费者”的问题。</p><p>就拿生产包子消费包子来说等待唤醒机制如何有效利用资源：</p><pre><code class="java">包子铺线程生产包子，吃货线程消费包子。当包子没有时（包子状态为false），吃货线程等待，包子铺线程生产包子（即包子状态为true），并通知吃货线程（解除吃货的等待状态）,因为已经有包子了，那么包子铺线程进入等待状态。接下来，吃货线程能否进一步执行则取决于锁的获取情况。如果吃货获取到锁，那么就执行吃包子动作，包子吃完（包子状态为false），并通知包子铺线程（解除包子铺的等待状态）,吃货线程进入等待。包子铺线程能否进一步执行则取决于锁的获取情况。</code></pre><p><strong>代码演示：</strong></p><p>包子资源类：</p><pre><code class="java">public class BaoZi {     String  pier ;     String  xianer ;     boolean  flag = false ;//包子资源 是否存在  包子资源状态}</code></pre><p>吃货线程类：</p><pre><code class="java">public class ChiHuo extends Thread{    private BaoZi bz;    public ChiHuo(String name,BaoZi bz){        super(name);        this.bz = bz;    }    @Override    public void run() {        while(true){            synchronized (bz){                if(bz.flag == false){//没包子                    try {                        bz.wait();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                System.out.println(&quot;吃货正在吃&quot;+bz.pier+bz.xianer+&quot;包子&quot;);                bz.flag = false;                bz.notify();            }        }    }}</code></pre><p>包子铺线程类：</p><pre><code class="java">public class BaoZiPu extends Thread {    private BaoZi bz;    public BaoZiPu(String name,BaoZi bz){        super(name);        this.bz = bz;    }    @Override    public void run() {        int count = 0;        //造包子        while(true){            //同步            synchronized (bz){                if(bz.flag == true){//包子资源  存在                    try {                        bz.wait();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                // 没有包子  造包子                System.out.println(&quot;包子铺开始做包子&quot;);                if(count%2 == 0){                    // 冰皮  五仁                    bz.pier = &quot;冰皮&quot;;                    bz.xianer = &quot;五仁&quot;;                }else{                    // 薄皮  牛肉大葱                    bz.pier = &quot;薄皮&quot;;                    bz.xianer = &quot;牛肉大葱&quot;;                }                count++;                bz.flag=true;                System.out.println(&quot;包子造好了：&quot;+bz.pier+bz.xianer);                System.out.println(&quot;吃货来吃吧&quot;);                //唤醒等待线程 （吃货）                bz.notify();            }        }    }}</code></pre><p>测试类：</p><pre><code class="java">public class Demo {    public static void main(String[] args) {        //等待唤醒案例        BaoZi bz = new BaoZi();        ChiHuo ch = new ChiHuo(&quot;吃货&quot;,bz);        BaoZiPu bzp = new BaoZiPu(&quot;包子铺&quot;,bz);        ch.start();        bzp.start();    }}</code></pre><p>执行效果：</p><pre><code class="java">包子铺开始做包子包子造好了：冰皮五仁吃货来吃吧吃货正在吃冰皮五仁包子包子铺开始做包子包子造好了：薄皮牛肉大葱吃货来吃吧吃货正在吃薄皮牛肉大葱包子包子铺开始做包子包子造好了：冰皮五仁吃货来吃吧吃货正在吃冰皮五仁包子</code></pre><h1 id="第二章-线程池"><a href="#第二章-线程池" class="headerlink" title="第二章 线程池"></a>第二章 线程池</h1><h2 id="2-1-线程池思想概述"><a href="#2-1-线程池思想概述" class="headerlink" title="2.1 线程池思想概述"></a>2.1 线程池思想概述</h2><p><img src="img%5C%E6%B8%B8%E6%B3%B3%E6%B1%A0.jpg" srcset="/img/loading.gif" alt=""></p><p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：</p><p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p><p>那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？</p><p>在Java中可以通过线程池来达到这样的效果。今天我们就来详细讲解一下Java的线程池。</p><h2 id="2-2-线程池概念"><a href="#2-2-线程池概念" class="headerlink" title="2.2 线程池概念"></a>2.2 线程池概念</h2><ul><li><strong>线程池：</strong>其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</li></ul><p>由于线程池中有很多操作都是与优化资源相关的，我们在这里就不多赘述。我们通过一张图来了解线程池的工作原理：</p><p><img src="img%5C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86.bmp" srcset="/img/loading.gif" alt=""></p><p>合理利用线程池能够带来三个好处：</p><ol><li>降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li><li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</li></ol><h2 id="2-3-线程池的使用"><a href="#2-3-线程池的使用" class="headerlink" title="2.3 线程池的使用"></a>2.3 线程池的使用</h2><p>Java里面线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上讲<code>Executor</code>并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是<code>java.util.concurrent.ExecutorService</code>。</p><p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在<code>java.util.concurrent.Executors</code>线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。</p><p>Executors类中有个创建线程池的方法如下：</p><ul><li><code>public static ExecutorService newFixedThreadPool(int nThreads)</code>：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)</li></ul><p>获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下：</p><ul><li><p><code>public Future&lt;?&gt; submit(Runnable task)</code>:获取线程池中的某一个线程对象，并执行</p><blockquote><p>Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。</p></blockquote></li></ul><p>使用线程池中线程对象的步骤：</p><ol><li>创建线程池对象。</li><li>创建Runnable接口子类对象。(task)</li><li>提交Runnable接口子类对象。(take task)</li><li>关闭线程池(一般不做)。</li></ol><p>Runnable实现类代码：</p><pre><code class="java">public class MyRunnable implements Runnable {    @Override    public void run() {        System.out.println(&quot;我要一个教练&quot;);        try {            Thread.sleep(2000);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(&quot;教练来了： &quot; + Thread.currentThread().getName());        System.out.println(&quot;教我游泳,交完后，教练回到了游泳池&quot;);    }}</code></pre><p>线程池测试类：</p><pre><code class="java">public class ThreadPoolDemo {    public static void main(String[] args) {        // 创建线程池对象        ExecutorService service = Executors.newFixedThreadPool(2);//包含2个线程对象        // 创建Runnable实例对象        MyRunnable r = new MyRunnable();        //自己创建线程对象的方式        // Thread t = new Thread(r);        // t.start(); ---&gt; 调用MyRunnable中的run()        // 从线程池中获取线程对象,然后调用MyRunnable中的run()        service.submit(r);        // 再获取个线程对象，调用MyRunnable中的run()        service.submit(r);        service.submit(r);        // 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。        // 将使用完的线程又归还到了线程池中        // 关闭线程池        //service.shutdown();    }}</code></pre><h1 id="第三章-Lambda表达式"><a href="#第三章-Lambda表达式" class="headerlink" title="第三章 Lambda表达式"></a>第三章 Lambda表达式</h1><h2 id="3-1-函数式编程思想概述"><a href="#3-1-函数式编程思想概述" class="headerlink" title="3.1 函数式编程思想概述"></a>3.1 函数式编程思想概述</h2><p><img src="img/03-Overview.png" srcset="/img/loading.gif" alt=""></p><p>在数学中，<strong>函数</strong>就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——<strong>强调做什么，而不是以什么形式做</strong>。</p><p>面向对象的思想:</p><p>​    做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.</p><p>函数式编程思想:</p><p>​    只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程</p><h2 id="3-2-冗余的Runnable代码"><a href="#3-2-冗余的Runnable代码" class="headerlink" title="3.2 冗余的Runnable代码"></a>3.2 冗余的Runnable代码</h2><h3 id="传统写法"><a href="#传统写法" class="headerlink" title="传统写法"></a>传统写法</h3><p>当需要启动一个线程去完成任务时，通常会通过<code>java.lang.Runnable</code>接口来定义任务内容，并使用<code>java.lang.Thread</code>类来启动该线程。代码如下：</p><pre><code class="java">public class Demo01Runnable {    public static void main(String[] args) {        // 匿名内部类        Runnable task = new Runnable() {            @Override            public void run() { // 覆盖重写抽象方法                System.out.println(&quot;多线程任务执行！&quot;);            }        };        new Thread(task).start(); // 启动线程    }}</code></pre><p>本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个<code>Runnable</code>接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。</p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>对于<code>Runnable</code>的匿名内部类用法，可以分析出几点内容：</p><ul><li><code>Thread</code>类需要<code>Runnable</code>接口作为参数，其中的抽象<code>run</code>方法是用来指定线程任务内容的核心；</li><li>为了指定<code>run</code>的方法体，<strong>不得不</strong>需要<code>Runnable</code>接口的实现类；</li><li>为了省去定义一个<code>RunnableImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li><li>必须覆盖重写抽象<code>run</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li><li>而实际上，<strong>似乎只有方法体才是关键所在</strong>。</li></ul><h2 id="3-3-编程思想转换"><a href="#3-3-编程思想转换" class="headerlink" title="3.3 编程思想转换"></a>3.3 编程思想转换</h2><h3 id="做什么，而不是怎么做"><a href="#做什么，而不是怎么做" class="headerlink" title="做什么，而不是怎么做"></a>做什么，而不是怎么做</h3><p>我们真的希望创建一个匿名内部类对象吗？不。我们只是为了做这件事情而<strong>不得不</strong>创建一个对象。我们真正希望做的事情是：将<code>run</code>方法体内的代码传递给<code>Thread</code>类知晓。</p><p><strong>传递一段代码</strong>——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。</p><h3 id="生活举例"><a href="#生活举例" class="headerlink" title="生活举例"></a>生活举例</h3><p><img src="img/01-%E4%BA%A4%E9%80%9A%E6%96%B9%E5%BC%8F.png" srcset="/img/loading.gif" alt=""></p><p>当我们需要从北京到上海时，可以选择高铁、汽车、骑行或是徒步。我们的真正目的是到达上海，而如何才能到达上海的形式并不重要，所以我们一直在探索有没有比高铁更好的方式——搭乘飞机。</p><p><img src="img/02-Lambda.png" srcset="/img/loading.gif" alt=""></p><p>而现在这种飞机（甚至是飞船）已经诞生：2014年3月Oracle所发布的Java 8（JDK 1.8）中，加入了<strong>Lambda表达式</strong>的重量级新特性，为我们打开了新世界的大门。</p><h2 id="3-4-体验Lambda的更优写法"><a href="#3-4-体验Lambda的更优写法" class="headerlink" title="3.4 体验Lambda的更优写法"></a>3.4 体验Lambda的更优写法</h2><p>借助Java 8的全新语法，上述<code>Runnable</code>接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效：</p><pre><code class="java">public class Demo02LambdaRunnable {    public static void main(String[] args) {        new Thread(() -&gt; System.out.println(&quot;多线程任务执行！&quot;)).start(); // 启动线程    }}</code></pre><p>这段代码和刚才的执行效果是完全一样的，可以在1.8或更高的编译级别下通过。从代码的语义中可以看出：我们启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定。</p><p>不再有“不得不创建接口对象”的束缚，不再有“抽象方法覆盖重写”的负担，就是这么简单！</p><h2 id="3-5-回顾匿名内部类"><a href="#3-5-回顾匿名内部类" class="headerlink" title="3.5 回顾匿名内部类"></a>3.5 回顾匿名内部类</h2><p>Lambda是怎样击败面向对象的？在上例中，核心代码其实只是如下所示的内容：</p><pre><code class="java">() -&gt; System.out.println(&quot;多线程任务执行！&quot;)</code></pre><p>为了理解Lambda的语义，我们需要从传统的代码起步。</p><h3 id="使用实现类"><a href="#使用实现类" class="headerlink" title="使用实现类"></a>使用实现类</h3><p>要启动一个线程，需要创建一个<code>Thread</code>类的对象并调用<code>start</code>方法。而为了指定线程执行的内容，需要调用<code>Thread</code>类的构造方法：</p><ul><li><code>public Thread(Runnable target)</code></li></ul><p>为了获取<code>Runnable</code>接口的实现对象，可以为该接口定义一个实现类<code>RunnableImpl</code>：</p><pre><code class="java">public class RunnableImpl implements Runnable {    @Override    public void run() {        System.out.println(&quot;多线程任务执行！&quot;);    }}</code></pre><p>然后创建该实现类的对象作为<code>Thread</code>类的构造参数：</p><pre><code class="java">public class Demo03ThreadInitParam {    public static void main(String[] args) {        Runnable task = new RunnableImpl();        new Thread(task).start();    }}</code></pre><h3 id="使用匿名内部类"><a href="#使用匿名内部类" class="headerlink" title="使用匿名内部类"></a>使用匿名内部类</h3><p>这个<code>RunnableImpl</code>类只是为了实现<code>Runnable</code>接口而存在的，而且仅被使用了唯一一次，所以使用匿名内部类的语法即可省去该类的单独定义，即匿名内部类：</p><pre><code class="java">public class Demo04ThreadNameless {    public static void main(String[] args) {        new Thread(new Runnable() {            @Override            public void run() {                System.out.println(&quot;多线程任务执行！&quot;);            }        }).start();    }}</code></pre><h3 id="匿名内部类的好处与弊端"><a href="#匿名内部类的好处与弊端" class="headerlink" title="匿名内部类的好处与弊端"></a>匿名内部类的好处与弊端</h3><p>一方面，匿名内部类可以帮我们<strong>省去实现类的定义</strong>；另一方面，匿名内部类的语法——<strong>确实太复杂了！</strong></p><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>仔细分析该代码中的语义，<code>Runnable</code>接口只有一个<code>run</code>方法的定义：</p><ul><li><code>public abstract void run();</code></li></ul><p>即制定了一种做事情的方案（其实就是一个函数）：</p><ul><li><strong>无参数</strong>：不需要任何条件即可执行该方案。</li><li><strong>无返回值</strong>：该方案不产生任何结果。</li><li><strong>代码块</strong>（方法体）：该方案的具体执行步骤。</li></ul><p>同样的语义体现在<code>Lambda</code>语法中，要更加简单：</p><pre><code class="java">() -&gt; System.out.println(&quot;多线程任务执行！&quot;)</code></pre><ul><li>前面的一对小括号即<code>run</code>方法的参数（无），代表不需要任何条件；</li><li>中间的一个箭头代表将前面的参数传递给后面的代码；</li><li>后面的输出语句即业务逻辑代码。</li></ul><h2 id="3-6-Lambda标准格式"><a href="#3-6-Lambda标准格式" class="headerlink" title="3.6 Lambda标准格式"></a>3.6 Lambda标准格式</h2><p>Lambda省去面向对象的条条框框，格式由<strong>3个部分</strong>组成：</p><ul><li>一些参数</li><li>一个箭头</li><li>一段代码</li></ul><p>Lambda表达式的<strong>标准格式</strong>为：</p><pre><code>(参数类型 参数名称) -&gt; { 代码语句 }</code></pre><p>格式说明：</p><ul><li>小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。</li><li><code>-&gt;</code>是新引入的语法格式，代表指向动作。</li><li>大括号内的语法与传统方法体要求基本一致。</li></ul><h2 id="3-7-练习：使用Lambda标准格式（无参无返回）"><a href="#3-7-练习：使用Lambda标准格式（无参无返回）" class="headerlink" title="3.7 练习：使用Lambda标准格式（无参无返回）"></a>3.7 练习：使用Lambda标准格式（无参无返回）</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个厨子<code>Cook</code>接口，内含唯一的抽象方法<code>makeFood</code>，且无参数、无返回值。如下：</p><pre><code class="java">public interface Cook {    void makeFood();}</code></pre><p>在下面的代码中，请使用Lambda的<strong>标准格式</strong>调用<code>invokeCook</code>方法，打印输出“吃饭啦！”字样：</p><pre><code class="java">public class Demo05InvokeCook {    public static void main(String[] args) {        // TODO 请在此使用Lambda【标准格式】调用invokeCook方法    }    private static void invokeCook(Cook cook) {        cook.makeFood();    }}</code></pre><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><pre><code class="java">public static void main(String[] args) {    invokeCook(() -&gt; {          System.out.println(&quot;吃饭啦！&quot;);    });}</code></pre><blockquote><p>备注：小括号代表<code>Cook</code>接口<code>makeFood</code>抽象方法的参数为空，大括号代表<code>makeFood</code>的方法体。</p></blockquote><h2 id="3-8-Lambda的参数和返回值"><a href="#3-8-Lambda的参数和返回值" class="headerlink" title="3.8 Lambda的参数和返回值"></a>3.8 Lambda的参数和返回值</h2><pre><code>需求:    使用数组存储多个Person对象    对数组中的Person对象使用Arrays的sort方法通过年龄进行升序排序</code></pre><p>下面举例演示<code>java.util.Comparator&lt;T&gt;</code>接口的使用场景代码，其中的抽象方法定义为：</p><ul><li><code>public abstract int compare(T o1, T o2);</code></li></ul><p>当需要对一个对象数组进行排序时，<code>Arrays.sort</code>方法需要一个<code>Comparator</code>接口实例来指定排序的规则。假设有一个<code>Person</code>类，含有<code>String name</code>和<code>int age</code>两个成员变量：</p><pre><code class="java">public class Person {     private String name;    private int age;    // 省略构造器、toString方法与Getter Setter }</code></pre><h3 id="传统写法-1"><a href="#传统写法-1" class="headerlink" title="传统写法"></a>传统写法</h3><p>如果使用传统的代码对<code>Person[]</code>数组进行排序，写法如下：</p><pre><code class="java">import java.util.Arrays;import java.util.Comparator;public class Demo06Comparator {    public static void main(String[] args) {          // 本来年龄乱序的对象数组        Person[] array = {            new Person(&quot;古力娜扎&quot;, 19),            new Person(&quot;迪丽热巴&quot;, 18),               new Person(&quot;马尔扎哈&quot;, 20) };          // 匿名内部类        Comparator&lt;Person&gt; comp = new Comparator&lt;Person&gt;() {            @Override            public int compare(Person o1, Person o2) {                return o1.getAge() - o2.getAge();            }        };        Arrays.sort(array, comp); // 第二个参数为排序规则，即Comparator接口实例        for (Person person : array) {            System.out.println(person);        }    }}</code></pre><p>这种做法在面向对象的思想中，似乎也是“理所当然”的。其中<code>Comparator</code>接口的实例（使用了匿名内部类）代表了“按照年龄从小到大”的排序规则。</p><h3 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h3><p>下面我们来搞清楚上述代码真正要做什么事情。</p><ul><li>为了排序，<code>Arrays.sort</code>方法需要排序规则，即<code>Comparator</code>接口的实例，抽象方法<code>compare</code>是关键；</li><li>为了指定<code>compare</code>的方法体，<strong>不得不</strong>需要<code>Comparator</code>接口的实现类；</li><li>为了省去定义一个<code>ComparatorImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li><li>必须覆盖重写抽象<code>compare</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li><li>实际上，<strong>只有参数和方法体才是关键</strong>。</li></ul><h3 id="Lambda写法"><a href="#Lambda写法" class="headerlink" title="Lambda写法"></a>Lambda写法</h3><pre><code class="java">import java.util.Arrays;public class Demo07ComparatorLambda {    public static void main(String[] args) {        Person[] array = {              new Person(&quot;古力娜扎&quot;, 19),              new Person(&quot;迪丽热巴&quot;, 18),              new Person(&quot;马尔扎哈&quot;, 20) };        Arrays.sort(array, (Person a, Person b) -&gt; {              return a.getAge() - b.getAge();        });        for (Person person : array) {            System.out.println(person);        }    }}</code></pre><h2 id="3-9-练习：使用Lambda标准格式（有参有返回）"><a href="#3-9-练习：使用Lambda标准格式（有参有返回）" class="headerlink" title="3.9 练习：使用Lambda标准格式（有参有返回）"></a>3.9 练习：使用Lambda标准格式（有参有返回）</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个计算器<code>Calculator</code>接口，内含抽象方法<code>calc</code>可以将两个int数字相加得到和值：</p><pre><code class="java">public interface Calculator {    int calc(int a, int b);}</code></pre><p>在下面的代码中，请使用Lambda的<strong>标准格式</strong>调用<code>invokeCalc</code>方法，完成120和130的相加计算：</p><pre><code class="java">public class Demo08InvokeCalc {    public static void main(String[] args) {        // TODO 请在此使用Lambda【标准格式】调用invokeCalc方法来计算120+130的结果ß    }    private static void invokeCalc(int a, int b, Calculator calculator) {        int result = calculator.calc(a, b);        System.out.println(&quot;结果是：&quot; + result);    }}</code></pre><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><pre><code class="java">public static void main(String[] args) {    invokeCalc(120, 130, (int a, int b) -&gt; {          return a + b;    });}</code></pre><blockquote><p>备注：小括号代表<code>Calculator</code>接口<code>calc</code>抽象方法的参数，大括号代表<code>calc</code>的方法体。</p></blockquote><h2 id="3-10-Lambda省略格式"><a href="#3-10-Lambda省略格式" class="headerlink" title="3.10 Lambda省略格式"></a>3.10 Lambda省略格式</h2><h3 id="可推导即可省略"><a href="#可推导即可省略" class="headerlink" title="可推导即可省略"></a>可推导即可省略</h3><p>Lambda强调的是“做什么”而不是“怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。例如上例还可以使用Lambda的省略写法：</p><pre><code class="java">public static void main(String[] args) {      invokeCalc(120, 130, (a, b) -&gt; a + b);}</code></pre><h3 id="省略规则"><a href="#省略规则" class="headerlink" title="省略规则"></a>省略规则</h3><p>在Lambda标准格式的基础上，使用省略写法的规则为：</p><ol><li>小括号内参数的类型可以省略；</li><li>如果小括号内<strong>有且仅有一个参</strong>，则小括号可以省略；</li><li>如果大括号内<strong>有且仅有一个语句</strong>，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。</li></ol><blockquote><p>备注：掌握这些省略规则后，请对应地回顾本章开头的多线程案例。</p></blockquote><h2 id="3-11-练习：使用Lambda省略格式"><a href="#3-11-练习：使用Lambda省略格式" class="headerlink" title="3.11 练习：使用Lambda省略格式"></a>3.11 练习：使用Lambda省略格式</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>仍然使用前文含有唯一<code>makeFood</code>抽象方法的厨子<code>Cook</code>接口，在下面的代码中，请使用Lambda的<strong>省略格式</strong>调用<code>invokeCook</code>方法，打印输出“吃饭啦！”字样：</p><pre><code class="java">public class Demo09InvokeCook {    public static void main(String[] args) {        // TODO 请在此使用Lambda【省略格式】调用invokeCook方法    }    private static void invokeCook(Cook cook) {        cook.makeFood();    }}</code></pre><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><pre><code class="java">public static void main(String[] args) {      invokeCook(() -&gt; System.out.println(&quot;吃饭啦！&quot;));}</code></pre><h2 id="3-12-Lambda的使用前提"><a href="#3-12-Lambda的使用前提" class="headerlink" title="3.12 Lambda的使用前提"></a>3.12 Lambda的使用前提</h2><p>Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：</p><ol><li>使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong>。<br>无论是JDK内置的<code>Runnable</code>、<code>Comparator</code>接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。</li><li>使用Lambda必须具有<strong>上下文推断</strong>。<br>也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li></ol><blockquote><p>备注：有且仅有一个抽象方法的接口，称为“<strong>函数式接口</strong>”。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>lamda</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>day06 【线程、同步】教案</title>
    <link href="/2017/04/19/day06%20%E3%80%90%E7%BA%BF%E7%A8%8B%E3%80%81%E5%90%8C%E6%AD%A5%E3%80%91%E6%95%99%E6%A1%88/"/>
    <url>/2017/04/19/day06%20%E3%80%90%E7%BA%BF%E7%A8%8B%E3%80%81%E5%90%8C%E6%AD%A5%E3%80%91%E6%95%99%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h3 id="一、学习目标"><a href="#一、学习目标" class="headerlink" title="一、学习目标"></a>一、学习目标</h3><ol><li>能够描述Java中多线程运行原理</li><li>能够使用继承类的方式创建多线程</li><li>能够使用实现接口的方式创建多线程</li><li>能够说出实现接口方式的好处</li><li>能够解释安全问题的出现的原因</li><li>能够使用同步代码块解决线程安全问题</li><li>能够使用同步方法解决线程安全问题</li><li>能够说出线程6个状态的名称</li></ol><h3 id="二、学习指南"><a href="#二、学习指南" class="headerlink" title="二、学习指南"></a>二、学习指南</h3><ol><li>线程程序的随机性&amp;开启线程的第二种方式</li><li>开启线程两种方式的区别</li><li>线程安全问题&amp;同步技术</li><li>线程状态&amp;线程通讯</li></ol><h3 id="第一堂课"><a href="#第一堂课" class="headerlink" title="第一堂课"></a>第一堂课</h3><p>本节知识点</p><p>01_今日内容介绍</p><p>02_多线程原理_随机性打印结果</p><p>03_多线程原理_多线程内存图解</p><p>04_Thread类的常用方法_获取线程名称的方法</p><p>05_Thread类的常用方法_设置线程名称的方法</p><p>视频时间</p><p> 27分33秒</p><p>本节目标</p><p> 了解今天所学内容</p><p> 理解多线程程序的随机性</p><p> 了解多线程程序在内存中的基本划分</p><p> 掌握获取线程名称的两种方式</p><p> 掌握设置线程名称的两种方式</p><p>1.</p><ol><li>1.1 今日内容介绍</li></ol><h5 id="1-1-1知识概述"><a href="#1-1-1知识概述" class="headerlink" title="1.1.1知识概述"></a>1.1.1知识概述</h5><p>今日内容介绍</p><h5 id="1-1-2视频详情"><a href="#1-1-2视频详情" class="headerlink" title="1.1.2视频详情"></a>1.1.2视频详情</h5><p>无</p><h5 id="1-1-3总结与补充"><a href="#1-1-3总结与补充" class="headerlink" title="1.1.3总结与补充"></a>1.1.3总结与补充</h5><p>无</p><h5 id="1-1-4课堂提问与练习"><a href="#1-1-4课堂提问与练习" class="headerlink" title="1.1.4课堂提问与练习"></a>1.1.4课堂提问与练习</h5><p>无</p><h5 id="1-1-5习题答案"><a href="#1-1-5习题答案" class="headerlink" title="1.1.5习题答案"></a>1.1.5习题答案</h5><p>无</p><p>1.</p><ol><li>1.2 多线程原理_随机性打印结果</li></ol><h5 id="1-2-1知识概述"><a href="#1-2-1知识概述" class="headerlink" title="1.2.1知识概述"></a>1.2.1知识概述</h5><ul><li>多线程原理_随机性打印结果</li></ul><h5 id="1-2-2视频详情"><a href="#1-2-2视频详情" class="headerlink" title="1.2.2视频详情"></a>1.2.2视频详情</h5><h5 id="1-2-3总结与补充"><a href="#1-2-3总结与补充" class="headerlink" title="1.2.3总结与补充"></a>1.2.3总结与补充</h5><h5 id="1-2-4课堂提问与练习"><a href="#1-2-4课堂提问与练习" class="headerlink" title="1.2.4课堂提问与练习"></a>1.2.4课堂提问与练习</h5><p> 无</p><h5 id="1-2-5习题答案"><a href="#1-2-5习题答案" class="headerlink" title="1.2.5习题答案"></a>1.2.5习题答案</h5><p> 无</p><p>1.</p><ol><li>1.3 多线程原理_多线程内存图解</li></ol><h5 id="1-3-1知识概述"><a href="#1-3-1知识概述" class="headerlink" title="1.3.1知识概述"></a>1.3.1知识概述</h5><ul><li>每个线程都有自己独立的一块栈空间</li></ul><h5 id="1-3-2视频详情"><a href="#1-3-2视频详情" class="headerlink" title="1.3.2视频详情"></a>1.3.2视频详情</h5><h5 id="1-3-3总结与补充"><a href="#1-3-3总结与补充" class="headerlink" title="1.3.3总结与补充"></a>1.3.3总结与补充</h5><pre><code>    多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈</code></pre><h5 id="1-3-4课堂提问与练习"><a href="#1-3-4课堂提问与练习" class="headerlink" title="1.3.4课堂提问与练习"></a>1.3.4课堂提问与练习</h5><p> 无</p><h5 id="1-3-5习题答案"><a href="#1-3-5习题答案" class="headerlink" title="1.3.5习题答案"></a>1.3.5习题答案</h5><p> 无</p><p>1.</p><ol><li>1.4 Thread类的常用方法_获取线程名称的方法</li></ol><h5 id="1-4-1知识概述"><a href="#1-4-1知识概述" class="headerlink" title="1.4.1知识概述"></a>1.4.1知识概述</h5><ul><li>getName();</li><li>currentThread.getName();</li></ul><h5 id="1-4-2视频详情"><a href="#1-4-2视频详情" class="headerlink" title="1.4.2视频详情"></a>1.4.2视频详情</h5><h5 id="1-4-3总结与补充"><a href="#1-4-3总结与补充" class="headerlink" title="1.4.3总结与补充"></a>1.4.3总结与补充</h5><p>public String getName() :获取当前线程名称。</p><p>public static Thread currentThread() :返回对当前正在执行的线程对象的引用</p><h5 id="1-4-4课堂提问与练习"><a href="#1-4-4课堂提问与练习" class="headerlink" title="1.4.4课堂提问与练习"></a>1.4.4课堂提问与练习</h5><p> 无</p><h5 id="1-4-5习题答案"><a href="#1-4-5习题答案" class="headerlink" title="1.4.5习题答案"></a>1.4.5习题答案</h5><p> 无</p><p>1.</p><ol><li>1.5 Thread类的常用方法_设置线程名称的方法</li></ol><h5 id="1-5-1知识概述"><a href="#1-5-1知识概述" class="headerlink" title="1.5.1知识概述"></a>1.5.1知识概述</h5><ul><li>setName();</li><li>new Thread(&quot;线程名字&quot;);</li></ul><h5 id="1-5-2视频详情"><a href="#1-5-2视频详情" class="headerlink" title="1.5.2视频详情"></a>1.5.2视频详情</h5><h5 id="1-5-3总结与补充"><a href="#1-5-3总结与补充" class="headerlink" title="1.5.3总结与补充"></a>1.5.3总结与补充</h5><p>public Thread(String name) :分配一个指定名字的新的线程对象</p><p>public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字</p><p>public void setName(String name) : 为线程对象设置名字.</p><h5 id="1-5-4课堂提问与练习"><a href="#1-5-4课堂提问与练习" class="headerlink" title="1.5.4课堂提问与练习"></a>1.5.4课堂提问与练习</h5><p> 无</p><h5 id="1-5-5习题答案"><a href="#1-5-5习题答案" class="headerlink" title="1.5.5习题答案"></a>1.5.5习题答案</h5><p> 无</p><h3 id="第二堂课"><a href="#第二堂课" class="headerlink" title="第二堂课"></a>第二堂课</h3><p>本节知识点：</p><p>06_Thread类的常用方法_sleep</p><p>07_创建多线程程序的第二种方式_实现Runnable接口</p><p>08_Thread和Runnable的区别</p><p>09_匿名内部类方式实现线程的创建</p><p>视频时间：</p><p> 21分28秒</p><p>本节目标 ：</p><ol><li>掌握sleep方法的使用</li><li>掌握实现Runnable接口开启线程的实现方式</li><li>独立阐述两种开启线程的区别</li><li>独立编写代码, 使用匿名内部类开启线程</li></ol><p>1.</p><ol><li>2.1Thread类的常用方法_sleep</li></ol><h5 id="2-1-1知识概述"><a href="#2-1-1知识概述" class="headerlink" title="2.1.1知识概述"></a>2.1.1知识概述</h5><ul><li>sleep方法演示</li></ul><h5 id="2-1-2视频详情"><a href="#2-1-2视频详情" class="headerlink" title="2.1.2视频详情"></a>2.1.2视频详情</h5><h5 id="2-1-3总结与补充"><a href="#2-1-3总结与补充" class="headerlink" title="2.1.3总结与补充"></a>2.1.3总结与补充</h5><p>无</p><h5 id="2-1-5习题答案"><a href="#2-1-5习题答案" class="headerlink" title="2.1.5习题答案"></a>2.1.5习题答案</h5><p>无</p><p>1.</p><ol><li>2.2创建多线程程序的第二种方式_实现Runnable接口</li></ol><h5 id="2-2-1知识概述"><a href="#2-2-1知识概述" class="headerlink" title="2.2.1知识概述"></a>2.2.1知识概述</h5><ul><li>开启线程的第二种方式</li></ul><h5 id="2-2-2视频详情"><a href="#2-2-2视频详情" class="headerlink" title="2.2.2视频详情"></a>2.2.2视频详情</h5><h5 id="2-2-3总结与补充"><a href="#2-2-3总结与补充" class="headerlink" title="2.2.3总结与补充"></a>2.2.3总结与补充</h5><ol><li>定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li><li>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</li><li>调用线程对象的start()方法来启动线程</li></ol><h5 id="2-2-4课堂提问与练习"><a href="#2-2-4课堂提问与练习" class="headerlink" title="2.2.4课堂提问与练习"></a>2.2.4课堂提问与练习</h5><p> 无</p><h5 id="2-2-5习题答案"><a href="#2-2-5习题答案" class="headerlink" title="2.2.5习题答案"></a>2.2.5习题答案</h5><p> 无</p><p>1.</p><ol><li>2.3Thread和Runnable的区别</li></ol><h5 id="2-3-1知识概述"><a href="#2-3-1知识概述" class="headerlink" title="2.3.1知识概述"></a>2.3.1知识概述</h5><ul><li>两种开启线程的区别</li></ul><h5 id="2-3-2视频详情"><a href="#2-3-2视频详情" class="headerlink" title="2.3.2视频详情"></a>2.3.2视频详情</h5><h5 id="2-3-3总结与补充"><a href="#2-3-3总结与补充" class="headerlink" title="2.3.3总结与补充"></a>2.3.3总结与补充</h5><p> 实现Runnable接口创建多线程程序的好处:</p><pre><code>    1.避免了单继承的局限性        一个类只能继承一个类(一个人只能有一个亲爹),类继承了Thread类就不能继 承其他的类        实现了Runnable接口,还可以继承其他的类,实现其他的接口    2.增强了程序的扩展性,降低了程序的耦合性(解耦)        实现Runnable接口的方式,把设置线程任务和开启新线程进行了分离(解耦)        实现类中,重写了run方法:用来设置线程任务        创建Thread类对象,调用start方法:用来开启新线程</code></pre><h5 id="2-3-4课堂提问与练习"><a href="#2-3-4课堂提问与练习" class="headerlink" title="2.3.4课堂提问与练习"></a>2.3.4课堂提问与练习</h5><pre><code>    无</code></pre><h5 id="2-3-5习题答案"><a href="#2-3-5习题答案" class="headerlink" title="2.3.5习题答案"></a>2.3.5习题答案</h5><p> 无</p><p>1.</p><ol><li>2.4匿名内部类方式实现线程的创建</li></ol><h5 id="2-4-1知识概述"><a href="#2-4-1知识概述" class="headerlink" title="2.4.1知识概述"></a>2.4.1知识概述</h5><ul><li>使用匿名内部类开启线程</li></ul><h5 id="2-4-2视频详情"><a href="#2-4-2视频详情" class="headerlink" title="2.4.2视频详情"></a>2.4.2视频详情</h5><h5 id="2-4-3总结与补充"><a href="#2-4-3总结与补充" class="headerlink" title="2.4.3总结与补充"></a>2.4.3总结与补充</h5><p><strong>2.4.4课堂提问与练习</strong></p><pre><code>    无</code></pre><h5 id="2-4-5习题答案"><a href="#2-4-5习题答案" class="headerlink" title="2.4.5习题答案"></a>2.4.5习题答案</h5><p> 无</p><h3 id="第三堂课"><a href="#第三堂课" class="headerlink" title="第三堂课"></a>第三堂课</h3><p>本节知识点：</p><p>10_线程安全问题的概述</p><p>11_线程安全问题的代码实现</p><p>12_线程安全问题产生的原理</p><p>13_解决线程安全问题_同步代码块</p><p>视频时间:</p><p>31分31秒</p><p>本节目标 ：</p><ol><li>了解多线程程序共享资源的时候, 会有安全隐患</li><li>独立编写售票案例代码</li><li>理解线程安全问题的产生原理</li><li>掌握同步代码块的使用</li></ol><p>1.</p><ol><li>3.1线程安全问题的概述</li></ol><h5 id="3-1-1知识概述"><a href="#3-1-1知识概述" class="headerlink" title="3.1.1知识概述"></a>3.1.1知识概述</h5><ul><li>线程安全问题引入</li></ul><h5 id="3-1-2视频详情"><a href="#3-1-2视频详情" class="headerlink" title="3.1.2视频详情"></a>3.1.2视频详情</h5><h5 id="3-1-3总结与补充"><a href="#3-1-3总结与补充" class="headerlink" title="3.1.3总结与补充"></a>3.1.3总结与补充</h5><h5 id="3-1-4课堂提问与练习"><a href="#3-1-4课堂提问与练习" class="headerlink" title="3.1.4课堂提问与练习"></a>3.1.4课堂提问与练习</h5><p> 无</p><h5 id="3-1-5习题答案"><a href="#3-1-5习题答案" class="headerlink" title="3.1.5习题答案"></a>3.1.5习题答案</h5><p> 无</p><p>1.</p><ol><li>3.2线程安全问题的代码实现</li></ol><h5 id="3-2-1知识概述"><a href="#3-2-1知识概述" class="headerlink" title="3.2.1知识概述"></a>3.2.1知识概述</h5><ul><li>多线程售票案例代码实现</li></ul><h5 id="3-2-2视频详情"><a href="#3-2-2视频详情" class="headerlink" title="3.2.2视频详情"></a>3.2.2视频详情</h5><h5 id="3-2-3总结与补充"><a href="#3-2-3总结与补充" class="headerlink" title="3.2.3总结与补充"></a>3.2.3总结与补充</h5><h5 id="3-2-4课堂提问与练习"><a href="#3-2-4课堂提问与练习" class="headerlink" title="3.2.4课堂提问与练习"></a>3.2.4课堂提问与练习</h5><p>无</p><h5 id="3-2-5习题答案"><a href="#3-2-5习题答案" class="headerlink" title="3.2.5习题答案"></a>3.2.5习题答案</h5><p>无</p><p>1.</p><ol><li>3.3线程安全问题产生的原理</li></ol><h5 id="3-3-1知识概述"><a href="#3-3-1知识概述" class="headerlink" title="3.3.1知识概述"></a>3.3.1知识概述</h5><ul><li>画图分析线程安全问题所在</li></ul><h5 id="3-3-2视频详情"><a href="#3-3-2视频详情" class="headerlink" title="3.3.2视频详情"></a>3.3.2视频详情</h5><h5 id="3-3-3总结与补充"><a href="#3-3-3总结与补充" class="headerlink" title="3.3.3总结与补充"></a>3.3.3总结与补充</h5><h5 id="3-3-4课堂提问与练习"><a href="#3-3-4课堂提问与练习" class="headerlink" title="3.3.4课堂提问与练习"></a>3.3.4课堂提问与练习</h5><p>无</p><h5 id="3-3-5习题答案"><a href="#3-3-5习题答案" class="headerlink" title="3.3.5习题答案"></a>3.3.5习题答案</h5><p> 无</p><p>1.</p><ol><li>3.4解决线程安全问题_同步代码块</li></ol><h5 id="3-3-1知识概述-1"><a href="#3-3-1知识概述-1" class="headerlink" title="3.3.1知识概述"></a>3.3.1知识概述</h5><ul><li>同步代码块解决线程安全问题</li></ul><h5 id="3-3-2视频详情-1"><a href="#3-3-2视频详情-1" class="headerlink" title="3.3.2视频详情"></a>3.3.2视频详情</h5><h5 id="3-3-3总结与补充-1"><a href="#3-3-3总结与补充-1" class="headerlink" title="3.3.3总结与补充"></a>3.3.3总结与补充</h5><p> 同步代码块： synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</p><p> 格式:</p><pre><code>    synchronized(锁对象){        可能会出现线程安全问题的代码(访问了共享数据的代码)    }注意:    1.通过代码块中的锁对象,可以使用任意的对象    2.但是必须保证多个线程使用的锁对象是同一个    3.锁对象作用:        把同步代码块锁住,只让一个线程在同步代码块中执行</code></pre><h5 id="3-3-4课堂提问与练习-1"><a href="#3-3-4课堂提问与练习-1" class="headerlink" title="3.3.4课堂提问与练习"></a>3.3.4课堂提问与练习</h5><p>无</p><h5 id="3-3-5习题答案-1"><a href="#3-3-5习题答案-1" class="headerlink" title="3.3.5习题答案"></a>3.3.5习题答案</h5><p> 无</p><h3 id="第四堂课"><a href="#第四堂课" class="headerlink" title="第四堂课"></a>第四堂课</h3><p>本节知识点：</p><p>14_同步技术的原理</p><p>15_解决线程安全问题_同步方法</p><p>16_静态同步方法</p><p>17_解决线程安全问题_Lock锁</p><p>视频时间：</p><p>25分26秒</p><p>本节目标 ：</p><p> 理解同步技术的原理</p><p> 掌握同步方法的使用</p><p> 了解静态同步方法的使用</p><p> 掌握Lock锁的使用方式</p><h4 id="4-1-同步技术的原理"><a href="#4-1-同步技术的原理" class="headerlink" title="4.1 同步技术的原理"></a>4.1 同步技术的原理</h4><h5 id="4-1-1知识概述"><a href="#4-1-1知识概述" class="headerlink" title="4.1.1知识概述"></a>4.1.1知识概述</h5><ul><li>同步技术的原理</li></ul><h5 id="4-1-2视频详情"><a href="#4-1-2视频详情" class="headerlink" title="4.1.2视频详情"></a>4.1.2视频详情</h5><h5 id="4-1-3总结与补充"><a href="#4-1-3总结与补充" class="headerlink" title="4.1.3总结与补充"></a>4.1.3总结与补充</h5><h5 id="4-1-4课堂提问与练习"><a href="#4-1-4课堂提问与练习" class="headerlink" title="4.1.4课堂提问与练习"></a>4.1.4课堂提问与练习</h5><p>无</p><h5 id="4-1-5习题答案"><a href="#4-1-5习题答案" class="headerlink" title="4.1.5习题答案"></a>4.1.5习题答案</h5><p> 无</p><h4 id="4-2-解决线程安全问题-同步方法"><a href="#4-2-解决线程安全问题-同步方法" class="headerlink" title="4.2 解决线程安全问题_同步方法"></a>4.2 解决线程安全问题_同步方法</h4><h5 id="4-2-1知识概述"><a href="#4-2-1知识概述" class="headerlink" title="4.2.1知识概述"></a>4.2.1知识概述</h5><ul><li>同步方法 &amp; 同步方法的锁对象</li></ul><h5 id="4-2-2视频详情"><a href="#4-2-2视频详情" class="headerlink" title="4.2.2视频详情"></a>4.2.2视频详情</h5><h5 id="4-2-3总结与补充"><a href="#4-2-3总结与补充" class="headerlink" title="4.2.3总结与补充"></a>4.2.3总结与补充</h5><p> 同步方法:使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。</p><h5 id="4-2-4课堂提问与练习"><a href="#4-2-4课堂提问与练习" class="headerlink" title="4.2.4课堂提问与练习"></a>4.2.4课堂提问与练习</h5><p>无</p><h5 id="4-2-5习题答案"><a href="#4-2-5习题答案" class="headerlink" title="4.2.5习题答案"></a>4.2.5习题答案</h5><p> 无</p><h4 id="4-3-静态同步方法"><a href="#4-3-静态同步方法" class="headerlink" title="4.3 静态同步方法"></a>4.3 静态同步方法</h4><h5 id="4-3-1知识概述"><a href="#4-3-1知识概述" class="headerlink" title="4.3.1知识概述"></a>4.3.1知识概述</h5><ul><li><strong>静态同步方法</strong></li></ul><h5 id="4-3-2视频详情"><a href="#4-3-2视频详情" class="headerlink" title="4.3.2视频详情"></a>4.3.2视频详情</h5><h5 id="4-3-3总结与补充"><a href="#4-3-3总结与补充" class="headerlink" title="4.3.3总结与补充"></a>4.3.3总结与补充</h5><pre><code>    对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。</code></pre><h5 id="4-3-4课堂提问与练习"><a href="#4-3-4课堂提问与练习" class="headerlink" title="4.3.4课堂提问与练习"></a>4.3.4课堂提问与练习</h5><p>无</p><h5 id="4-3-5习题答案"><a href="#4-3-5习题答案" class="headerlink" title="4.3.5习题答案"></a>4.3.5习题答案</h5><p>  无</p><h4 id="4-4-解决线程安全问题-Lock锁"><a href="#4-4-解决线程安全问题-Lock锁" class="headerlink" title="4.4 解决线程安全问题_Lock锁"></a>4.4 解决线程安全问题_Lock锁</h4><h5 id="4-4-1知识概述"><a href="#4-4-1知识概述" class="headerlink" title="4.4.1知识概述"></a>4.4.1知识概述</h5><ul><li>lock方法, unlock方法</li></ul><h5 id="4-4-2视频详情"><a href="#4-4-2视频详情" class="headerlink" title="4.4.2视频详情"></a>4.4.2视频详情</h5><h5 id="4-4-3总结与补充"><a href="#4-4-3总结与补充" class="headerlink" title="4.4.3总结与补充"></a>4.4.3总结与补充</h5><p>public void lock() :加同步锁。<br>public void unlock() :释放同步锁</p><h5 id="4-4-4课堂提问与练习"><a href="#4-4-4课堂提问与练习" class="headerlink" title="4.4.4课堂提问与练习"></a>4.4.4课堂提问与练习</h5><p>无</p><h5 id="4-4-5习题答案"><a href="#4-4-5习题答案" class="headerlink" title="4.4.5习题答案"></a>4.4.5习题答案</h5><p> 无</p><h3 id="第五堂课"><a href="#第五堂课" class="headerlink" title="第五堂课"></a>第五堂课</h3><p>本节知识点：</p><p>18_线程状态概述</p><p>19_等待唤醒案例分析</p><p>20_等待唤醒案例代码实现</p><p>21_Object类中wait带参方法和notifyAll方法</p><p>视频时间：</p><p>28分38秒</p><p>本节目标 ：</p><p> 了解API中线程的6种状态</p><p> 理解等待唤醒实现线程通讯的思路</p><p> 独立编写等待唤醒案例</p><p> 了解wait带参方法和notifyAll方法的特点</p><h4 id="5-1-线程状态概述"><a href="#5-1-线程状态概述" class="headerlink" title="5.1 线程状态概述"></a>5.1 线程状态概述</h4><h5 id="5-1-1知识概述"><a href="#5-1-1知识概述" class="headerlink" title="5.1.1知识概述"></a>5.1.1知识概述</h5><ul><li>线程的6中状态</li></ul><h5 id="5-1-2视频详情"><a href="#5-1-2视频详情" class="headerlink" title="5.1.2视频详情"></a>5.1.2视频详情</h5><h5 id="5-1-3总结与补充"><a href="#5-1-3总结与补充" class="headerlink" title="5.1.3总结与补充"></a>5.1.3总结与补充</h5><h5 id="5-1-4课堂提问与练习"><a href="#5-1-4课堂提问与练习" class="headerlink" title="5.1.4课堂提问与练习"></a>5.1.4课堂提问与练习</h5><p>无</p><h5 id="5-1-5习题答案"><a href="#5-1-5习题答案" class="headerlink" title="5.1.5习题答案"></a>5.1.5习题答案</h5><p>  无</p><h4 id="5-2-等待唤醒案例分析"><a href="#5-2-等待唤醒案例分析" class="headerlink" title="5.2 等待唤醒案例分析"></a>5.2 等待唤醒案例分析</h4><h5 id="5-2-1知识概述"><a href="#5-2-1知识概述" class="headerlink" title="5.2.1知识概述"></a>5.2.1知识概述</h5><ul><li>线程通讯案例分析</li></ul><h5 id="5-2-2视频详情"><a href="#5-2-2视频详情" class="headerlink" title="5.2.2视频详情"></a>5.2.2视频详情</h5><h5 id="5-2-3总结与补充"><a href="#5-2-3总结与补充" class="headerlink" title="5.2.3总结与补充"></a>5.2.3总结与补充</h5><h5 id="5-2-4课堂提问与练习"><a href="#5-2-4课堂提问与练习" class="headerlink" title="5.2.4课堂提问与练习"></a>5.2.4课堂提问与练习</h5><p>无</p><h5 id="5-2-5习题答案"><a href="#5-2-5习题答案" class="headerlink" title="5.2.5习题答案"></a>5.2.5习题答案</h5><p> 无</p><h4 id="5-3-等待唤醒案例代码实现"><a href="#5-3-等待唤醒案例代码实现" class="headerlink" title="5.3 等待唤醒案例代码实现"></a>5.3 等待唤醒案例代码实现</h4><h5 id="5-3-1知识概述"><a href="#5-3-1知识概述" class="headerlink" title="5.3.1知识概述"></a>5.3.1知识概述</h5><ul><li>线程通讯代码实现</li><li>wait方法</li><li>notify方法</li></ul><h5 id="5-3-2视频详情"><a href="#5-3-2视频详情" class="headerlink" title="5.3.2视频详情"></a>5.3.2视频详情</h5><h5 id="5-3-3总结与补充"><a href="#5-3-3总结与补充" class="headerlink" title="5.3.3总结与补充"></a>5.3.3总结与补充</h5><p>等待唤醒案例:线程之间的通信</p><pre><code>    创建一个顾客线程(消费者):告知老板要的包子的种类和数量,调用wait方法,放弃cpu的执行,进入到WAITING状态(无限等待)    创建一个老板线程(生产者):花了5秒做包子,做好包子之后,调用notify方法,唤醒顾客吃包子注意:    顾客和老板线程必须使用同步代码块包裹起来,保证等待和唤醒只能有一个在执行    同步使用的锁对象必须保证唯一    只有锁对象才能调用wait和notify方法Obejct类中的方法void wait()      在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。void notify()    唤醒在此对象监视器上等待的单个线程。会继续执行wait方法之后的代码</code></pre><h5 id="5-3-4课堂提问与练习"><a href="#5-3-4课堂提问与练习" class="headerlink" title="5.3.4课堂提问与练习"></a>5.3.4课堂提问与练习</h5><p>无</p><h5 id="5-3-5习题答案"><a href="#5-3-5习题答案" class="headerlink" title="5.3.5习题答案"></a>5.3.5习题答案</h5><p>  无</p><h4 id="5-4-Object类中wait带参方法和notifyAll方法"><a href="#5-4-Object类中wait带参方法和notifyAll方法" class="headerlink" title="5.4  Object类中wait带参方法和notifyAll方法"></a>5.4  Object类中wait带参方法和notifyAll方法</h4><h5 id="5-3-1知识概述-1"><a href="#5-3-1知识概述-1" class="headerlink" title="5.3.1知识概述"></a>5.3.1知识概述</h5><ul><li>Object类中wait带参方法和notifyAll方法</li></ul><h5 id="5-3-2视频详情-1"><a href="#5-3-2视频详情-1" class="headerlink" title="5.3.2视频详情"></a>5.3.2视频详情</h5><h5 id="5-3-3总结与补充-1"><a href="#5-3-3总结与补充-1" class="headerlink" title="5.3.3总结与补充"></a>5.3.3总结与补充</h5><p>进入到TimeWaiting(计时等待)有两种方式</p><pre><code>1.使用sleep(long m)方法,在毫秒值结束之后,线程睡醒进入到Runnable/Blocked状态2.使用wait(long m)方法,wait方法如果在毫秒值结束之后,还没有被notify唤醒,就会自动醒来,线程睡醒进入到Runnable/Blocked状态唤醒的方法:     void notify() 唤醒在此对象监视器上等待的单个线程。     void notifyAll() 唤醒在此对象监视器上等待的所有线程。</code></pre><h5 id="5-3-4课堂提问与练习-1"><a href="#5-3-4课堂提问与练习-1" class="headerlink" title="5.3.4课堂提问与练习"></a>5.3.4课堂提问与练习</h5><p>无</p><h5 id="5-3-5习题答案-1"><a href="#5-3-5习题答案-1" class="headerlink" title="5.3.5习题答案"></a>5.3.5习题答案</h5><p> 无</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>lamda</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>day05 【异常、线程】</title>
    <link href="/2017/04/18/day05%20%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/"/>
    <url>/2017/04/18/day05%20%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="day05-【异常、线程】"><a href="#day05-【异常、线程】" class="headerlink" title="day05 【异常、线程】"></a>day05 【异常、线程】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul><li>异常、线程</li></ul><h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul><li><input disabled="" type="checkbox"> 能够辨别程序中异常和错误的区别</li><li><input disabled="" type="checkbox"> 说出异常的分类</li><li><input disabled="" type="checkbox"> 说出虚拟机处理异常的方式</li><li><input disabled="" type="checkbox"> 列举出常见的三个运行期异常</li><li><input disabled="" type="checkbox"> 能够使用try…catch关键字处理异常</li><li><input disabled="" type="checkbox"> 能够使用throws关键字处理异常</li><li><input disabled="" type="checkbox"> 能够自定义异常类</li><li><input disabled="" type="checkbox"> 能够处理自定义异常类</li><li><input disabled="" type="checkbox"> 说出进程的概念</li><li><input disabled="" type="checkbox"> 说出线程的概念</li><li><input disabled="" type="checkbox"> 能够理解并发与并行的区别</li><li><input disabled="" type="checkbox"> 能够开启新线程</li></ul><h1 id="第一章-异常"><a href="#第一章-异常" class="headerlink" title="第一章    异常"></a>第一章    异常</h1><h2 id="1-1-异常概念"><a href="#1-1-异常概念" class="headerlink" title="1.1 异常概念"></a>1.1 异常概念</h2><p>异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是：</p><ul><li><strong>异常</strong> ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。</li></ul><p>在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。</p><blockquote><p>异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.</p></blockquote><h2 id="1-2-异常体系"><a href="#1-2-异常体系" class="headerlink" title="1.2 异常体系"></a>1.2 异常体系</h2><p>异常机制其实是帮助我们<strong>找到</strong>程序中的问题，异常的根类是<code>java.lang.Throwable</code>，其下有两个子类：<code>java.lang.Error</code>与<code>java.lang.Exception</code>，平常所说的异常指<code>java.lang.Exception</code>。</p><p><img src="img%5C%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.png" srcset="/img/loading.gif" alt=""></p><p><strong>Throwable体系：</strong></p><ul><li><strong>Error</strong>:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。</li><li><strong>Exception</strong>:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。</li></ul><p><strong>Throwable中的常用方法：</strong></p><ul><li><p><code>public void printStackTrace()</code>:打印异常的详细信息。</p><p><em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p></li><li><p><code>public String getMessage()</code>:获取发生异常的原因。</p><p><em>提示给用户的时候,就提示错误原因。</em></p></li><li><p><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</p></li></ul><p><strong><em>出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。</em></strong></p><p><img src="img%5C%E7%AE%80%E5%8D%95%E7%9A%84%E5%BC%82%E5%B8%B8%E6%9F%A5%E7%9C%8B.bmp" srcset="/img/loading.gif" alt=""></p><h2 id="1-3-异常分类"><a href="#1-3-异常分类" class="headerlink" title="1.3 异常分类"></a>1.3 异常分类</h2><p>我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。</p><p><strong>异常(Exception)的分类</strong>:根据在编译时期还是运行时期去检查异常?</p><ul><li><strong>编译时期异常</strong>:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)</li><li><strong>运行时期异常</strong>:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)</li></ul><p>​    <img src="img%5C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB.png" srcset="/img/loading.gif" alt=""></p><h2 id="1-4-异常的产生过程解析"><a href="#1-4-异常的产生过程解析" class="headerlink" title="1.4     异常的产生过程解析"></a>1.4     异常的产生过程解析</h2><p>先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。</p><p> 工具类</p><pre><code class="java">public class ArrayTools {    // 对给定的数组通过给定的角标获取元素。    public static int getElement(int[] arr, int index) {        int element = arr[index];        return element;    }}</code></pre><p> 测试类</p><pre><code class="java">public class ExceptionDemo {    public static void main(String[] args) {        int[] arr = { 34, 12, 67 };        intnum = ArrayTools.getElement(arr, 4)        System.out.println(&quot;num=&quot; + num);        System.out.println(&quot;over&quot;);    }}</code></pre><p>上述程序执行过程图解：</p><p> <img src="img%5C%E5%BC%82%E5%B8%B8%E4%BA%A7%E7%94%9F%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" alt=""></p><h1 id="第二章-异常的处理"><a href="#第二章-异常的处理" class="headerlink" title="第二章 异常的处理"></a>第二章 异常的处理</h1><p>Java异常处理的五个关键字：<strong>try、catch、finally、throw、throws</strong></p><h2 id="2-1-抛出异常throw"><a href="#2-1-抛出异常throw" class="headerlink" title="2.1     抛出异常throw"></a>2.1     抛出异常throw</h2><p>在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。</p><p>在java中，提供了一个<strong>throw</strong>关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？</p><ol><li><p>创建一个异常对象。封装一些提示信息(信息可以自己编写)。</p></li><li><p>需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。</p><p>throw<strong>用在方法内</strong>，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</p></li></ol><p><strong>使用格式：</strong></p><pre><code>throw new 异常类名(参数);</code></pre><p> 例如：</p><pre><code class="java">throw new NullPointerException(&quot;要访问的arr数组不存在&quot;);throw new ArrayIndexOutOfBoundsException(&quot;该索引在数组中不存在，已超出范围&quot;);</code></pre><p>学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。</p><pre><code class="java">public class ThrowDemo {    public static void main(String[] args) {        //创建一个数组         int[] arr = {2,4,52,2};        //根据索引找对应的元素         int index = 4;        int element = getElement(arr, index);        System.out.println(element);        System.out.println(&quot;over&quot;);    }    /*     * 根据 索引找到数组中对应的元素     */    public static int getElement(int[] arr,int index){            //判断  索引是否越界        if(index&lt;0 || index&gt;arr.length-1){             /*             判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。             这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。               */             throw new ArrayIndexOutOfBoundsException(&quot;哥们，角标越界了~~~&quot;);        }        int element = arr[index];        return element;    }}</code></pre><blockquote><p>注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。</p><p>那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。</p></blockquote><h2 id="2-2-Objects非空判断"><a href="#2-2-Objects非空判断" class="headerlink" title="2.2 Objects非空判断"></a>2.2 Objects非空判断</h2><p>还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。</p><ul><li><code>public static &lt;T&gt; T requireNonNull(T obj)</code>:查看指定引用对象不是null。</li></ul><p>查看源码发现这里对为null的进行了抛出异常操作：</p><pre><code class="java">public static &lt;T&gt; T requireNonNull(T obj) {    if (obj == null)          throw new NullPointerException();    return obj;}</code></pre><h2 id="2-3-声明异常throws"><a href="#2-3-声明异常throws" class="headerlink" title="2.3  声明异常throws"></a>2.3  声明异常throws</h2><p><strong>声明异常</strong>：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。</p><p>关键字<strong>throws</strong>运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).</p><p><strong>声明异常格式：</strong></p><pre><code>修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…{   }    </code></pre><p>声明异常的代码演示：</p><pre><code class="java">public class ThrowsDemo {    public static void main(String[] args) throws FileNotFoundException {        read(&quot;a.txt&quot;);    }    // 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明    public static void read(String path) throws FileNotFoundException {        if (!path.equals(&quot;a.txt&quot;)) {//如果不是 a.txt这个文件             // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw            throw new FileNotFoundException(&quot;文件不存在&quot;);        }    }}</code></pre><p>throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。</p><pre><code class="java">public class ThrowsDemo2 {    public static void main(String[] args) throws IOException {        read(&quot;a.txt&quot;);    }    public static void read(String path)throws FileNotFoundException, IOException {        if (!path.equals(&quot;a.txt&quot;)) {//如果不是 a.txt这个文件             // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw            throw new FileNotFoundException(&quot;文件不存在&quot;);        }        if (!path.equals(&quot;b.txt&quot;)) {            throw new IOException();        }    }}</code></pre><h2 id="2-4-捕获异常try…catch"><a href="#2-4-捕获异常try…catch" class="headerlink" title="2.4  捕获异常try…catch"></a>2.4  捕获异常try…catch</h2><p>如果异常出现的话,会立刻终止程序,所以我们得处理异常:</p><ol><li>该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。</li><li>在方法中使用try-catch的语句块来处理异常。</li></ol><p><strong>try-catch</strong>的方式就是捕获异常。</p><ul><li><strong>捕获异常</strong>：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。</li></ul><p>捕获异常语法如下：</p><pre><code class="java">try{     编写可能会出现异常的代码}catch(异常类型  e){     处理异常的代码     //记录日志/打印异常信息/继续抛出异常}</code></pre><p><strong>try：</strong>该代码块中编写可能产生异常的代码。</p><p><strong>catch：</strong>用来进行某种异常的捕获，实现对捕获到的异常进行处理。</p><blockquote><p>注意:try和catch都不能单独使用,必须连用。</p></blockquote><p>演示如下：</p><pre><code class="java">public class TryCatchDemo {    public static void main(String[] args) {        try {// 当产生异常时，必须有处理方式。要么捕获，要么声明。            read(&quot;b.txt&quot;);        } catch (FileNotFoundException e) {// 括号中需要定义什么呢？              //try中抛出的是什么异常，在括号中就定义什么异常类型            System.out.println(e);        }        System.out.println(&quot;over&quot;);    }    /*     *     * 我们 当前的这个方法中 有异常  有编译期异常     */    public static void read(String path) throws FileNotFoundException {        if (!path.equals(&quot;a.txt&quot;)) {//如果不是 a.txt这个文件             // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw            throw new FileNotFoundException(&quot;文件不存在&quot;);        }    }}</code></pre><p>如何获取异常信息：</p><p>Throwable类中定义了一些查看方法:</p><ul><li><code>public String getMessage()</code>:获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。</li></ul><ul><li><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</li><li><code>public void printStackTrace()</code>:打印异常的跟踪栈信息并输出到控制台。</li></ul><p>​            <em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p><h2 id="2-4-finally-代码块"><a href="#2-4-finally-代码块" class="headerlink" title="2.4 finally 代码块"></a>2.4 finally 代码块</h2><p><strong>finally</strong>：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。</p><p>什么时候的代码必须最终执行？</p><p>当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。</p><p>finally的语法:</p><p> try…catch….finally:自身需要处理异常,最终还得关闭资源。</p><blockquote><p>注意:finally不能单独使用。</p></blockquote><p>比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。</p><p>finally代码参考如下：</p><pre><code class="java">public class TryCatchDemo4 {    public static void main(String[] args) {        try {            read(&quot;a.txt&quot;);        } catch (FileNotFoundException e) {            //抓取到的是编译期异常  抛出去的是运行期             throw new RuntimeException(e);        } finally {            System.out.println(&quot;不管程序怎样，这里都将会被执行。&quot;);        }        System.out.println(&quot;over&quot;);    }    /*     *     * 我们 当前的这个方法中 有异常  有编译期异常     */    public static void read(String path) throws FileNotFoundException {        if (!path.equals(&quot;a.txt&quot;)) {//如果不是 a.txt这个文件             // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw            throw new FileNotFoundException(&quot;文件不存在&quot;);        }    }}</code></pre><blockquote><p>当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。</p></blockquote><p><img src="img%5C%E6%AD%BB%E4%BA%86%E9%83%BD%E8%A6%81try.bmp" srcset="/img/loading.gif" alt=""></p><h2 id="2-5-异常注意事项"><a href="#2-5-异常注意事项" class="headerlink" title="2.5   异常注意事项"></a>2.5   异常注意事项</h2><ul><li><p>多个异常使用捕获又该如何处理呢？</p><ol><li>多个异常分别处理。</li><li>多个异常一次捕获，多次处理。</li><li>多个异常一次捕获一次处理。</li></ol><p>一般我们是使用一次捕获多次处理方式，格式如下：</p><pre><code class="java">try{     编写可能会出现异常的代码}catch(异常类型A  e){  当try中出现A类型异常,就用该catch来捕获.     处理异常的代码     //记录日志/打印异常信息/继续抛出异常}catch(异常类型B  e){  当try中出现B类型异常,就用该catch来捕获.     处理异常的代码     //记录日志/打印异常信息/继续抛出异常}</code></pre><blockquote><p>注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。</p></blockquote></li><li><p>运行时异常被抛出可以不处理。即不捕获也不声明抛出。</p></li><li><p>如果finally有return语句,永远返回finally中的结果,避免该情况. </p></li><li><p>如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。</p></li><li><p>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出</p></li></ul><h1 id="第三章-自定义异常"><a href="#第三章-自定义异常" class="headerlink" title="第三章 自定义异常"></a>第三章 自定义异常</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p><strong>为什么需要自定义异常类:</strong></p><p>我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题,考试成绩负数问题等等。</p><p>在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？</p><p><strong>什么是自定义异常类:</strong></p><p>在开发中根据自己业务的异常情况来定义异常类.</p><p>自定义一个业务逻辑异常: <strong>RegisterException</strong>。一个注册异常类。</p><p><strong>异常类如何定义:</strong></p><ol><li>自定义一个编译期异常: 自定义类 并继承于<code>java.lang.Exception</code>。</li><li>自定义一个运行时期的异常类:自定义类 并继承于<code>java.lang.RuntimeException</code>。</li></ol><h2 id="3-2-自定义异常的练习"><a href="#3-2-自定义异常的练习" class="headerlink" title="3.2 自定义异常的练习"></a>3.2 自定义异常的练习</h2><p>要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。</p><p>首先定义一个登陆异常类RegisterException：</p><pre><code class="java">// 业务逻辑异常public class RegisterException extends Exception {    /**     * 空参构造     */    public RegisterException() {    }    /**     *     * @param message 表示异常提示     */    public RegisterException(String message) {        super(message);    }}</code></pre><p>模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。</p><pre><code class="java">public class Demo {    // 模拟数据库中已存在账号    private static String[] names = {&quot;bill&quot;,&quot;hill&quot;,&quot;jill&quot;};    public static void main(String[] args) {             //调用方法        try{              // 可能出现异常的代码            checkUsername(&quot;nill&quot;);            System.out.println(&quot;注册成功&quot;);//如果没有异常就是注册成功        }catch(RegisterException e){            //处理异常            e.printStackTrace();        }    }    //判断当前注册账号是否存在    //因为是编译期异常，又想调用者去处理 所以声明该异常    public static boolean checkUsername(String uname) throws LoginException{        for (String name : names) {            if(name.equals(uname)){//如果名字在这里面 就抛出登陆异常                throw new RegisterException(&quot;亲&quot;+name+&quot;已经被注册了！&quot;);            }        }        return true;    }}</code></pre><h1 id="第四章-多线程"><a href="#第四章-多线程" class="headerlink" title="第四章 多线程"></a>第四章 多线程</h1><p>我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？</p><p>要解决上述问题,咱们得使用多进程或者多线程来解决.</p><h2 id="4-1-并发与并行"><a href="#4-1-并发与并行" class="headerlink" title="4.1 并发与并行"></a>4.1 并发与并行</h2><ul><li><strong>并发</strong>：指两个或多个事件在<strong>同一个时间段内</strong>发生。</li><li><strong>并行</strong>：指两个或多个事件在<strong>同一时刻</strong>发生（同时发生）。</li></ul><p><img src="img%5C%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91.bmp" srcset="/img/loading.gif" alt=""></p><p>在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。</p><p>而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。</p><blockquote><p>注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。</p></blockquote><h2 id="4-2-线程与进程"><a href="#4-2-线程与进程" class="headerlink" title="4.2 线程与进程"></a>4.2 线程与进程</h2><ul><li><p><strong>进程</strong>：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p></li><li><p><strong>线程</strong>：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 </p><p>简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 </p></li></ul><p>我们可以再电脑底部任务栏，右键—–&gt;打开任务管理器,可以查看当前任务的进程：</p><p><strong>进程</strong></p><p><img src="img%5C%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5.png" srcset="/img/loading.gif" alt=""></p><p><strong>线程</strong></p><p><img src="img%5C%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5.png" srcset="/img/loading.gif" alt=""></p><p><strong>线程调度:</strong></p><ul><li><p>分时调度</p><p>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p></li><li><p>抢占式调度</p><p>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。</p><ul><li>设置线程的优先级</li></ul><p><img src="img/%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7.bmp" srcset="/img/loading.gif" alt="设置线程优先级"></p><ul><li><p>抢占式调度详解</p><p>大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。</p><p>实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。<br>其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。</p><p><img src="img/%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6.bmp" srcset="/img/loading.gif" alt="抢占式调度"></p></li></ul></li></ul><h2 id="4-3-创建线程类"><a href="#4-3-创建线程类" class="headerlink" title="4.3 创建线程类"></a>4.3 创建线程类</h2><p>Java使用<code>java.lang.Thread</code>类代表<strong>线程</strong>，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p><ol><li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li><li>创建Thread子类的实例，即创建了线程对象</li><li>调用线程对象的start()方法来启动该线程</li></ol><p>代码如下：</p><p>测试类：</p><pre><code class="java">public class Demo01 {    public static void main(String[] args) {        //创建自定义线程对象        MyThread mt = new MyThread(&quot;新的线程！&quot;);        //开启新线程        mt.start();        //在主方法中执行for循环        for (int i = 0; i &lt; 10; i++) {            System.out.println(&quot;main线程！&quot;+i);        }    }}</code></pre><p>自定义线程类：</p><pre><code class="java">public class MyThread extends Thread {    //定义指定线程名称的构造方法    public MyThread(String name) {        //调用父类的String参数的构造方法，指定线程的名称        super(name);    }    /**     * 重写run方法，完成该线程执行的逻辑     */    @Override    public void run() {        for (int i = 0; i &lt; 10; i++) {            System.out.println(getName()+&quot;：正在执行！&quot;+i);        }    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>lamda</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>day04 【Map】</title>
    <link href="/2017/04/15/day04%20%E3%80%90Map%E3%80%91/"/>
    <url>/2017/04/15/day04%20%E3%80%90Map%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="day04-【Map】"><a href="#day04-【Map】" class="headerlink" title="day04 【Map】"></a>day04 【Map】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul><li>Map集合</li></ul><h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul><li><input disabled="" type="checkbox"> 能够说出Map集合特点</li><li><input disabled="" type="checkbox"> 使用Map集合添加方法保存数据</li><li><input disabled="" type="checkbox"> 使用”键找值”的方式遍历Map集合</li><li><input disabled="" type="checkbox"> 使用”键值对”的方式遍历Map集合</li><li><input disabled="" type="checkbox"> 能够使用HashMap存储自定义键值对的数据</li><li><input disabled="" type="checkbox"> 能够使用HashMap编写斗地主洗牌发牌案例</li></ul><h1 id="第一章-Map集合"><a href="#第一章-Map集合" class="headerlink" title="第一章 Map集合"></a>第一章 Map集合</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即<code>java.util.Map</code>接口。</p><p>我们通过查看<code>Map</code>接口描述，发现<code>Map</code>接口下的集合与<code>Collection</code>接口下的集合，它们存储数据的形式不同，如下图。</p><p><img src="img%5CCollection%E4%B8%8EMap.bmp" srcset="/img/loading.gif" alt=""></p><ul><li><code>Collection</code>中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。</li><li><code>Map</code>中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</li><li><code>Collection</code>中的集合称为单列集合，<code>Map</code>中的集合称为双列集合。</li><li>需要注意的是，<code>Map</code>中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li></ul><h2 id="1-2-Map常用子类"><a href="#1-2-Map常用子类" class="headerlink" title="1.2  Map常用子类"></a>1.2  Map常用子类</h2><p>通过查看Map接口描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。</p><ul><li><strong>HashMap&lt;K,V&gt;</strong>：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li><li><strong>LinkedHashMap&lt;K,V&gt;</strong>：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li></ul><blockquote><p>tips：Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。</p></blockquote><h2 id="1-3-Map接口中的常用方法"><a href="#1-3-Map接口中的常用方法" class="headerlink" title="1.3  Map接口中的常用方法"></a>1.3  Map接口中的常用方法</h2><p>Map接口中定义了很多方法，常用的如下：</p><ul><li><code>public V put(K key, V value)</code>:  把指定的键与指定的值添加到Map集合中。</li><li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li><li><code>public V get(Object key)</code> 根据指定的键，在Map集合中获取对应的值。</li><li><code>boolean containsKey(Object key)</code> 判断集合中是否包含指定的键。</li><li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><p>Map接口的方法演示</p><pre><code class="java">public class MapDemo {    public static void main(String[] args) {        //创建 map对象        HashMap&lt;String, String&gt;  map = new HashMap&lt;String, String&gt;();        //添加元素到集合        map.put(&quot;黄晓明&quot;, &quot;杨颖&quot;);        map.put(&quot;文章&quot;, &quot;马伊琍&quot;);        map.put(&quot;邓超&quot;, &quot;孙俪&quot;);        System.out.println(map);        //String remove(String key)        System.out.println(map.remove(&quot;邓超&quot;));        System.out.println(map);        // 想要查看 黄晓明的媳妇 是谁        System.out.println(map.get(&quot;黄晓明&quot;));        System.out.println(map.get(&quot;邓超&quot;));        }}</code></pre><blockquote><p>tips:</p><p>使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； </p><p>若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 </p></blockquote><h2 id="1-4-Map集合遍历键找值方式"><a href="#1-4-Map集合遍历键找值方式" class="headerlink" title="1.4   Map集合遍历键找值方式"></a>1.4   Map集合遍历键找值方式</h2><p>键找值方式：即通过元素中的键，获取键所对应的值</p><p>分析步骤：</p><ol><li>获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:<code>keyset()</code></li><li>遍历键的Set集合，得到每一个键。</li><li>根据键，获取键所对应的值。方法提示:<code>get(K key)</code></li></ol><p>代码演示：</p><pre><code class="java">public class MapDemo01 {    public static void main(String[] args) {        //创建Map集合对象         HashMap&lt;String, String&gt; map = new HashMap&lt;String,String&gt;();        //添加元素到集合         map.put(&quot;胡歌&quot;, &quot;霍建华&quot;);        map.put(&quot;郭德纲&quot;, &quot;于谦&quot;);        map.put(&quot;薛之谦&quot;, &quot;大张伟&quot;);        //获取所有的键  获取键集        Set&lt;String&gt; keys = map.keySet();        // 遍历键集 得到 每一个键        for (String key : keys) {              //key  就是键            //获取对应值            String value = map.get(key);            System.out.println(key+&quot;的CP是：&quot;+value);        }      }}</code></pre><p>遍历图解：</p><p><img src="img%5CMap%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E4%B8%80.bmp" srcset="/img/loading.gif" alt=""></p><h2 id="1-5-Entry键值对对象"><a href="#1-5-Entry键值对对象" class="headerlink" title="1.5  Entry键值对对象"></a>1.5  Entry键值对对象</h2><p>我们已经知道，<code>Map</code>中存放的是两种对象，一种称为<strong>key</strong>(键)，一种称为<strong>value</strong>(值)，它们在在<code>Map</code>中是一一对应关系，这一对对象又称做<code>Map</code>中的一个<code>Entry(项)</code>。<code>Entry</code>将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历<code>Map</code>集合时，就可以从每一个键值对（<code>Entry</code>）对象中获取对应的键与对应的值。</p><p> 既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法：</p><ul><li><code>public K getKey()</code>：获取Entry对象中的键。</li><li><code>public V getValue()</code>：获取Entry对象中的值。</li></ul><p>在Map集合中也提供了获取所有Entry对象的方法：</p><ul><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><h2 id="1-6-Map集合遍历键值对方式"><a href="#1-6-Map集合遍历键值对方式" class="headerlink" title="1.6 Map集合遍历键值对方式"></a>1.6 Map集合遍历键值对方式</h2><p>键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。</p><p>操作步骤与图解：</p><ol><li><p>获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:<code>entrySet()</code>。</p></li><li><p>遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。</p></li><li><p>通过键值对(Entry)对象，获取Entry对象中的键与值。  方法提示:<code>getkey() getValue()</code>     </p></li></ol><pre><code class="java">public class MapDemo02 {    public static void main(String[] args) {        // 创建Map集合对象         HashMap&lt;String, String&gt; map = new HashMap&lt;String,String&gt;();        // 添加元素到集合         map.put(&quot;胡歌&quot;, &quot;霍建华&quot;);        map.put(&quot;郭德纲&quot;, &quot;于谦&quot;);        map.put(&quot;薛之谦&quot;, &quot;大张伟&quot;);        // 获取 所有的 entry对象  entrySet        Set&lt;Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();        // 遍历得到每一个entry对象        for (Entry&lt;String, String&gt; entry : entrySet) {               // 解析             String key = entry.getKey();            String value = entry.getValue();              System.out.println(key+&quot;的CP是:&quot;+value);        }    }}</code></pre><p>遍历图解：</p><p><img src="img%5CMap%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E4%BA%8C.bmp" srcset="/img/loading.gif" alt=""></p><blockquote><p>tips：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。</p></blockquote><h2 id="1-7-HashMap存储自定义类型键值"><a href="#1-7-HashMap存储自定义类型键值" class="headerlink" title="1.7  HashMap存储自定义类型键值"></a>1.7  HashMap存储自定义类型键值</h2><p>练习：每位学生（姓名，年龄）都有自己的家庭住址。那么，既然有对应关系，则将学生对象和家庭住址存储到map集合中。学生作为键, 家庭住址作为值。</p><blockquote><p>注意，学生姓名相同并且年龄相同视为同一名学生。</p></blockquote><p>编写学生类：</p><pre><code class="java">public class Student {    private String name;    private int age;    public Student() {    }    public Student(String name, int age) {        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public boolean equals(Object o) {        if (this == o)            return true;        if (o == null || getClass() != o.getClass())            return false;        Student student = (Student) o;        return age == student.age &amp;&amp; Objects.equals(name, student.name);    }    @Override    public int hashCode() {        return Objects.hash(name, age);    }}</code></pre><p>编写测试类：</p><pre><code class="java">public class HashMapTest {    public static void main(String[] args) {        //1,创建Hashmap集合对象。        Map&lt;Student,String&gt;map = new HashMap&lt;Student,String&gt;();        //2,添加元素。        map.put(newStudent(&quot;lisi&quot;,28), &quot;上海&quot;);        map.put(newStudent(&quot;wangwu&quot;,22), &quot;北京&quot;);        map.put(newStudent(&quot;zhaoliu&quot;,24), &quot;成都&quot;);        map.put(newStudent(&quot;zhouqi&quot;,25), &quot;广州&quot;);        map.put(newStudent(&quot;wangwu&quot;,22), &quot;南京&quot;);        //3,取出元素。键找值方式        Set&lt;Student&gt;keySet = map.keySet();        for(Student key: keySet){            Stringvalue = map.get(key);            System.out.println(key.toString()+&quot;.....&quot;+value);        }    }}</code></pre><ul><li>当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。</li><li>如果要保证map中存放的key和取出的顺序一致，可以使用<code>java.util.LinkedHashMap</code>集合来存放。</li></ul><h2 id="1-8-LinkedHashMap"><a href="#1-8-LinkedHashMap" class="headerlink" title="1.8   LinkedHashMap"></a>1.8   LinkedHashMap</h2><p>我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？</p><p>在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。</p><pre><code class="java">public class LinkedHashMapDemo {    public static void main(String[] args) {        LinkedHashMap&lt;String, String&gt; map = new LinkedHashMap&lt;String, String&gt;();        map.put(&quot;邓超&quot;, &quot;孙俪&quot;);        map.put(&quot;李晨&quot;, &quot;范冰冰&quot;);        map.put(&quot;刘德华&quot;, &quot;朱丽倩&quot;);        Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();        for (Entry&lt;String, String&gt; entry : entrySet) {            System.out.println(entry.getKey() + &quot;  &quot; + entry.getValue());        }    }}</code></pre><p>结果:</p><pre><code>邓超  孙俪李晨  范冰冰刘德华  朱丽倩</code></pre><h2 id="1-9-Map集合练习"><a href="#1-9-Map集合练习" class="headerlink" title="1.9 Map集合练习"></a>1.9 Map集合练习</h2><p><strong>需求：</strong></p><p>计算一个字符串中每个字符出现次数。</p><p><strong>分析：</strong></p><ol><li>获取一个字符串对象</li><li>创建一个Map集合，键代表字符，值代表次数。</li><li>遍历字符串得到每个字符。</li><li>判断Map中是否有该键。</li><li>如果没有，第一次出现，存储次数为1；如果有，则说明已经出现过，获取到对应的值进行++，再次存储。     </li><li>打印最终结果</li></ol><p><strong>代码：</strong></p><pre><code class="java">public class MapTest {public static void main(String[] args) {        //友情提示        System.out.println(&quot;请录入一个字符串:&quot;);        String line = new Scanner(System.in).nextLine();        // 定义 每个字符出现次数的方法        findChar(line);    }    private static void findChar(String line) {        //1:创建一个集合 存储  字符 以及其出现的次数        HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();        //2:遍历字符串        for (int i = 0; i &lt; line.length(); i++) {            char c = line.charAt(i);            //判断 该字符 是否在键集中            if (!map.containsKey(c)) {//说明这个字符没有出现过                //那就是第一次                map.put(c, 1);            } else {                //先获取之前的次数                Integer count = map.get(c);                //count++;                //再次存入  更新                map.put(c, ++count);            }        }        System.out.println(map);    }}</code></pre><h1 id="第二章-补充知识点"><a href="#第二章-补充知识点" class="headerlink" title="第二章 补充知识点"></a>第二章 补充知识点</h1><h2 id="2-1-JDK9对集合添加的优化"><a href="#2-1-JDK9对集合添加的优化" class="headerlink" title="2.1  JDK9对集合添加的优化"></a>2.1  JDK9对集合添加的优化</h2><p>通常，我们在代码中创建一个集合（例如，List 或 Set ），并直接用一些元素填充它。 实例化集合，几个 add方法 调用，使得代码重复。</p><pre><code class="java">public class Demo01 {    public static void main(String[] args) {        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;abc&quot;);        list.add(&quot;def&quot;);        list.add(&quot;ghi&quot;);        System.out.println(list);    }}</code></pre><p> Java 9，添加了几种集合工厂方法,更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可以更方便地创建集合的不可变实例。</p><p>例子：</p><pre><code class="java">public class HelloJDK9 {      public static void main(String[] args) {          Set&lt;String&gt; str1=Set.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);          //str1.add(&quot;c&quot;);这里编译的时候不会错，但是执行的时候会报错，因为是不可变的集合          System.out.println(str1);          Map&lt;String,Integer&gt; str2=Map.of(&quot;a&quot;,1,&quot;b&quot;,2);          System.out.println(str2);          List&lt;String&gt; str3=List.of(&quot;a&quot;,&quot;b&quot;);          System.out.println(str3);      }  } </code></pre><p>需要注意以下两点：</p><blockquote><p>1:of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如    HashSet，ArrayList等待；</p><p>2:返回的集合是不可变的；</p></blockquote><h2 id="2-2-Debug追踪"><a href="#2-2-Debug追踪" class="headerlink" title="2.2 Debug追踪"></a>2.2 Debug追踪</h2><p><strong>使用IDEA的断点调试功能，查看程序的运行过程</strong></p><ol><li><p>在有效代码行，点击行号右边的空白区域，设置断点，程序执行到断点将停止，我们可以手动来运行程序     </p><p>   <img src="img/debug1.png" srcset="/img/loading.gif" alt=""></p></li><li><p>点击Debug运行模式       <img src="img%5Cdebug2.png" srcset="/img/loading.gif" alt="">                                                                                                                                                                      </p></li><li><p>程序停止在断点上不再执行，而IDEA最下方打开了Debug调试窗口  </p><p> <img src="img%5Cdebug3.png" srcset="/img/loading.gif" alt="">)<img src="img%5Cdebug4.png" srcset="/img/loading.gif" alt=""></p></li><li><p>Debug调试窗口介绍</p><p> <img src="img%5Cdebug5.png" srcset="/img/loading.gif" alt=""></p></li><li><p>快捷键F8，代码向下执行一行,第九行执行完毕，执行到第10行（第10行还未执行）</p><p><img src="img%5Cdebug6.png" srcset="/img/loading.gif" alt=""></p></li><li><p>切换到控制台面板，控制台显示 请录入一个字符串： 并且等待键盘录入</p><p><img src="img%5Cdebug7.png" srcset="/img/loading.gif" alt=""></p></li><li><p>快捷键F8，程序继续向后执行，执行键盘录入操作，在控制台录入数据 ababcea</p><p><img src="img%5Cdebug8.png" srcset="/img/loading.gif" alt=""></p><p>回车之后效果：<img src="img%5Cdebug9.png" srcset="/img/loading.gif" alt=""></p><p>调试界面效果：<img src="img%5Cdebug0.png" srcset="/img/loading.gif" alt=""></p></li><li><p>此时到达findChar方法，快捷键F7，进入方法findChar</p><p><img src="img%5Cdebug11.png" srcset="/img/loading.gif" alt=""></p></li><li><p>快捷键F8 接续执行，创建了map对象，变量区域显示</p><p><img src="img%5Cdebug12.png" srcset="/img/loading.gif" alt=""></p></li><li><p>快捷键F8 接续执行，进入到循环中，循环变量i为 0,F8再继续执行，就获取到变量c赋值为字符‘a’ 字节值97</p><p><img src="img%5Cdebug13.png" srcset="/img/loading.gif" alt=""></p></li><li><p>快捷键F8 接续执行，进入到判断语句中，因为该字符 不在Map集合键集中，再按F8执行，进入该判断中</p><p><img src="img%5Cdebug14.png" srcset="/img/loading.gif" alt=""></p></li><li><p>快捷键F8 接续执行，循环结束，进入下次循环，此时map中已经添加一对儿元素</p><p><img src="img%5Cdebug15.png" srcset="/img/loading.gif" alt=""></p></li><li><p>快捷键F8 接续执行，进入下次循环，再继续上面的操作，我们就可以看到代码每次是如何执行的了</p><p><img src="img%5Cdebug16.png" srcset="/img/loading.gif" alt=""></p></li><li><p>如果不想继续debug,那么可以使用快捷键F9,程序正常执行到结束，程序结果在控制台显示</p><p><img src="img%5Cdebug17.png" srcset="/img/loading.gif" alt=""></p></li></ol><h1 id="第三章-模拟斗地主洗牌发牌"><a href="#第三章-模拟斗地主洗牌发牌" class="headerlink" title="第三章  模拟斗地主洗牌发牌"></a>第三章  模拟斗地主洗牌发牌</h1><h2 id="3-1-案例介绍"><a href="#3-1-案例介绍" class="headerlink" title="3.1 案例介绍"></a>3.1 案例介绍</h2><p>按照斗地主的规则，完成洗牌发牌的动作。</p><p><img src="img%5C%E6%96%97%E5%9C%B0%E4%B8%BB.png" srcset="/img/loading.gif" alt=""></p><p>具体规则：</p><ol><li>组装54张扑克牌将</li><li>54张牌顺序打乱</li><li>三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</li><li>查看三人各自手中的牌（按照牌的大小排序）、底牌</li></ol><blockquote><p>规则：手中扑克牌从大到小的摆放顺序：大王,小王,2,A,K,Q,J,10,9,8,7,6,5,4,3</p></blockquote><h2 id="3-2-案例需求分析"><a href="#3-2-案例需求分析" class="headerlink" title="3.2 案例需求分析"></a>3.2 案例需求分析</h2><ol><li>准备牌：</li></ol><p>完成数字与纸牌的映射关系：</p><p>使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。</p><ol start="2"><li>洗牌：</li></ol><p>通过数字完成洗牌发牌</p><ol start="3"><li>发牌：</li></ol><p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</p><p>存放的过程中要求数字大小与斗地主规则的大小对应。</p><p>将代表不同纸牌的数字分配给不同的玩家与底牌。</p><ol start="4"><li>看牌：</li></ol><p>通过Map集合找到对应字符展示。</p><p>通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。</p><p><img src="img%5C%E6%96%97%E5%9C%B0%E4%B8%BB%E5%88%86%E6%9E%90.png" srcset="/img/loading.gif" alt=""></p><h2 id="3-3-实现代码步骤"><a href="#3-3-实现代码步骤" class="headerlink" title="3.3  实现代码步骤"></a>3.3  实现代码步骤</h2><pre><code class="java">public class Poker {    public static void main(String[] args) {        /*         * 1组装54张扑克牌         */        // 1.1 创建Map集合存储        HashMap&lt;Integer, String&gt; pokerMap = new HashMap&lt;Integer, String&gt;();        // 1.2 创建 花色集合 与 数字集合        ArrayList&lt;String&gt; colors = new ArrayList&lt;String&gt;();        ArrayList&lt;String&gt; numbers = new ArrayList&lt;String&gt;();        // 1.3 存储 花色 与数字        Collections.addAll(colors, &quot;♦&quot;, &quot;♣&quot;, &quot;♥&quot;, &quot;♠&quot;);        Collections.addAll(numbers, &quot;2&quot;, &quot;A&quot;, &quot;K&quot;, &quot;Q&quot;, &quot;J&quot;, &quot;10&quot;, &quot;9&quot;, &quot;8&quot;, &quot;7&quot;, &quot;6&quot;, &quot;5&quot;, &quot;4&quot;, &quot;3&quot;);        // 设置 存储编号变量        int count = 1;        pokerMap.put(count++, &quot;大王&quot;);        pokerMap.put(count++, &quot;小王&quot;);        // 1.4 创建牌 存储到map集合中        for (String number : numbers) {            for (String color : colors) {                String card = color + number;                pokerMap.put(count++, card);            }        }        /*         * 2 将54张牌顺序打乱         */        // 取出编号 集合        Set&lt;Integer&gt; numberSet = pokerMap.keySet();        // 因为要将编号打乱顺序 所以 应该先进行转换到 list集合中        ArrayList&lt;Integer&gt; numberList = new ArrayList&lt;Integer&gt;();        numberList.addAll(numberSet);        // 打乱顺序        Collections.shuffle(numberList);        // 3 完成三个玩家交替摸牌，每人17张牌，最后三张留作底牌        // 3.1 发牌的编号        // 创建三个玩家编号集合 和一个 底牌编号集合        ArrayList&lt;Integer&gt; noP1 = new ArrayList&lt;Integer&gt;();        ArrayList&lt;Integer&gt; noP2 = new ArrayList&lt;Integer&gt;();        ArrayList&lt;Integer&gt; noP3 = new ArrayList&lt;Integer&gt;();        ArrayList&lt;Integer&gt; dipaiNo = new ArrayList&lt;Integer&gt;();        // 3.2发牌的编号        for (int i = 0; i &lt; numberList.size(); i++) {            // 获取该编号            Integer no = numberList.get(i);            // 发牌            // 留出底牌            if (i &gt;= 51) {                dipaiNo.add(no);            } else {                if (i % 3 == 0) {                    noP1.add(no);                } else if (i % 3 == 1) {                    noP2.add(no);                } else {                    noP3.add(no);                }            }        }        // 4 查看三人各自手中的牌（按照牌的大小排序）、底牌        // 4.1 对手中编号进行排序        Collections.sort(noP1);        Collections.sort(noP2);        Collections.sort(noP3);        Collections.sort(dipaiNo);        // 4.2 进行牌面的转换        // 创建三个玩家牌面集合 以及底牌牌面集合        ArrayList&lt;String&gt; player1 = new ArrayList&lt;String&gt;();        ArrayList&lt;String&gt; player2 = new ArrayList&lt;String&gt;();        ArrayList&lt;String&gt; player3 = new ArrayList&lt;String&gt;();        ArrayList&lt;String&gt; dipai = new ArrayList&lt;String&gt;();        // 4.3转换        for (Integer i : noP1) {            // 4.4 根据编号找到 牌面 pokerMap            String card = pokerMap.get(i);            // 添加到对应的 牌面集合中            player1.add(card);        }        for (Integer i : noP2) {            String card = pokerMap.get(i);            player2.add(card);        }        for (Integer i : noP3) {            String card = pokerMap.get(i);            player3.add(card);        }        for (Integer i : dipaiNo) {            String card = pokerMap.get(i);            dipai.add(card);        }        //4.5 查看        System.out.println(&quot;令狐冲：&quot;+player1);        System.out.println(&quot;石破天：&quot;+player2);        System.out.println(&quot;鸠摩智：&quot;+player3);        System.out.println(&quot;底牌：&quot;+dipai);    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>lamda</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>day03【List、Set】</title>
    <link href="/2017/04/05/day03%E3%80%90List%E3%80%81Set%E3%80%91/"/>
    <url>/2017/04/05/day03%E3%80%90List%E3%80%81Set%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="day03-【List、Set、数据结构、Collections】"><a href="#day03-【List、Set、数据结构、Collections】" class="headerlink" title="day03 【List、Set、数据结构、Collections】"></a>day03 【List、Set、数据结构、Collections】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul><li>数据结构</li><li>List集合</li><li>Set集合</li><li>Collections</li></ul><h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul><li><input disabled="" type="checkbox"> 能够说出List集合特点</li><li><input disabled="" type="checkbox"> 能够说出常见的数据结构</li><li><input disabled="" type="checkbox"> 能够说出数组结构特点</li><li><input disabled="" type="checkbox"> 能够说出栈结构特点</li><li><input disabled="" type="checkbox"> 能够说出队列结构特点</li><li><input disabled="" type="checkbox"> 能够说出单向链表结构特点</li><li><input disabled="" type="checkbox"> 能够说出Set集合的特点</li><li><input disabled="" type="checkbox"> 能够说出哈希表的特点</li><li><input disabled="" type="checkbox"> 使用HashSet集合存储自定义元素</li><li><input disabled="" type="checkbox"> 能够说出可变参数的格式</li><li><input disabled="" type="checkbox"> 能够使用集合工具类</li><li><input disabled="" type="checkbox"> 能够使用Comparator比较器进行排序</li></ul><h1 id="第一章-数据结构"><a href="#第一章-数据结构" class="headerlink" title="第一章 数据结构"></a>第一章 数据结构</h1><h2 id="2-1-数据结构有什么用？"><a href="#2-1-数据结构有什么用？" class="headerlink" title="2.1 数据结构有什么用？"></a>2.1 数据结构有什么用？</h2><p>当你用着java里面的容器类很爽的时候，你有没有想过，怎么ArrayList就像一个无限扩充的数组，也好像链表之类的。好用吗？好用，这就是数据结构的用处，只不过你在不知不觉中使用了。</p><p>现实世界的存储，我们使用的工具和建模。每种数据结构有自己的优点和缺点，想想如果Google的数据用的是数组的存储，我们还能方便地查询到所需要的数据吗？而算法，在这么多的数据中如何做到最快的插入，查找，删除，也是在追求更快。</p><p>我们java是面向对象的语言，就好似自动档轿车，C语言好似手动档吉普。数据结构呢？是变速箱的工作原理。你完全可以不知道变速箱怎样工作，就把自动档的车子从 A点 开到 B点，而且未必就比懂得的人慢。写程序这件事，和开车一样，经验可以起到很大作用，但如果你不知道底层是怎么工作的，就永远只能开车，既不会修车，也不能造车。当然了，数据结构内容比较多，细细的学起来也是相对费功夫的，不可能达到一蹴而就。我们将常见的数据结构：堆栈、队列、数组、链表和红黑树 这几种给大家介绍一下，作为数据结构的入门，了解一下它们的特点即可。</p><p><img src="img%5C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%AF%94%E5%96%BB.png" srcset="/img/loading.gif" alt=""></p><h2 id="2-2-常见的数据结构"><a href="#2-2-常见的数据结构" class="headerlink" title="2.2 常见的数据结构"></a>2.2 常见的数据结构</h2><p>数据存储的常用结构有：栈、队列、数组、链表和红黑树。我们分别来了解一下：</p><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul><li><strong>栈</strong>：<strong>stack</strong>,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。</li></ul><p>简单的说：采用该结构的集合，对元素的存取有如下的特点</p><ul><li><p>先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。</p></li><li><p>栈的入口、出口的都是栈的顶端位置。</p><p><img src="img%5C%E5%A0%86%E6%A0%88.png" srcset="/img/loading.gif" alt=""></p></li></ul><p>这里两个名词需要注意：</p><ul><li><strong>压栈</strong>：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。</li><li><strong>弹栈</strong>：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。</li></ul><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul><li><strong>队列</strong>：<strong>queue</strong>,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。</li></ul><p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p><ul><li>先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。</li><li>队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。</li></ul><p><img src="img%5C%E9%98%9F%E5%88%97%E5%9B%BE.bmp" srcset="/img/loading.gif" alt=""></p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul><li><strong>数组</strong>:<strong>Array</strong>,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。</li></ul><p>简单的说,采用该结构的集合，对元素的存取有如下的特点：</p><ul><li><p>查找元素快：通过索引，可以快速访问指定位置的元素</p><p><img src="img/%E6%95%B0%E7%BB%84%E6%9F%A5%E8%AF%A2%E5%BF%AB.png" srcset="/img/loading.gif" alt=""></p></li><li><p>增删元素慢</p><ul><li><strong>指定索引位置增加元素</strong>：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。如下图<img src="img/%E6%95%B0%E7%BB%84%E6%B7%BB%E5%8A%A0.png" srcset="/img/loading.gif" alt=""></li><li><strong>指定索引位置删除元素：</strong>需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图<img src="img/%E6%95%B0%E7%BB%84%E5%88%A0%E9%99%A4.png" srcset="/img/loading.gif" alt=""></li></ul></li></ul><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ul><li><p><strong>链表</strong>:<strong>linked list</strong>,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，那么这里给大家介绍的是<strong>单向链表</strong>。</p><p><img src="img%5C%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E7%89%B9%E7%82%B9.png" srcset="/img/loading.gif" alt=""></p></li></ul><p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p><ul><li><p>多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。</p><p><img src="img%5C%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" alt=""></p></li><li><p>查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素</p></li><li><p>增删元素快：</p><ul><li><p>增加元素：只需要修改连接下个元素的地址即可。</p><p><img src="img%5C%E5%A2%9E%E5%8A%A0%E7%BB%93%E7%82%B9.png" srcset="/img/loading.gif" alt=""></p></li><li><p>删除元素：只需要修改连接下个元素的地址即可。</p><p><img src="img%5C%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9.bmp" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><ul><li><strong>二叉树</strong>：<strong>binary tree</strong> ,是每个结点不超过2的有序<strong>树（tree）</strong> 。</li></ul><p>简单的理解，就是一种类似于我们生活中树的结构，只不过每个结点上都最多只能有两个子结点。</p><p>二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。</p><p>如图：</p><p><img src="img%5C%E4%BA%8C%E5%8F%89%E6%A0%91.bmp" srcset="/img/loading.gif" alt=""></p><p>我们要说的是二叉树的一种比较有意思的叫做<strong>红黑树</strong>，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。</p><p>红黑树的约束:</p><ol><li>节点可以是红色的或者黑色的</li></ol><ol start="2"><li>根节点是黑色的</li></ol><ol start="3"><li>叶子节点(特指空节点)是黑色的</li><li>每个红色节点的子节点都是黑色的</li><li>任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同</li></ol><p>红黑树的特点:</p><p>​    速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍</p><h1 id="第二章-List集合"><a href="#第二章-List集合" class="headerlink" title="第二章 List集合"></a>第二章 List集合</h1><p>我们掌握了Collection接口的使用后，再来看看Collection接口中的子类，他们都具备那些特性呢？</p><p>接下来，我们一起学习Collection中的常用几个子类（<code>java.util.List</code>集合、<code>java.util.Set</code>集合）。</p><h2 id="1-1-List接口介绍"><a href="#1-1-List接口介绍" class="headerlink" title="1.1 List接口介绍"></a>1.1 List接口介绍</h2><p><code>java.util.List</code>接口继承自<code>Collection</code>接口，是单列集合的一个重要分支，习惯性地会将实现了<code>List</code>接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。</p><p>看完API，我们总结一下：</p><p>List接口特点：</p><ol><li>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li><li>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li><li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</li></ol><blockquote><p>tips:我们在基础班的时候已经学习过List接口的子类java.util.ArrayList类，该类中的方法都是来自List中定义。</p></blockquote><h2 id="1-2-List接口中常用方法"><a href="#1-2-List接口中常用方法" class="headerlink" title="1.2 List接口中常用方法"></a>1.2 List接口中常用方法</h2><p>List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：</p><ul><li><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</li><li><code>public E get(int index)</code>:返回集合中指定位置的元素。</li><li><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</li><li><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li></ul><p>List集合特有的方法都是跟索引相关，我们在基础班都学习过，那么我们再来复习一遍吧：</p><pre><code class="java">public class ListDemo {    public static void main(String[] args) {        // 创建List集合对象        List&lt;String&gt; list = new ArrayList&lt;String&gt;();        // 往 尾部添加 指定元素        list.add(&quot;图图&quot;);        list.add(&quot;小美&quot;);        list.add(&quot;不高兴&quot;);        System.out.println(list);        // add(int index,String s) 往指定位置添加        list.add(1,&quot;没头脑&quot;);        System.out.println(list);        // String remove(int index) 删除指定位置元素  返回被删除元素        // 删除索引位置为2的元素         System.out.println(&quot;删除索引位置为2的元素&quot;);        System.out.println(list.remove(2));        System.out.println(list);        // String set(int index,String s)        // 在指定位置 进行 元素替代（改）         // 修改指定位置元素        list.set(0, &quot;三毛&quot;);        System.out.println(list);        // String get(int index)  获取指定位置元素        // 跟size() 方法一起用  来 遍历的         for(int i = 0;i&lt;list.size();i++){            System.out.println(list.get(i));        }        //还可以使用增强for        for (String string : list) {            System.out.println(string);        }          }}</code></pre><h1 id="第三章-List的子类"><a href="#第三章-List的子类" class="headerlink" title="第三章 List的子类"></a>第三章 List的子类</h1><h2 id="3-1-ArrayList集合"><a href="#3-1-ArrayList集合" class="headerlink" title="3.1 ArrayList集合"></a>3.1 ArrayList集合</h2><p><code>java.util.ArrayList</code>集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合。</p><p>许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。</p><h2 id="3-2-LinkedList集合"><a href="#3-2-LinkedList集合" class="headerlink" title="3.2 LinkedList集合"></a>3.2 LinkedList集合</h2><p><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p><blockquote><p>LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下</p></blockquote><p><img src="img%5C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" srcset="/img/loading.gif" alt=""></p><p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可：</p><ul><li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li><li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li><li><code>public E getFirst()</code>:返回此列表的第一个元素。</li><li><code>public E getLast()</code>:返回此列表的最后一个元素。</li><li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li><li><code>public E removeLast()</code>:移除并返回此列表的最后一个元素。</li><li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li><li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li><li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li></ul><p>LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。（了解即可）</p><p>方法演示：</p><pre><code class="java">public class LinkedListDemo {    public static void main(String[] args) {        LinkedList&lt;String&gt; link = new LinkedList&lt;String&gt;();        //添加元素        link.addFirst(&quot;abc1&quot;);        link.addFirst(&quot;abc2&quot;);        link.addFirst(&quot;abc3&quot;);        System.out.println(link);        // 获取元素        System.out.println(link.getFirst());        System.out.println(link.getLast());        // 删除元素        System.out.println(link.removeFirst());        System.out.println(link.removeLast());        while (!link.isEmpty()) { //判断集合是否为空            System.out.println(link.pop()); //弹出集合中的栈顶元素        }        System.out.println(link);    }}</code></pre><h1 id="第四章-Set接口"><a href="#第四章-Set接口" class="headerlink" title="第四章 Set接口"></a>第四章 Set接口</h1><p><code>java.util.Set</code>接口和<code>java.util.List</code>接口一样，同样继承自<code>Collection</code>接口，它与<code>Collection</code>接口中的方法基本一致，并没有对<code>Collection</code>接口进行功能上的扩充，只是比<code>Collection</code>接口更加严格了。与<code>List</code>接口不同的是，<code>Set</code>接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。</p><p><code>Set</code>集合有多个子类，这里我们介绍其中的<code>java.util.HashSet</code>、<code>java.util.LinkedHashSet</code>这两个集合。</p><blockquote><p>tips:Set集合取出元素的方式可以采用：迭代器、增强for。</p></blockquote><h2 id="3-1-HashSet集合介绍"><a href="#3-1-HashSet集合介绍" class="headerlink" title="3.1 HashSet集合介绍"></a>3.1 HashSet集合介绍</h2><p><code>java.util.HashSet</code>是<code>Set</code>接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。<code>java.util.HashSet</code>底层的实现其实是一个<code>java.util.HashMap</code>支持，由于我们暂时还未学习，先做了解。</p><p><code>HashSet</code>是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p><p>我们先来使用一下Set集合存储，看下现象，再进行原理的讲解:</p><pre><code class="java">public class HashSetDemo {    public static void main(String[] args) {        //创建 Set集合        HashSet&lt;String&gt;  set = new HashSet&lt;String&gt;();        //添加元素        set.add(new String(&quot;cba&quot;));        set.add(&quot;abc&quot;);        set.add(&quot;bac&quot;);         set.add(&quot;cba&quot;);          //遍历        for (String name : set) {            System.out.println(name);        }    }}</code></pre><p>输出结果如下，说明集合中不能存储重复元素：</p><pre><code>cbaabcbac</code></pre><blockquote><p>tips:根据结果我们发现字符串”cba”只存储了一个，也就是说重复的元素set集合不存储。</p></blockquote><h2 id="2-2-HashSet集合存储数据的结构（哈希表）"><a href="#2-2-HashSet集合存储数据的结构（哈希表）" class="headerlink" title="2.2  HashSet集合存储数据的结构（哈希表）"></a>2.2  HashSet集合存储数据的结构（哈希表）</h2><p>什么是哈希表呢？</p><p>在<strong>JDK1.8</strong>之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p><p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。<img src="img%5C%E5%93%88%E5%B8%8C%E8%A1%A8.png" srcset="/img/loading.gif" alt=""></p><p>看到这张图就有人要问了，这个是怎么存储的呢？</p><p>为了方便大家的理解我们结合一个存储流程图来说明一下：</p><p><img src="img%5C%E5%93%88%E5%B8%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" srcset="/img/loading.gif" alt=""></p><p>总而言之，<strong>JDK1.8</strong>引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。</p><h2 id="2-3-HashSet存储自定义类型元素"><a href="#2-3-HashSet存储自定义类型元素" class="headerlink" title="2.3  HashSet存储自定义类型元素"></a>2.3  HashSet存储自定义类型元素</h2><p>给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一</p><p>创建自定义Student类</p><pre><code class="java">public class Student {    private String name;    private int age;    public Student() {    }    public Student(String name, int age) {        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public boolean equals(Object o) {        if (this == o)            return true;        if (o == null || getClass() != o.getClass())            return false;        Student student = (Student) o;        return age == student.age &amp;&amp;               Objects.equals(name, student.name);    }    @Override    public int hashCode() {        return Objects.hash(name, age);    }}</code></pre><pre><code class="java">public class HashSetDemo2 {    public static void main(String[] args) {        //创建集合对象   该集合中存储 Student类型对象        HashSet&lt;Student&gt; stuSet = new HashSet&lt;Student&gt;();        //存储         Student stu = new Student(&quot;于谦&quot;, 43);        stuSet.add(stu);        stuSet.add(new Student(&quot;郭德纲&quot;, 44));        stuSet.add(new Student(&quot;于谦&quot;, 43));        stuSet.add(new Student(&quot;郭麒麟&quot;, 23));        stuSet.add(stu);        for (Student stu2 : stuSet) {            System.out.println(stu2);        }    }}执行结果：Student [name=郭德纲, age=44]Student [name=于谦, age=43]Student [name=郭麒麟, age=23]</code></pre><h2 id="2-3-LinkedHashSet"><a href="#2-3-LinkedHashSet" class="headerlink" title="2.3 LinkedHashSet"></a>2.3 LinkedHashSet</h2><p>我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？</p><p>在HashSet下面有一个子类<code>java.util.LinkedHashSet</code>，它是链表和哈希表组合的一个数据存储结构。</p><p>演示代码如下:</p><pre><code class="java">public class LinkedHashSetDemo {    public static void main(String[] args) {        Set&lt;String&gt; set = new LinkedHashSet&lt;String&gt;();        set.add(&quot;bbb&quot;);        set.add(&quot;aaa&quot;);        set.add(&quot;abc&quot;);        set.add(&quot;bbc&quot;);        Iterator&lt;String&gt; it = set.iterator();        while (it.hasNext()) {            System.out.println(it.next());        }    }}结果：  bbb  aaa  abc  bbc</code></pre><h2 id="1-9-可变参数"><a href="#1-9-可变参数" class="headerlink" title="1.9  可变参数"></a>1.9  可变参数</h2><p>在<strong>JDK1.5</strong>之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：</p><pre><code>修饰符 返回值类型 方法名(参数类型... 形参名){  }</code></pre><p>其实这个书写完全等价与</p><pre><code>修饰符 返回值类型 方法名(参数类型[] 形参名){  }</code></pre><p>只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。</p><p><strong>JDK1.5</strong>以后。出现了简化操作。<strong>…</strong> 用在参数上，称之为可变参数。</p><p>同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。</p><p>代码演示：    </p><pre><code class="java">public class ChangeArgs {    public static void main(String[] args) {        int[] arr = { 1, 4, 62, 431, 2 };        int sum = getSum(arr);        System.out.println(sum);        //  6  7  2 12 2121        // 求 这几个元素和 6  7  2 12 2121        int sum2 = getSum(6, 7, 2, 12, 2121);        System.out.println(sum2);    }    /*     * 完成数组  所有元素的求和 原始写法      public static int getSum(int[] arr){        int sum = 0;        for(int a : arr){            sum += a;        }        return sum;      }    */    //可变参数写法    public static int getSum(int... arr) {        int sum = 0;        for (int a : arr) {            sum += a;        }        return sum;    }}</code></pre><blockquote><p>tips: 上述add方法在同一个类中，只能存在一个。因为会发生调用的不确定性</p><p>注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。</p></blockquote><h1 id="第五章-Collections"><a href="#第五章-Collections" class="headerlink" title="第五章  Collections"></a>第五章  Collections</h1><h2 id="2-1-常用功能"><a href="#2-1-常用功能" class="headerlink" title="2.1 常用功能"></a>2.1 常用功能</h2><ul><li><code>java.utils.Collections</code>是集合工具类，用来对集合进行操作。部分方法如下：</li></ul><ul><li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)</code>:往集合中添加一些元素。</li><li><code>public static void shuffle(List&lt;?&gt; list) 打乱顺序</code>:打乱集合顺序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</li></ul><p>代码演示：</p><pre><code class="java">public class CollectionsDemo {    public static void main(String[] args) {        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();        //原来写法        //list.add(12);        //list.add(14);        //list.add(15);        //list.add(1000);        //采用工具类 完成 往集合中添加元素          Collections.addAll(list, 5, 222, 1，2);        System.out.println(list);        //排序方法         Collections.sort(list);        System.out.println(list);    }}结果：[5, 222, 1, 2][1, 2, 5, 222]</code></pre><p>代码演示之后 ，发现我们的集合按照顺序进行了排列，可是这样的顺序是采用默认的顺序，如果想要指定顺序那该怎么办呢？</p><p>我们发现还有个方法没有讲，<code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。接下来讲解一下指定规则的排列。</p><h2 id="2-2-Comparator比较器"><a href="#2-2-Comparator比较器" class="headerlink" title="2.2 Comparator比较器"></a>2.2 Comparator比较器</h2><p>我们还是先研究这个方法</p><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</p><p>不过这次存储的是字符串类型。</p><pre><code class="java">public class CollectionsDemo2 {    public static void main(String[] args) {        ArrayList&lt;String&gt;  list = new ArrayList&lt;String&gt;();        list.add(&quot;cba&quot;);        list.add(&quot;aba&quot;);        list.add(&quot;sba&quot;);        list.add(&quot;nba&quot;);        //排序方法        Collections.sort(list);        System.out.println(list);    }}</code></pre><p>结果：</p><pre><code>[aba, cba, nba, sba]</code></pre><p>我们使用的是默认的规则完成字符串的排序，那么默认规则是怎么定义出来的呢？</p><p>说到排序了，简单的说就是两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是比较死板的采用<code>java.lang.Comparable</code>接口去实现，一种是灵活的当我需要做排序的时候在去选择的<code>java.util.Comparator</code>接口完成。</p><p>那么我们采用的<code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>这个方法完成的排序，实际上要求了被排序的类型需要实现Comparable接口完成比较的功能，在String类型上如下：</p><pre><code class="java">public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {</code></pre><p>String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改String的源代码，这是不可能的了，那么这个时候我们可以使用</p><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>方法灵活的完成，这个里面就涉及到了Comparator这个接口，位于位于java.util包下，排序是comparator能实现的功能之一,该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是：</p><ul><li><p><code>public int compare(String o1, String o2)</code>：比较其两个参数的顺序。</p><blockquote><p>两个对象比较的结果有三种：大于，等于，小于。</p><p>如果要按照升序排序，<br>则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）<br>如果要按照降序排序<br>则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数）</p></blockquote></li></ul><p>操作如下:</p><pre><code class="java">public class CollectionsDemo3 {    public static void main(String[] args) {        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();        list.add(&quot;cba&quot;);        list.add(&quot;aba&quot;);        list.add(&quot;sba&quot;);        list.add(&quot;nba&quot;);        //排序方法  按照第一个单词的降序        Collections.sort(list, new Comparator&lt;String&gt;() {            @Override            public int compare(String o1, String o2) {                return o2.charAt(0) - o1.charAt(0);            }        });        System.out.println(list);    }}</code></pre><p>结果如下：</p><pre><code>[sba, nba, cba, aba]</code></pre><h2 id="2-3-简述Comparable和Comparator两个接口的区别。"><a href="#2-3-简述Comparable和Comparator两个接口的区别。" class="headerlink" title="2.3 简述Comparable和Comparator两个接口的区别。"></a>2.3 简述Comparable和Comparator两个接口的区别。</h2><p><strong>Comparable</strong>：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</p><p><strong>Comparator</strong>强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。</p><h2 id="2-4-练习"><a href="#2-4-练习" class="headerlink" title="2.4  练习"></a>2.4  练习</h2><p>创建一个学生类，存储到ArrayList集合中完成指定排序操作。</p><p>Student 初始类</p><pre><code class="java">public class Student{    private String name;    private int age;    public Student() {    }    public Student(String name, int age) {        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public String toString() {        return &quot;Student{&quot; +               &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +               &quot;, age=&quot; + age +               &#39;}&#39;;    }}</code></pre><p>测试类：</p><pre><code class="java">public class Demo {    public static void main(String[] args) {        // 创建四个学生对象 存储到集合中        ArrayList&lt;Student&gt; list = new ArrayList&lt;Student&gt;();        list.add(new Student(&quot;rose&quot;,18));        list.add(new Student(&quot;jack&quot;,16));        list.add(new Student(&quot;abc&quot;,16));        list.add(new Student(&quot;ace&quot;,17));        list.add(new Student(&quot;mark&quot;,16));        /*          让学生 按照年龄排序 升序         *///        Collections.sort(list);//要求 该list中元素类型  必须实现比较器Comparable接口        for (Student student : list) {            System.out.println(student);        }    }}</code></pre><p>发现，当我们调用Collections.sort()方法的时候 程序报错了。</p><p>原因：如果想要集合中的元素完成排序，那么必须要实现比较器Comparable接口。</p><p>于是我们就完成了Student类的一个实现，如下：</p><pre><code class="java">public class Student implements Comparable&lt;Student&gt;{    ....    @Override    public int compareTo(Student o) {        return this.age-o.age;//升序    }}</code></pre><p>再次测试，代码就OK 了效果如下：</p><pre><code class="java">Student{name=&#39;jack&#39;, age=16}Student{name=&#39;abc&#39;, age=16}Student{name=&#39;mark&#39;, age=16}Student{name=&#39;ace&#39;, age=17}Student{name=&#39;rose&#39;, age=18}</code></pre><h2 id="2-5-扩展"><a href="#2-5-扩展" class="headerlink" title="2.5 扩展"></a>2.5 扩展</h2><p>如果在使用的时候，想要独立的定义规则去使用 可以采用Collections.sort(List list,Comparetor<T> c)方式，自己定义规则：</p><pre><code class="java">Collections.sort(list, new Comparator&lt;Student&gt;() {    @Override    public int compare(Student o1, Student o2) {        return o2.getAge()-o1.getAge();//以学生的年龄降序    }});</code></pre><p>效果：</p><pre><code>Student{name=&#39;rose&#39;, age=18}Student{name=&#39;ace&#39;, age=17}Student{name=&#39;jack&#39;, age=16}Student{name=&#39;abc&#39;, age=16}Student{name=&#39;mark&#39;, age=16}</code></pre><p>如果想要规则更多一些，可以参考下面代码：</p><pre><code class="java">Collections.sort(list, new Comparator&lt;Student&gt;() {            @Override            public int compare(Student o1, Student o2) {                // 年龄降序                int result = o2.getAge()-o1.getAge();//年龄降序                if(result==0){//第一个规则判断完了 下一个规则 姓名的首字母 升序                    result = o1.getName().charAt(0)-o2.getName().charAt(0);                }                return result;            }        });</code></pre><p>效果如下：</p><pre><code>Student{name=&#39;rose&#39;, age=18}Student{name=&#39;ace&#39;, age=17}Student{name=&#39;abc&#39;, age=16}Student{name=&#39;jack&#39;, age=16}Student{name=&#39;mark&#39;, age=16}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>lamda</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>day02【Collection、泛型】-笔记</title>
    <link href="/2017/04/03/day02%E3%80%90Collection%E3%80%81%E6%B3%9B%E5%9E%8B%E3%80%91-%E7%AC%94%E8%AE%B0/"/>
    <url>/2017/04/03/day02%E3%80%90Collection%E3%80%81%E6%B3%9B%E5%9E%8B%E3%80%91-%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="day02【Collection、泛型】"><a href="#day02【Collection、泛型】" class="headerlink" title="day02【Collection、泛型】"></a>day02【Collection、泛型】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul><li>Collection集合</li><li>迭代器</li><li>增强for</li><li>泛型</li></ul><h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul><li><input disabled="" type="checkbox"> 能够说出集合与数组的区别</li><li><input disabled="" type="checkbox"> 说出Collection集合的常用功能</li><li><input disabled="" type="checkbox"> 能够使用迭代器对集合进行取元素</li><li><input disabled="" type="checkbox"> 能够说出集合的使用细节</li><li><input disabled="" type="checkbox"> 能够使用集合存储自定义类型</li><li><input disabled="" type="checkbox"> 能够使用foreach循环遍历集合</li><li><input disabled="" type="checkbox"> 能够使用泛型定义集合对象</li><li><input disabled="" type="checkbox"> 能够理解泛型上下限</li><li><input disabled="" type="checkbox"> 能够阐述泛型通配符的作用</li></ul><h1 id="第一章-Collection集合"><a href="#第一章-Collection集合" class="headerlink" title="第一章 Collection集合"></a>第一章 Collection集合</h1><h2 id="1-1-集合概述"><a href="#1-1-集合概述" class="headerlink" title="1.1 集合概述"></a>1.1 集合概述</h2><p>在前面基础班我们已经学习过并使用过集合ArrayList<E> ,那么集合到底是什么呢?</p><ul><li><strong>集合</strong>：集合是java中提供的一种容器，可以用来存储多个数据。</li></ul><p>集合和数组既然都是容器，它们有啥区别呢？</p><ul><li>数组的长度是固定的。集合的长度是可变的。</li><li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li></ul><h2 id="1-2-集合框架"><a href="#1-2-集合框架" class="headerlink" title="1.2  集合框架"></a>1.2  集合框架</h2><p>JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。</p><p>集合按照其存储结构可以分为两大类，分别是单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code>，今天我们主要学习<code>Collection</code>集合，在day04时讲解<code>Map</code>集合。</p><ul><li><strong>Collection</strong>：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。其中，<code>List</code>的特点是元素有序、元素可重复。<code>Set</code>的特点是元素无序，而且不可重复。<code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</li></ul><p>从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。</p><p><img src="img%5CCollection%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E5%9B%BE.png" srcset="/img/loading.gif" alt=""></p><p>其中，橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。这几天将针对图中所列举的集合类进行逐一地讲解。</p><p>集合本身是一个工具，它存放在java.util包中。在<code>Collection</code>接口定义着单列集合框架中最最共性的内容。</p><h2 id="1-3-Collection-常用功能"><a href="#1-3-Collection-常用功能" class="headerlink" title="1.3 Collection 常用功能"></a>1.3 Collection 常用功能</h2><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p><ul><li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code> :清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li><li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li><li><code>public int size()</code>: 返回集合中元素的个数。</li><li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li></ul><p>方法演示：</p><pre><code class="java">import java.util.ArrayList;import java.util.Collection;public class Demo1Collection {    public static void main(String[] args) {        // 创建集合对象         // 使用多态形式        Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();        // 使用方法        // 添加功能  boolean  add(String s)        coll.add(&quot;小李广&quot;);        coll.add(&quot;扫地僧&quot;);        coll.add(&quot;石破天&quot;);        System.out.println(coll);        // boolean contains(E e) 判断o是否在集合中存在        System.out.println(&quot;判断  扫地僧 是否在集合中&quot;+coll.contains(&quot;扫地僧&quot;));        //boolean remove(E e) 删除在集合中的o元素        System.out.println(&quot;删除石破天：&quot;+coll.remove(&quot;石破天&quot;));        System.out.println(&quot;操作之后集合中元素:&quot;+coll);        // size() 集合中有几个元素        System.out.println(&quot;集合中有&quot;+coll.size()+&quot;个元素&quot;);        // Object[] toArray()转换成一个Object数组        Object[] objects = coll.toArray();        // 遍历数组        for (int i = 0; i &lt; objects.length; i++) {            System.out.println(objects[i]);        }        // void  clear() 清空集合        coll.clear();        System.out.println(&quot;集合中内容为：&quot;+coll);        // boolean  isEmpty()  判断是否为空        System.out.println(coll.isEmpty());          }}</code></pre><blockquote><p>tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。</p></blockquote><h2 id="第二章-Iterator迭代器"><a href="#第二章-Iterator迭代器" class="headerlink" title="第二章 Iterator迭代器"></a>第二章 Iterator迭代器</h2><h2 id="2-1-Iterator接口"><a href="#2-1-Iterator接口" class="headerlink" title="2.1 Iterator接口"></a>2.1 Iterator接口</h2><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同，<code>Collection</code>接口与<code>Map</code>接口主要用于存储元素，而<code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p><p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：</p><ul><li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li></ul><p>下面介绍一下迭代的概念：</p><ul><li><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</li></ul><p>Iterator接口的常用方法如下：</p><ul><li><code>public E next()</code>:返回迭代的下一个元素。</li><li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li></ul><p>接下来我们通过案例学习如何使用Iterator迭代集合中元素：</p><pre><code class="java">public class IteratorDemo {      public static void main(String[] args) {        // 使用多态方式 创建对象        Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();        // 添加元素到集合        coll.add(&quot;串串星人&quot;);        coll.add(&quot;吐槽星人&quot;);        coll.add(&quot;汪星人&quot;);        //遍历        //使用迭代器 遍历   每个集合对象都有自己的迭代器        Iterator&lt;String&gt; it = coll.iterator();        //  泛型指的是 迭代出 元素的数据类型        while(it.hasNext()){ //判断是否有迭代元素            String s = it.next();//获取迭代出的元素            System.out.println(s);        }      }}</code></pre><blockquote><p>tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。</p></blockquote><h2 id="2-2-迭代器的实现原理"><a href="#2-2-迭代器的实现原理" class="headerlink" title="2.2 迭代器的实现原理"></a>2.2 迭代器的实现原理</h2><p>我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p><p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程：</p><p><img src="img%5C%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8E%9F%E7%90%86%E5%9B%BE.bmp" srcset="/img/loading.gif" alt=""></p><p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p><h2 id="2-3-增强for"><a href="#2-3-增强for" class="headerlink" title="2.3 增强for"></a>2.3 增强for</h2><p>增强for循环(也称for each循环)是<strong>JDK1.5</strong>以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p><p>格式：</p><pre><code class="java">for(元素的数据类型  变量 : Collection集合or数组){       //写操作代码}</code></pre><p>它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。</p><h4 id="练习1：遍历数组"><a href="#练习1：遍历数组" class="headerlink" title="练习1：遍历数组"></a>练习1：遍历数组</h4><pre><code class="java">public class NBForDemo1 {    public static void main(String[] args) {        int[] arr = {3,5,6,87};           //使用增强for遍历数组        for(int a : arr){//a代表数组中的每个元素            System.out.println(a);        }    }}</code></pre><h4 id="练习2-遍历集合"><a href="#练习2-遍历集合" class="headerlink" title="练习2:遍历集合"></a>练习2:遍历集合</h4><pre><code class="java">public class NBFor {    public static void main(String[] args) {                Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();        coll.add(&quot;小河神&quot;);        coll.add(&quot;老河神&quot;);        coll.add(&quot;神婆&quot;);        //使用增强for遍历        for(String s :coll){//接收变量s代表 代表被遍历到的集合元素            System.out.println(s);        }    }}</code></pre><blockquote><p>tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。</p></blockquote><h1 id="第三章-泛型"><a href="#第三章-泛型" class="headerlink" title="第三章 泛型"></a>第三章 泛型</h1><h2 id="3-1-泛型概述"><a href="#3-1-泛型概述" class="headerlink" title="3.1  泛型概述"></a>3.1  泛型概述</h2><p>在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。</p><p>大家观察下面代码：</p><pre><code class="java">public class GenericDemo {    public static void main(String[] args) {        Collection coll = new ArrayList();        coll.add(&quot;abc&quot;);        coll.add(&quot;itcast&quot;);        coll.add(5);//由于集合没有做任何限定，任何类型都可以给其中存放        Iterator it = coll.iterator();        while(it.hasNext()){            //需要打印每个字符串的长度,就要把迭代出来的对象转成String类型            String str = (String) it.next();            System.out.println(str.length());        }    }}</code></pre><p>程序在运行时发生了问题<strong>java.lang.ClassCastException</strong>。                                                                                             为什么会发生类型转换异常呢？                                                                                                                                       我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。                                                                                                                                                       怎么来解决这个问题呢？                                                                                                                                                           Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了<strong>泛型</strong>(<strong>Generic</strong>)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。</p><ul><li><strong>泛型</strong>：可以在类或方法中预支地使用未知的类型。</li></ul><blockquote><p>tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。</p></blockquote><h2 id="3-2-使用泛型的好处"><a href="#3-2-使用泛型的好处" class="headerlink" title="3.2  使用泛型的好处"></a>3.2  使用泛型的好处</h2><p>上一节只是讲解了泛型的引入，那么泛型带来了哪些好处呢？</p><ul><li>将运行时期的ClassCastException，转移到了编译时期变成了编译失败。</li><li>避免了类型强转的麻烦。</li></ul><p>通过我们如下代码体验一下：</p><pre><code class="java">public class GenericDemo2 {    public static void main(String[] args) {        Collection&lt;String&gt; list = new ArrayList&lt;String&gt;();        list.add(&quot;abc&quot;);        list.add(&quot;itcast&quot;);        // list.add(5);//当集合明确类型后，存放类型不一致就会编译报错        // 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型        Iterator&lt;String&gt; it = list.iterator();        while(it.hasNext()){            String str = it.next();            //当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型            System.out.println(str.length());        }    }}</code></pre><blockquote><p>tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。</p></blockquote><h2 id="3-3-泛型的定义与使用"><a href="#3-3-泛型的定义与使用" class="headerlink" title="3.3  泛型的定义与使用"></a>3.3  泛型的定义与使用</h2><p>我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。</p><p>泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。</p><h3 id="定义和使用含有泛型的类"><a href="#定义和使用含有泛型的类" class="headerlink" title="定义和使用含有泛型的类"></a>定义和使用含有泛型的类</h3><p>定义格式：</p><pre><code>修饰符 class 类名&lt;代表泛型的变量&gt; {  }</code></pre><p>例如，API中的ArrayList集合：</p><pre><code class="java">class ArrayList&lt;E&gt;{     public boolean add(E e){ }    public E get(int index){ }       ....}</code></pre><p>使用泛型： 即什么时候确定泛型。</p><p><strong>在创建对象的时候确定泛型</strong></p><p> 例如，<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p><p>此时，变量E的值就是String类型,那么我们的类型就可以理解为：</p><pre><code class="java">class ArrayList&lt;String&gt;{      public boolean add(String e){ }     public String get(int index){  }     ...}</code></pre><p>再例如，<code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</code></p><p>此时，变量E的值就是Integer类型,那么我们的类型就可以理解为：</p><pre><code class="java">class ArrayList&lt;Integer&gt; {      public boolean add(Integer e) { }     public Integer get(int index) {  }     ...}</code></pre><p>举例自定义泛型类</p><pre><code class="java">public class MyGenericClass&lt;MVP&gt; {    //没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型    private MVP mvp;    public void setMVP(MVP mvp) {        this.mvp = mvp;    }    public MVP getMVP() {        return mvp;    }}</code></pre><p>使用:</p><pre><code class="java">public class GenericClassDemo {      public static void main(String[] args) {                  // 创建一个泛型为String的类         MyGenericClass&lt;String&gt; my = new MyGenericClass&lt;String&gt;();                 // 调用setMVP         my.setMVP(&quot;大胡子登登&quot;);         // 调用getMVP         String mvp = my.getMVP();         System.out.println(mvp);         //创建一个泛型为Integer的类         MyGenericClass&lt;Integer&gt; my2 = new MyGenericClass&lt;Integer&gt;();          my2.setMVP(123);                  Integer mvp2 = my2.getMVP();    }}</code></pre><h3 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h3><p>定义格式：</p><pre><code>修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数){  }</code></pre><p>例如，</p><pre><code class="java">public class MyGenericMethod {          public &lt;MVP&gt; void show(MVP mvp) {        System.out.println(mvp.getClass());    }    public &lt;MVP&gt; MVP show2(MVP mvp) {            return mvp;    }}</code></pre><p>使用格式：<strong>调用方法时，确定泛型的类型</strong></p><pre><code class="java">public class GenericMethodDemo {    public static void main(String[] args) {        // 创建对象        MyGenericMethod mm = new MyGenericMethod();        // 演示看方法提示        mm.show(&quot;aaa&quot;);        mm.show(123);        mm.show(12.45);    }}</code></pre><h3 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h3><p>定义格式：</p><pre><code>修饰符 interface接口名&lt;代表泛型的变量&gt; {  }</code></pre><p>例如，</p><pre><code class="java">public interface MyGenericInterface&lt;E&gt;{    public abstract void add(E e);    public abstract E getE();  }</code></pre><p>使用格式：</p><p><strong>1、定义类时确定泛型的类型</strong></p><p>例如</p><pre><code class="java">public class MyImp1 implements MyGenericInterface&lt;String&gt; {    @Override    public void add(String e) {        // 省略...    }    @Override    public String getE() {        return null;    }}</code></pre><p>此时，泛型E的值就是String类型。</p><p> <strong>2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></p><p> 例如</p><pre><code class="java">public class MyImp2&lt;E&gt; implements MyGenericInterface&lt;E&gt; {    @Override    public void add(E e) {            // 省略...    }    @Override    public E getE() {        return null;    }}</code></pre><p>确定泛型：</p><pre><code class="java">/* * 使用 */public class GenericInterface {    public static void main(String[] args) {        MyImp2&lt;String&gt;  my = new MyImp2&lt;String&gt;();          my.add(&quot;aa&quot;);    }}</code></pre><h2 id="3-4-泛型通配符"><a href="#3-4-泛型通配符" class="headerlink" title="3.4  泛型通配符"></a>3.4  泛型通配符</h2><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p><h4 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h4><p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</strong></p><p>此时只能接受数据,不能往该集合中存储数据。</p><p>举个例子大家理解使用即可：</p><pre><code class="java">public static void main(String[] args) {    Collection&lt;Intger&gt; list1 = new ArrayList&lt;Integer&gt;();    getElement(list1);    Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;();    getElement(list2);}public static void getElement(Collection&lt;?&gt; coll){}//？代表可以接收任意类型</code></pre><blockquote><p>tips:泛型不存在继承关系 Collection<Object> list = new ArrayList<String>();这种是错误的。</p></blockquote><h4 id="通配符高级使用—-受限泛型"><a href="#通配符高级使用—-受限泛型" class="headerlink" title="通配符高级使用—-受限泛型"></a>通配符高级使用—-受限泛型</h4><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p><p><strong>泛型的上限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li></ul><p><strong>泛型的下限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li></ul><p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p><pre><code class="java">public static void main(String[] args) {    Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;();    Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;();    Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;();    Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;();    getElement(list1);    getElement(list2);//报错    getElement(list3);    getElement(list4);//报错    getElement2(list1);//报错    getElement2(list2);//报错    getElement2(list3);    getElement2(list4);}// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类public static void getElement1(Collection&lt;? extends Number&gt; coll){}// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类public static void getElement2(Collection&lt;? super Number&gt; coll){}</code></pre><h1 id="第四章-集合综合案例"><a href="#第四章-集合综合案例" class="headerlink" title="第四章 集合综合案例"></a>第四章 集合综合案例</h1><h2 id="4-1-案例介绍"><a href="#4-1-案例介绍" class="headerlink" title="4.1 案例介绍"></a>4.1 案例介绍</h2><p>按照斗地主的规则，完成洗牌发牌的动作。<br>具体规则：</p><p>使用54张牌打乱顺序,三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</p><h2 id="4-2-案例分析"><a href="#4-2-案例分析" class="headerlink" title="4.2 案例分析"></a>4.2 案例分析</h2><ul><li><p>准备牌：</p><p>牌可以设计为一个ArrayList<String>,每个字符串为一张牌。<br>每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。<br>牌由Collections类的shuffle方法进行随机排序。</p></li><li><p>发牌</p><p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</p></li></ul><ul><li><p>看牌</p><p>直接打印每个集合。</p></li></ul><h2 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h2><pre><code class="java">import java.util.ArrayList;import java.util.Collections;public class Poker {    public static void main(String[] args) {        /*        * 1: 准备牌操作        */        //1.1 创建牌盒 将来存储牌面的         ArrayList&lt;String&gt; pokerBox = new ArrayList&lt;String&gt;();        //1.2 创建花色集合        ArrayList&lt;String&gt; colors = new ArrayList&lt;String&gt;();        //1.3 创建数字集合        ArrayList&lt;String&gt; numbers = new ArrayList&lt;String&gt;();        //1.4 分别给花色 以及 数字集合添加元素        colors.add(&quot;♥&quot;);        colors.add(&quot;♦&quot;);        colors.add(&quot;♠&quot;);        colors.add(&quot;♣&quot;);        for(int i = 2;i&lt;=10;i++){            numbers.add(i+&quot;&quot;);        }        numbers.add(&quot;J&quot;);        numbers.add(&quot;Q&quot;);        numbers.add(&quot;K&quot;);        numbers.add(&quot;A&quot;);        //1.5 创造牌  拼接牌操作        // 拿出每一个花色  然后跟每一个数字 进行结合  存储到牌盒中        for (String color : colors) {            //color每一个花色             //遍历数字集合            for(String number : numbers){                //结合                String card = color+number;                //存储到牌盒中                pokerBox.add(card);            }        }        //1.6大王小王        pokerBox.add(&quot;小☺&quot;);        pokerBox.add(&quot;大☠&quot;);              // System.out.println(pokerBox);        //洗牌 是不是就是将  牌盒中 牌的索引打乱         // Collections类  工具类  都是 静态方法        // shuffer方法           /*         * static void shuffle(List&lt;?&gt; list)          *     使用默认随机源对指定列表进行置换。          */        //2:洗牌        Collections.shuffle(pokerBox);        //3 发牌        //3.1 创建 三个 玩家集合  创建一个底牌集合        ArrayList&lt;String&gt; player1 = new ArrayList&lt;String&gt;();        ArrayList&lt;String&gt; player2 = new ArrayList&lt;String&gt;();        ArrayList&lt;String&gt; player3 = new ArrayList&lt;String&gt;();        ArrayList&lt;String&gt; dipai = new ArrayList&lt;String&gt;();              //遍历 牌盒  必须知道索引           for(int i = 0;i&lt;pokerBox.size();i++){            //获取 牌面            String card = pokerBox.get(i);            //留出三张底牌 存到 底牌集合中            if(i&gt;=51){//存到底牌集合中                dipai.add(card);            } else {                //玩家1   %3  ==0                if(i%3==0){                      player1.add(card);                }else if(i%3==1){//玩家2                      player2.add(card);                }else{//玩家3                      player3.add(card);                }            }        }        //看看        System.out.println(&quot;令狐冲：&quot;+player1);        System.out.println(&quot;田伯光：&quot;+player2);        System.out.println(&quot;绿竹翁：&quot;+player3);        System.out.println(&quot;底牌：&quot;+dipai);      }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>lamda</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>day01【Object类、常用API】-笔记</title>
    <link href="/2017/04/02/day01%E3%80%90Object%E7%B1%BB%E3%80%81%E5%B8%B8%E7%94%A8API%E3%80%91-%E7%AC%94%E8%AE%B0/"/>
    <url>/2017/04/02/day01%E3%80%90Object%E7%B1%BB%E3%80%81%E5%B8%B8%E7%94%A8API%E3%80%91-%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="day01【Object类、常用API】"><a href="#day01【Object类、常用API】" class="headerlink" title="day01【Object类、常用API】"></a>day01【Object类、常用API】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul><li>Object类</li><li>Date类</li><li>DateFormat类</li><li>Calendar类</li><li>System类</li><li>StringBuilder类</li><li>包装类</li></ul><h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><p>-[ ] 能够说出Object类的特点<br>-[ ] 能够重写Object类的toString方法<br>-[ ] 能够重写Object类的equals方法<br>-[ ] 能够使用日期类输出当前日期<br>-[ ] 能够使用将日期格式化为字符串的方法<br>-[ ] 能够使用将字符串转换成日期的方法<br>-[ ] 能够使用System类的数组复制方法<br>-[ ] 能够使用System类获取当前毫秒时刻值<br>-[ ] 能够说出使用StringBuilder类可以解决的问题<br>-[ ] 能够使用StringBuilder进行字符串拼接操作<br>-[ ] 能够说出8种基本类型对应的包装类名称<br>-[ ] 能够说出自动装箱、自动拆箱的概念<br>-[ ] 能够将字符串转换为对应的基本类型<br>-[ ] 能够将基本类型转换为对应的字符串</p><h1 id="第一章-Object类"><a href="#第一章-Object类" class="headerlink" title="第一章 Object类"></a>第一章 Object类</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><code>java.lang.Object</code>类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。</p><p>如果一个类没有特别指定父类，    那么默认则继承自Object类。例如：</p><pre><code class="java">public class MyClass /*extends Object*/ {      // ...}</code></pre><p>根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个：</p><ul><li><code>public String toString()</code>：返回该对象的字符串表示。</li><li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li></ul><h2 id="1-2-toString方法"><a href="#1-2-toString方法" class="headerlink" title="1.2 toString方法"></a>1.2 toString方法</h2><h3 id="方法摘要"><a href="#方法摘要" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul><li><code>public String toString()</code>：返回该对象的字符串表示。</li></ul><p>toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。</p><p>由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。</p><h3 id="覆盖重写"><a href="#覆盖重写" class="headerlink" title="覆盖重写"></a>覆盖重写</h3><p>如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类：</p><pre><code class="java">public class Person {      private String name;    private int age;    @Override    public String toString() {        return &quot;Person{&quot; + &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; + &quot;, age=&quot; + age + &#39;}&#39;;    }    // 省略构造器与Getter Setter}</code></pre><p>在IntelliJ IDEA中，可以点击<code>Code</code>菜单中的<code>Generate...</code>，也可以使用快捷键<code>alt+insert</code>，点击<code>toString()</code>选项。选择需要包含的成员变量并确定。如下图所示：</p><p><img src="img%5CtoString%E6%96%B9%E6%B3%95%E7%9A%84%E8%87%AA%E5%8A%A8%E9%87%8D%E5%86%99.bmp" srcset="/img/loading.gif" alt="toString方法的自动重写"></p><blockquote><p>小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。</p></blockquote><h2 id="1-3-equals方法"><a href="#1-3-equals方法" class="headerlink" title="1.3 equals方法"></a>1.3 equals方法</h2><h3 id="方法摘要-1"><a href="#方法摘要-1" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul><li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li></ul><p>调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。</p><h3 id="默认地址比较"><a href="#默认地址比较" class="headerlink" title="默认地址比较"></a>默认地址比较</h3><p>如果没有覆盖重写equals方法，那么Object类中默认进行<code>==</code>运算符的对象地址比较，只要不是同一个对象，结果必然为false。</p><h3 id="对象内容比较"><a href="#对象内容比较" class="headerlink" title="对象内容比较"></a>对象内容比较</h3><p>如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如：</p><pre><code class="java">import java.util.Objects;public class Person {        private String name;    private int age;    @Override    public boolean equals(Object o) {        // 如果对象地址一样，则认为相同        if (this == o)            return true;        // 如果参数为空，或者类型信息不一样，则认为不同        if (o == null || getClass() != o.getClass())            return false;        // 转换为当前类型        Person person = (Person) o;        // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果        return age == person.age &amp;&amp; Objects.equals(name, person.name);    }}</code></pre><p>这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用<code>Code</code>菜单中的<code>Generate…</code>选项，也可以使用快捷键<code>alt+insert</code>，并选择<code>equals() and hashCode()</code>进行自动代码生成。如下图所示：</p><p><img src="img%5Cequals%E6%96%B9%E6%B3%951.png" srcset="/img/loading.gif" alt=""></p><p><img src="img%5Cequals%E6%96%B9%E6%B3%952.png" srcset="/img/loading.gif" alt=""></p><p><img src="img%5Cequals%E6%96%B9%E6%B3%953.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>tips：Object类当中的hashCode等其他方法，今后学习。</p></blockquote><h2 id="1-4-Objects类"><a href="#1-4-Objects类" class="headerlink" title="1.4 Objects类"></a>1.4 Objects类</h2><p>在刚才IDEA自动重写equals代码中，使用到了<code>java.util.Objects</code>类，那么这个类是什么呢？</p><p>在<strong>JDK7</strong>添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。</p><p>在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下：</p><ul><li><code>public static boolean equals(Object a, Object b)</code>:判断两个对象是否相等。</li></ul><p>我们可以查看一下源码，学习一下：</p><pre><code class="java">public static boolean equals(Object a, Object b) {      return (a == b) || (a != null &amp;&amp; a.equals(b));  }</code></pre><h1 id="第二章-日期时间类"><a href="#第二章-日期时间类" class="headerlink" title="第二章 日期时间类"></a>第二章 日期时间类</h1><h2 id="2-1-Date类"><a href="#2-1-Date类" class="headerlink" title="2.1 Date类"></a>2.1 Date类</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>java.util.Date</code>类 表示特定的瞬间，精确到毫秒。</p><p>继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。</p><ul><li><code>public Date()</code>：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。</li><li><code>public Date(long date)</code>：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。</li></ul><blockquote><p>tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。</p></blockquote><p>简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如：</p><pre><code class="java">import java.util.Date;public class Demo01Date {    public static void main(String[] args) {        // 创建日期对象，把当前的时间        System.out.println(new Date()); // Tue Jan 16 14:37:35 CST 2018        // 创建日期对象，把当前的毫秒值转成日期对象        System.out.println(new Date(0L)); // Thu Jan 01 08:00:00 CST 1970    }}</code></pre><blockquote><p>tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。</p></blockquote><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>Date类中的多数方法已经过时，常用的方法有：</p><ul><li><code>public long getTime()</code> 把日期对象转换成对应的时间毫秒值。</li></ul><h2 id="2-2-DateFormat类"><a href="#2-2-DateFormat类" class="headerlink" title="2.2 DateFormat类"></a>2.2 DateFormat类</h2><p><code>java.text.DateFormat</code> 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。</p><ul><li><strong>格式化</strong>：按照指定的格式，从Date对象转换为String对象。</li><li><strong>解析</strong>：按照指定的格式，从String对象转换为Date对象。</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>由于DateFormat为抽象类，不能直接使用，所以需要常用的子类<code>java.text.SimpleDateFormat</code>。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为：</p><ul><li><code>public SimpleDateFormat(String pattern)</code>：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。</li></ul><p>参数pattern是一个字符串，代表日期时间的自定义格式。</p><h3 id="格式规则"><a href="#格式规则" class="headerlink" title="格式规则"></a>格式规则</h3><p>常用的格式规则为：</p><table><thead><tr><th>标识字母（区分大小写）</th><th>含义</th></tr></thead><tbody><tr><td>y</td><td>年</td></tr><tr><td>M</td><td>月</td></tr><tr><td>d</td><td>日</td></tr><tr><td>H</td><td>时</td></tr><tr><td>m</td><td>分</td></tr><tr><td>s</td><td>秒</td></tr></tbody></table><blockquote><p>备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。</p></blockquote><p>创建SimpleDateFormat对象的代码如：</p><pre><code class="java">import java.text.DateFormat;import java.text.SimpleDateFormat;public class Demo02SimpleDateFormat {    public static void main(String[] args) {        // 对应的日期格式如：2018-01-16 15:06:38        DateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);    }    }</code></pre><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><p>DateFormat类的常用方法有：</p><ul><li><code>public String format(Date date)</code>：将Date对象格式化为字符串。</li><li><code>public Date parse(String source)</code>：将字符串解析为Date对象。</li></ul><h4 id="format方法"><a href="#format方法" class="headerlink" title="format方法"></a>format方法</h4><p>使用format方法的代码为：</p><pre><code class="java">import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;/* 把Date对象转换成String*/public class Demo03DateFormatMethod {    public static void main(String[] args) {        Date date = new Date();        // 创建日期格式化对象,在获取格式化对象时可以指定风格        DateFormat df = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;);        String str = df.format(date);        System.out.println(str); // 2008年1月23日    }}</code></pre><h4 id="parse方法"><a href="#parse方法" class="headerlink" title="parse方法"></a>parse方法</h4><p>使用parse方法的代码为：</p><pre><code class="java">import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/* 把String转换成Date对象*/public class Demo04DateFormatMethod {    public static void main(String[] args) throws ParseException {        DateFormat df = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;);        String str = &quot;2018年12月11日&quot;;        Date date = df.parse(str);        System.out.println(date); // Tue Dec 11 00:00:00 CST 2018    }}</code></pre><h2 id="2-3-练习"><a href="#2-3-练习" class="headerlink" title="2.3 练习"></a>2.3 练习</h2><p>请使用日期时间相关的API，计算出一个人已经出生了多少天。</p><p><strong>思路：</strong></p><p>1.获取当前时间对应的毫秒值</p><p>2.获取自己出生日期对应的毫秒值</p><p>3.两个时间相减（当前时间– 出生日期）</p><p><strong>代码实现：</strong></p><pre><code class="java">public static void function() throws Exception {    System.out.println(&quot;请输入出生日期 格式 YYYY-MM-dd&quot;);    // 获取出生日期,键盘输入    String birthdayString = new Scanner(System.in).next();    // 将字符串日期,转成Date对象    // 创建SimpleDateFormat对象,写日期模式    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);    // 调用方法parse,字符串转成日期对象    Date birthdayDate = sdf.parse(birthdayString);        // 获取今天的日期对象    Date todayDate = new Date();        // 将两个日期转成毫秒值,Date类的方法getTime    long birthdaySecond = birthdayDate.getTime();    long todaySecond = todayDate.getTime();    long secone = todaySecond-birthdaySecond;        if (secone &lt; 0){        System.out.println(&quot;还没出生呢&quot;);    } else {        System.out.println(secone/1000/60/60/24);    }}</code></pre><h2 id="2-4-Calendar类"><a href="#2-4-Calendar类" class="headerlink" title="2.4 Calendar类"></a>2.4 Calendar类</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>日历我们都见过</p><p><img src="img%5C%E6%97%A5%E5%8E%86.jpg" srcset="/img/loading.gif" alt=""></p><p><code>java.util.Calendar</code>是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。</p><h3 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h3><p>Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下：</p><p>Calendar静态方法</p><ul><li><code>public static Calendar getInstance()</code>：使用默认时区和语言环境获得一个日历</li></ul><p>例如：</p><pre><code class="java">import java.util.Calendar;public class Demo06CalendarInit {    public static void main(String[] args) {        Calendar cal = Calendar.getInstance();    }    }</code></pre><h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><p>根据Calendar类的API文档，常用方法有：</p><ul><li><code>public int get(int field)</code>：返回给定日历字段的值。</li><li><code>public void set(int field, int value)</code>：将给定的日历字段设置为给定值。</li><li><code>public abstract void add(int field, int amount)</code>：根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li><li><code>public Date getTime()</code>：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。</li></ul><p>Calendar类中提供很多成员常量，代表给定的日历字段：</p><table><thead><tr><th>字段值</th><th>含义</th></tr></thead><tbody><tr><td>YEAR</td><td>年</td></tr><tr><td>MONTH</td><td>月（从0开始，可以+1使用）</td></tr><tr><td>DAY_OF_MONTH</td><td>月中的天（几号）</td></tr><tr><td>HOUR</td><td>时（12小时制）</td></tr><tr><td>HOUR_OF_DAY</td><td>时（24小时制）</td></tr><tr><td>MINUTE</td><td>分</td></tr><tr><td>SECOND</td><td>秒</td></tr><tr><td>DAY_OF_WEEK</td><td>周中的天（周几，周日为1，可以-1使用）</td></tr></tbody></table><h4 id="get-set方法"><a href="#get-set方法" class="headerlink" title="get/set方法"></a>get/set方法</h4><p>get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示：</p><pre><code class="java">import java.util.Calendar;public class CalendarUtil {    public static void main(String[] args) {        // 创建Calendar对象        Calendar cal = Calendar.getInstance();        // 设置年         int year = cal.get(Calendar.YEAR);        // 设置月        int month = cal.get(Calendar.MONTH) + 1;        // 设置日        int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);        System.out.print(year + &quot;年&quot; + month + &quot;月&quot; + dayOfMonth + &quot;日&quot;);    }    }</code></pre><pre><code class="java">import java.util.Calendar;public class Demo07CalendarMethod {    public static void main(String[] args) {        Calendar cal = Calendar.getInstance();        cal.set(Calendar.YEAR, 2020);        System.out.print(year + &quot;年&quot; + month + &quot;月&quot; + dayOfMonth + &quot;日&quot;); // 2020年1月17日    }}</code></pre><h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p>add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如：</p><pre><code class="java">import java.util.Calendar;public class Demo08CalendarMethod {    public static void main(String[] args) {        Calendar cal = Calendar.getInstance();        System.out.print(year + &quot;年&quot; + month + &quot;月&quot; + dayOfMonth + &quot;日&quot;); // 2018年1月17日        // 使用add方法        cal.add(Calendar.DAY_OF_MONTH, 2); // 加2天        cal.add(Calendar.YEAR, -3); // 减3年        System.out.print(year + &quot;年&quot; + month + &quot;月&quot; + dayOfMonth + &quot;日&quot;); // 2015年1月18日;     }}</code></pre><h4 id="getTime方法"><a href="#getTime方法" class="headerlink" title="getTime方法"></a>getTime方法</h4><p>Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。</p><pre><code class="java">import java.util.Calendar;import java.util.Date;public class Demo09CalendarMethod {    public static void main(String[] args) {        Calendar cal = Calendar.getInstance();        Date date = cal.getTime();        System.out.println(date); // Tue Jan 16 16:03:09 CST 2018    }}</code></pre><blockquote><p>小贴士：</p><p>​     西方星期的开始为周日，中国为周一。</p><p>​     在Calendar类中，月份的表示是以0-11代表1-12月。</p><p>​     日期是有大小关系的，时间靠后，时间越大。</p></blockquote><h1 id="第三章-System类"><a href="#第三章-System类" class="headerlink" title="第三章 System类"></a>第三章 System类</h1><p><code>java.lang.System</code>类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有：</p><ul><li><code>public static long currentTimeMillis()</code>：返回以毫秒为单位的当前时间。</li><li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li></ul><h2 id="3-1-currentTimeMillis方法"><a href="#3-1-currentTimeMillis方法" class="headerlink" title="3.1 currentTimeMillis方法"></a>3.1 currentTimeMillis方法</h2><p>实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值</p><pre><code class="java">import java.util.Date;public class SystemDemo {    public static void main(String[] args) {           //获取当前时间毫秒值        System.out.println(System.currentTimeMillis()); // 1516090531144    }}</code></pre><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>验证for循环打印数字1-9999所需要使用的时间（毫秒）</p><pre><code class="java">public class SystemTest1 {    public static void main(String[] args) {        long start = System.currentTimeMillis();        for (int i = 0; i &lt; 10000; i++) {            System.out.println(i);        }        long end = System.currentTimeMillis();        System.out.println(&quot;共耗时毫秒：&quot; + (end - start));    }}</code></pre><h2 id="3-2-arraycopy方法"><a href="#3-2-arraycopy方法" class="headerlink" title="3.2 arraycopy方法"></a>3.2 arraycopy方法</h2><ul><li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li></ul><p>数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为：</p><table><thead><tr><th>参数序号</th><th>参数名称</th><th>参数类型</th><th>参数含义</th></tr></thead><tbody><tr><td>1</td><td>src</td><td>Object</td><td>源数组</td></tr><tr><td>2</td><td>srcPos</td><td>int</td><td>源数组索引起始位置</td></tr><tr><td>3</td><td>dest</td><td>Object</td><td>目标数组</td></tr><tr><td>4</td><td>destPos</td><td>int</td><td>目标数组索引起始位置</td></tr><tr><td>5</td><td>length</td><td>int</td><td>复制元素个数</td></tr></tbody></table><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><p>将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10]</p><pre><code class="java">import java.util.Arrays;public class Demo11SystemArrayCopy {    public static void main(String[] args) {        int[] src = new int[]{1,2,3,4,5};        int[] dest = new int[]{6,7,8,9,10};        System.arraycopy( src, 0, dest, 0, 3);        /*代码运行后：两个数组中的元素发生了变化         src数组元素[1,2,3,4,5]         dest数组元素[1,2,3,9,10]        */    }}</code></pre><h1 id="第四章-StringBuilder类"><a href="#第四章-StringBuilder类" class="headerlink" title="第四章 StringBuilder类"></a>第四章 StringBuilder类</h1><h2 id="4-1-字符串拼接问题"><a href="#4-1-字符串拼接问题" class="headerlink" title="4.1 字符串拼接问题"></a>4.1 字符串拼接问题</h2><p>由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如：</p><pre><code class="java">public class StringDemo {    public static void main(String[] args) {        String s = &quot;Hello&quot;;        s += &quot;World&quot;;        System.out.println(s);    }}</code></pre><p>在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。</p><p>根据这句话分析我们的代码，其实总共产生了三个字符串，即<code>&quot;Hello&quot;</code>、<code>&quot;World&quot;</code>和<code>&quot;HelloWorld&quot;</code>。引用变量s首先指向<code>Hello</code>对象，最终指向拼接出来的新字符串对象，即<code>HelloWord</code> 。</p><p><img src="img%5CString%E6%8B%BC%E6%8E%A5%E9%97%AE%E9%A2%98.bmp" srcset="/img/loading.gif" alt=""></p><p>由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用<code>java.lang.StringBuilder</code>类。</p><h2 id="4-2-StringBuilder概述"><a href="#4-2-StringBuilder概述" class="headerlink" title="4.2 StringBuilder概述"></a>4.2 StringBuilder概述</h2><p>查阅<code>java.lang.StringBuilder</code>的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。</p><p>原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。</p><p>它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充)</p><p><img src="img%5C06-StringBuilder%E7%9A%84%E5%8E%9F%E7%90%86.png" srcset="/img/loading.gif" alt="06-StringBuilder的原理"></p><h2 id="4-3-构造方法"><a href="#4-3-构造方法" class="headerlink" title="4.3 构造方法"></a>4.3 构造方法</h2><p>根据StringBuilder的API文档，常用构造方法有2个：</p><ul><li><code>public StringBuilder()</code>：构造一个空的StringBuilder容器。</li><li><code>public StringBuilder(String str)</code>：构造一个StringBuilder容器，并将字符串添加进去。</li></ul><pre><code class="java">public class StringBuilderDemo {    public static void main(String[] args) {        StringBuilder sb1 = new StringBuilder();        System.out.println(sb1); // (空白)        // 使用带参构造        StringBuilder sb2 = new StringBuilder(&quot;itcast&quot;);        System.out.println(sb2); // itcast    }}</code></pre><h2 id="4-4-常用方法"><a href="#4-4-常用方法" class="headerlink" title="4.4 常用方法"></a>4.4 常用方法</h2><p>StringBuilder常用的方法有2个：</p><ul><li><code>public StringBuilder append(...)</code>：添加任意类型数据的字符串形式，并返回当前对象自身。</li><li><code>public String toString()</code>：将当前StringBuilder对象转换为String对象。</li></ul><h3 id="append方法"><a href="#append方法" class="headerlink" title="append方法"></a>append方法</h3><p>append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如：</p><pre><code class="java">public class Demo02StringBuilder {    public static void main(String[] args) {        //创建对象        StringBuilder builder = new StringBuilder();        //public StringBuilder append(任意类型)        StringBuilder builder2 = builder.append(&quot;hello&quot;);        //对比一下        System.out.println(&quot;builder:&quot;+builder);        System.out.println(&quot;builder2:&quot;+builder2);        System.out.println(builder == builder2); //true        // 可以添加 任何类型        builder.append(&quot;hello&quot;);        builder.append(&quot;world&quot;);        builder.append(true);        builder.append(100);        // 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。        // 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下        //链式编程        builder.append(&quot;hello&quot;).append(&quot;world&quot;).append(true).append(100);        System.out.println(&quot;builder:&quot;+builder);    }}</code></pre><blockquote><p>备注：StringBuilder已经覆盖重写了Object当中的toString方法。</p></blockquote><h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><p>通过toString方法，StringBuilder对象将会转换为不可变的String对象。如：</p><pre><code class="java">public class Demo16StringBuilder {    public static void main(String[] args) {        // 链式创建        StringBuilder sb = new StringBuilder(&quot;Hello&quot;).append(&quot;World&quot;).append(&quot;Java&quot;);        // 调用方法        String str = sb.toString();        System.out.println(str); // HelloWorldJava    }}</code></pre><h1 id="第五章-包装类"><a href="#第五章-包装类" class="headerlink" title="第五章 包装类"></a>第五章 包装类</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：</p><table><thead><tr><th>基本类型</th><th>对应的包装类（位于java.lang包中）</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td><strong>Integer</strong></td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td><strong>Character</strong></td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h2 id="5-2-装箱与拆箱"><a href="#5-2-装箱与拆箱" class="headerlink" title="5.2 装箱与拆箱"></a>5.2 装箱与拆箱</h2><p>基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：</p><ul><li><p><strong>装箱</strong>：从基本类型转换为对应的包装类对象。</p></li><li><p><strong>拆箱</strong>：从包装类对象转换为对应的基本类型。</p></li></ul><p>用Integer与 int为例：（看懂代码即可）</p><p>基本数值—-&gt;包装对象</p><pre><code class="java">Integer i = new Integer(4);//使用构造函数函数Integer iii = Integer.valueOf(4);//使用包装类中的valueOf方法</code></pre><p>包装对象—-&gt;基本数值</p><pre><code class="java">int num = i.intValue();</code></pre><h2 id="5-3自动装箱与自动拆箱"><a href="#5-3自动装箱与自动拆箱" class="headerlink" title="5.3自动装箱与自动拆箱"></a>5.3自动装箱与自动拆箱</h2><p>由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：</p><pre><code class="java">Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;//加法运算完成后，再次装箱，把基本数值转成对象。</code></pre><h2 id="5-3-基本类型与字符串之间的转换"><a href="#5-3-基本类型与字符串之间的转换" class="headerlink" title="5.3 基本类型与字符串之间的转换"></a>5.3 基本类型与字符串之间的转换</h2><h3 id="基本类型转换为String"><a href="#基本类型转换为String" class="headerlink" title="基本类型转换为String"></a>基本类型转换为String</h3><p>   基本类型转换String总共有三种方式，查看课后资料可以得知，这里只讲最简单的一种方式： </p><pre><code>基本类型直接与””相连接即可；如：34+&quot;&quot;</code></pre><p>String转换成对应的基本类型 </p><p>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：</p><ul><li><code>public static byte parseByte(String s)</code>：将字符串参数转换为对应的byte基本类型。</li><li><code>public static short parseShort(String s)</code>：将字符串参数转换为对应的short基本类型。</li><li><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</li><li><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</li><li><code>public static float parseFloat(String s)</code>：将字符串参数转换为对应的float基本类型。</li><li><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</li><li><code>public static boolean parseBoolean(String s)</code>：将字符串参数转换为对应的boolean基本类型。</li></ul><p>代码使用（仅以Integer类的静态方法parseXxx为例）如：</p><pre><code class="java">public class Demo18WrapperParse {    public static void main(String[] args) {        int num = Integer.parseInt(&quot;100&quot;);    }}</code></pre><blockquote><p>注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出<code>java.lang.NumberFormatException</code>异常。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>lamda</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Hexo」将文章发布到hexo博客</title>
    <link href="/2016/08/05/%E5%B0%86%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E5%88%B0hexo%E5%8D%9A%E5%AE%A2/"/>
    <url>/2016/08/05/%E5%B0%86%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E5%88%B0hexo%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="将文章发布到hexo博客"><a href="#将文章发布到hexo博客" class="headerlink" title="将文章发布到hexo博客"></a>将文章发布到hexo博客</h2><hr><p>1.将内容写入 markdown.md 文件；然后找到这个md文件，把它复制到你hexo博客文件夹 中 source 下的 _posts 中，默认只有一个 hello-world.md；</p><p>2.复制完之后然后使用文本编辑器打开它，在第一行加上title，内容自定title: this is my first blog  </p><p>3.接着在你博客站点文件夹下右键空白处，选择Git Bash Here，输入 hexo g (完整命令为hexo generate)，用于生成静态文件</p><p>4 然后 输入 hexo s(完整命令为hexo server)，用于启动服务器，主要用来本地预览；完成后 打开浏览器输入 localhost:4000，会发现多了你刚写的那篇博客</p><p>5 最后输入hexo d(hexo deploy)，用于将本地文件发布到github等git仓库上；</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Hexo」使用Github Pages+Hexo搭建博客</title>
    <link href="/2016/08/05/%E4%BD%BF%E7%94%A8Github%20Pages+Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2016/08/05/%E4%BD%BF%E7%94%A8Github%20Pages+Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://www.jianshu.com/p/856aaace865a" target="_blank" rel="noopener">https://www.jianshu.com/p/856aaace865a</a><br><a href="https://www.jianshu.com/p/7dcd97c8e0e3" target="_blank" rel="noopener">https://www.jianshu.com/p/7dcd97c8e0e3</a></p>]]></content>
    
    
    <categories>
      
      <category>github</category>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Tool」常用工具汇总</title>
    <link href="/2016/06/18/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/"/>
    <url>/2016/06/18/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/example.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="「Tool」常用工具汇总"><a href="#「Tool」常用工具汇总" class="headerlink" title="「Tool」常用工具汇总"></a>「Tool」常用工具汇总</h2><p><strong>PC:(何必来回折腾,工具而已)</strong></p><ol><li><p>IDEA(吃饭的家伙)</p></li><li><p>VsCode</p></li><li><p>VM</p></li><li><p>火绒</p></li><li><p>Everthing</p></li><li><p>Listary(搜索神器)</p></li><li><p>Edge/360急速浏览器</p></li><li><p>Xmind</p></li><li><p>印象笔记/OneNote</p></li><li><p>腾讯桌面整理</p></li><li><p>Foxit Reader</p><p><strong>推荐:</strong></p><p> <a href="https://mp.weixin.qq.com/s/zyBzWj0lCvQEYGK4AWCkAA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/zyBzWj0lCvQEYGK4AWCkAA</a></p></li></ol><hr>]]></content>
    
    
    <categories>
      
      <category>Tool</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
